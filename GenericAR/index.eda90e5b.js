// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"3BwQ7":[function(require,module,exports) {
"use strict";
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "1f2220aaeda90e5b";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id1][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"eSWDu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ModelViewerElement", ()=>ab);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ const t103 = (t9, e1)=>"method" === e1.kind && e1.descriptor && !("value" in e1.descriptor) ? {
        ...e1,
        finisher (n1) {
            n1.createProperty(e1.key, t9);
        }
    } : {
        kind: "field",
        key: Symbol(),
        placement: "own",
        descriptor: {},
        originalKey: e1.key,
        initializer () {
            "function" == typeof e1.initializer && (this[e1.key] = e1.initializer.call(this));
        },
        finisher (n2) {
            n2.createProperty(e1.key, t9);
        }
    };
function e(e2) {
    return (n3, i1)=>void 0 !== i1 ? ((t10, e3, n4)=>{
            e3.constructor.createProperty(n4, t10);
        })(e2, n3, i1) : t103(e2, n3);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ }
var n;
null === (n = window.HTMLSlotElement) || void 0 === n || n.prototype.assignedElements;
class i {
    addEventListener(t11, e4) {
        void 0 === this._listeners && (this._listeners = {});
        const n5 = this._listeners;
        void 0 === n5[t11] && (n5[t11] = []), -1 === n5[t11].indexOf(e4) && n5[t11].push(e4);
    }
    hasEventListener(t12, e5) {
        if (void 0 === this._listeners) return !1;
        const n6 = this._listeners;
        return void 0 !== n6[t12] && -1 !== n6[t12].indexOf(e5);
    }
    removeEventListener(t13, e6) {
        if (void 0 === this._listeners) return;
        const n7 = this._listeners[t13];
        if (void 0 !== n7) {
            const t14 = n7.indexOf(e6);
            -1 !== t14 && n7.splice(t14, 1);
        }
    }
    dispatchEvent(t15) {
        if (void 0 === this._listeners) return;
        const e7 = this._listeners[t15.type];
        if (void 0 !== e7) {
            t15.target = this;
            const n8 = e7.slice(0);
            for(let e8 = 0, i2 = n8.length; e8 < i2; e8++)n8[e8].call(this, t15);
            t15.target = null;
        }
    }
}
const r = [];
for(let t1 = 0; t1 < 256; t1++)r[t1] = (t1 < 16 ? "0" : "") + t1.toString(16);
let s = 1234567;
const a = Math.PI / 180, o = 180 / Math.PI;
function l() {
    const t16 = 4294967295 * Math.random() | 0, e9 = 4294967295 * Math.random() | 0, n9 = 4294967295 * Math.random() | 0, i3 = 4294967295 * Math.random() | 0;
    return (r[255 & t16] + r[t16 >> 8 & 255] + r[t16 >> 16 & 255] + r[t16 >> 24 & 255] + "-" + r[255 & e9] + r[e9 >> 8 & 255] + "-" + r[e9 >> 16 & 15 | 64] + r[e9 >> 24 & 255] + "-" + r[63 & n9 | 128] + r[n9 >> 8 & 255] + "-" + r[n9 >> 16 & 255] + r[n9 >> 24 & 255] + r[255 & i3] + r[i3 >> 8 & 255] + r[i3 >> 16 & 255] + r[i3 >> 24 & 255]).toLowerCase();
}
function h(t17, e10, n10) {
    return Math.max(e10, Math.min(n10, t17));
}
function c(t18, e11) {
    return (t18 % e11 + e11) % e11;
}
function u(t19, e12, n11) {
    return (1 - n11) * t19 + n11 * e12;
}
function d(t20) {
    return 0 == (t20 & t20 - 1) && 0 !== t20;
}
function p(t21) {
    return Math.pow(2, Math.ceil(Math.log(t21) / Math.LN2));
}
function m(t22) {
    return Math.pow(2, Math.floor(Math.log(t22) / Math.LN2));
}
var f = Object.freeze({
    __proto__: null,
    DEG2RAD: a,
    RAD2DEG: o,
    generateUUID: l,
    clamp: h,
    euclideanModulo: c,
    mapLinear: function(t23, e13, n12, i4, r1) {
        return i4 + (t23 - e13) * (r1 - i4) / (n12 - e13);
    },
    inverseLerp: function(t24, e14, n13) {
        return t24 !== e14 ? (n13 - t24) / (e14 - t24) : 0;
    },
    lerp: u,
    damp: function(t25, e15, n14, i5) {
        return u(t25, e15, 1 - Math.exp(-n14 * i5));
    },
    pingpong: function(t26, e16 = 1) {
        return e16 - Math.abs(c(t26, 2 * e16) - e16);
    },
    smoothstep: function(t27, e17, n15) {
        return t27 <= e17 ? 0 : t27 >= n15 ? 1 : (t27 = (t27 - e17) / (n15 - e17)) * t27 * (3 - 2 * t27);
    },
    smootherstep: function(t28, e18, n16) {
        return t28 <= e18 ? 0 : t28 >= n16 ? 1 : (t28 = (t28 - e18) / (n16 - e18)) * t28 * t28 * (t28 * (6 * t28 - 15) + 10);
    },
    randInt: function(t29, e19) {
        return t29 + Math.floor(Math.random() * (e19 - t29 + 1));
    },
    randFloat: function(t30, e20) {
        return t30 + Math.random() * (e20 - t30);
    },
    randFloatSpread: function(t31) {
        return t31 * (.5 - Math.random());
    },
    seededRandom: function(t32) {
        void 0 !== t32 && (s = t32);
        let e21 = s += 1831565813;
        return e21 = Math.imul(e21 ^ e21 >>> 15, 1 | e21), e21 ^= e21 + Math.imul(e21 ^ e21 >>> 7, 61 | e21), ((e21 ^ e21 >>> 14) >>> 0) / 4294967296;
    },
    degToRad: function(t33) {
        return t33 * a;
    },
    radToDeg: function(t34) {
        return t34 * o;
    },
    isPowerOfTwo: d,
    ceilPowerOfTwo: p,
    floorPowerOfTwo: m,
    setQuaternionFromProperEuler: function(t35, e22, n17, i6, r2) {
        const s1 = Math.cos, a1 = Math.sin, o1 = s1(n17 / 2), l1 = a1(n17 / 2), h1 = s1((e22 + i6) / 2), c1 = a1((e22 + i6) / 2), u1 = s1((e22 - i6) / 2), d1 = a1((e22 - i6) / 2), p1 = s1((i6 - e22) / 2), m1 = a1((i6 - e22) / 2);
        switch(r2){
            case "XYX":
                t35.set(o1 * c1, l1 * u1, l1 * d1, o1 * h1);
                break;
            case "YZY":
                t35.set(l1 * d1, o1 * c1, l1 * u1, o1 * h1);
                break;
            case "ZXZ":
                t35.set(l1 * u1, l1 * d1, o1 * c1, o1 * h1);
                break;
            case "XZX":
                t35.set(o1 * c1, l1 * m1, l1 * p1, o1 * h1);
                break;
            case "YXY":
                t35.set(l1 * p1, o1 * c1, l1 * m1, o1 * h1);
                break;
            case "ZYZ":
                t35.set(l1 * m1, l1 * p1, o1 * c1, o1 * h1);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r2);
        }
    },
    normalize: function(t36, e23) {
        switch(e23.constructor){
            case Float32Array:
                return t36;
            case Uint16Array:
                return Math.round(65535 * t36);
            case Uint8Array:
                return Math.round(255 * t36);
            case Int16Array:
                return Math.round(32767 * t36);
            case Int8Array:
                return Math.round(127 * t36);
            default:
                throw new Error("Invalid component type.");
        }
    },
    denormalize: function(t37, e24) {
        switch(e24.constructor){
            case Float32Array:
                return t37;
            case Uint16Array:
                return t37 / 65535;
            case Uint8Array:
                return t37 / 255;
            case Int16Array:
                return Math.max(t37 / 32767, -1);
            case Int8Array:
                return Math.max(t37 / 127, -1);
            default:
                throw new Error("Invalid component type.");
        }
    }
});
class g {
    constructor(t38 = 0, e25 = 0){
        this.x = t38, this.y = e25;
    }
    get width() {
        return this.x;
    }
    set width(t39) {
        this.x = t39;
    }
    get height() {
        return this.y;
    }
    set height(t40) {
        this.y = t40;
    }
    set(t41, e26) {
        return this.x = t41, this.y = e26, this;
    }
    setScalar(t42) {
        return this.x = t42, this.y = t42, this;
    }
    setX(t43) {
        return this.x = t43, this;
    }
    setY(t44) {
        return this.y = t44, this;
    }
    setComponent(t45, e27) {
        switch(t45){
            case 0:
                this.x = e27;
                break;
            case 1:
                this.y = e27;
                break;
            default:
                throw new Error("index is out of range: " + t45);
        }
        return this;
    }
    getComponent(t46) {
        switch(t46){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t46);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(t47) {
        return this.x = t47.x, this.y = t47.y, this;
    }
    add(t48, e28) {
        return void 0 !== e28 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t48, e28)) : (this.x += t48.x, this.y += t48.y, this);
    }
    addScalar(t49) {
        return this.x += t49, this.y += t49, this;
    }
    addVectors(t50, e29) {
        return this.x = t50.x + e29.x, this.y = t50.y + e29.y, this;
    }
    addScaledVector(t51, e30) {
        return this.x += t51.x * e30, this.y += t51.y * e30, this;
    }
    sub(t52, e31) {
        return void 0 !== e31 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t52, e31)) : (this.x -= t52.x, this.y -= t52.y, this);
    }
    subScalar(t53) {
        return this.x -= t53, this.y -= t53, this;
    }
    subVectors(t54, e32) {
        return this.x = t54.x - e32.x, this.y = t54.y - e32.y, this;
    }
    multiply(t55) {
        return this.x *= t55.x, this.y *= t55.y, this;
    }
    multiplyScalar(t56) {
        return this.x *= t56, this.y *= t56, this;
    }
    divide(t57) {
        return this.x /= t57.x, this.y /= t57.y, this;
    }
    divideScalar(t58) {
        return this.multiplyScalar(1 / t58);
    }
    applyMatrix3(t59) {
        const e33 = this.x, n18 = this.y, i7 = t59.elements;
        return this.x = i7[0] * e33 + i7[3] * n18 + i7[6], this.y = i7[1] * e33 + i7[4] * n18 + i7[7], this;
    }
    min(t60) {
        return this.x = Math.min(this.x, t60.x), this.y = Math.min(this.y, t60.y), this;
    }
    max(t61) {
        return this.x = Math.max(this.x, t61.x), this.y = Math.max(this.y, t61.y), this;
    }
    clamp(t62, e34) {
        return this.x = Math.max(t62.x, Math.min(e34.x, this.x)), this.y = Math.max(t62.y, Math.min(e34.y, this.y)), this;
    }
    clampScalar(t63, e35) {
        return this.x = Math.max(t63, Math.min(e35, this.x)), this.y = Math.max(t63, Math.min(e35, this.y)), this;
    }
    clampLength(t64, e36) {
        const n19 = this.length();
        return this.divideScalar(n19 || 1).multiplyScalar(Math.max(t64, Math.min(e36, n19)));
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this;
    }
    dot(t65) {
        return this.x * t65.x + this.y * t65.y;
    }
    cross(t66) {
        return this.x * t66.y - this.y * t66.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(t67) {
        return Math.sqrt(this.distanceToSquared(t67));
    }
    distanceToSquared(t68) {
        const e37 = this.x - t68.x, n20 = this.y - t68.y;
        return e37 * e37 + n20 * n20;
    }
    manhattanDistanceTo(t69) {
        return Math.abs(this.x - t69.x) + Math.abs(this.y - t69.y);
    }
    setLength(t70) {
        return this.normalize().multiplyScalar(t70);
    }
    lerp(t71, e38) {
        return this.x += (t71.x - this.x) * e38, this.y += (t71.y - this.y) * e38, this;
    }
    lerpVectors(t72, e39, n21) {
        return this.x = t72.x + (e39.x - t72.x) * n21, this.y = t72.y + (e39.y - t72.y) * n21, this;
    }
    equals(t73) {
        return t73.x === this.x && t73.y === this.y;
    }
    fromArray(t74, e40 = 0) {
        return this.x = t74[e40], this.y = t74[e40 + 1], this;
    }
    toArray(t75 = [], e41 = 0) {
        return t75[e41] = this.x, t75[e41 + 1] = this.y, t75;
    }
    fromBufferAttribute(t76, e42, n22) {
        return void 0 !== n22 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t76.getX(e42), this.y = t76.getY(e42), this;
    }
    rotateAround(t77, e43) {
        const n23 = Math.cos(e43), i8 = Math.sin(e43), r3 = this.x - t77.x, s2 = this.y - t77.y;
        return this.x = r3 * n23 - s2 * i8 + t77.x, this.y = r3 * i8 + s2 * n23 + t77.y, this;
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y;
    }
}
g.prototype.isVector2 = !0;
class v {
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t78, e44, n24, i9, r4, s3, a2, o2, l2) {
        const h2 = this.elements;
        return h2[0] = t78, h2[1] = i9, h2[2] = a2, h2[3] = e44, h2[4] = r4, h2[5] = o2, h2[6] = n24, h2[7] = s3, h2[8] = l2, this;
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t79) {
        const e45 = this.elements, n25 = t79.elements;
        return e45[0] = n25[0], e45[1] = n25[1], e45[2] = n25[2], e45[3] = n25[3], e45[4] = n25[4], e45[5] = n25[5], e45[6] = n25[6], e45[7] = n25[7], e45[8] = n25[8], this;
    }
    extractBasis(t80, e46, n26) {
        return t80.setFromMatrix3Column(this, 0), e46.setFromMatrix3Column(this, 1), n26.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(t81) {
        const e47 = t81.elements;
        return this.set(e47[0], e47[4], e47[8], e47[1], e47[5], e47[9], e47[2], e47[6], e47[10]), this;
    }
    multiply(t82) {
        return this.multiplyMatrices(this, t82);
    }
    premultiply(t83) {
        return this.multiplyMatrices(t83, this);
    }
    multiplyMatrices(t84, e48) {
        const n27 = t84.elements, i10 = e48.elements, r5 = this.elements, s4 = n27[0], a3 = n27[3], o3 = n27[6], l3 = n27[1], h3 = n27[4], c2 = n27[7], u2 = n27[2], d2 = n27[5], p2 = n27[8], m2 = i10[0], f1 = i10[3], g1 = i10[6], v1 = i10[1], y1 = i10[4], x1 = i10[7], b1 = i10[2], _1 = i10[5], w1 = i10[8];
        return r5[0] = s4 * m2 + a3 * v1 + o3 * b1, r5[3] = s4 * f1 + a3 * y1 + o3 * _1, r5[6] = s4 * g1 + a3 * x1 + o3 * w1, r5[1] = l3 * m2 + h3 * v1 + c2 * b1, r5[4] = l3 * f1 + h3 * y1 + c2 * _1, r5[7] = l3 * g1 + h3 * x1 + c2 * w1, r5[2] = u2 * m2 + d2 * v1 + p2 * b1, r5[5] = u2 * f1 + d2 * y1 + p2 * _1, r5[8] = u2 * g1 + d2 * x1 + p2 * w1, this;
    }
    multiplyScalar(t85) {
        const e49 = this.elements;
        return e49[0] *= t85, e49[3] *= t85, e49[6] *= t85, e49[1] *= t85, e49[4] *= t85, e49[7] *= t85, e49[2] *= t85, e49[5] *= t85, e49[8] *= t85, this;
    }
    determinant() {
        const t86 = this.elements, e50 = t86[0], n28 = t86[1], i11 = t86[2], r6 = t86[3], s5 = t86[4], a4 = t86[5], o4 = t86[6], l4 = t86[7], h4 = t86[8];
        return e50 * s5 * h4 - e50 * a4 * l4 - n28 * r6 * h4 + n28 * a4 * o4 + i11 * r6 * l4 - i11 * s5 * o4;
    }
    invert() {
        const t87 = this.elements, e51 = t87[0], n29 = t87[1], i12 = t87[2], r7 = t87[3], s6 = t87[4], a5 = t87[5], o5 = t87[6], l5 = t87[7], h5 = t87[8], c3 = h5 * s6 - a5 * l5, u3 = a5 * o5 - h5 * r7, d3 = l5 * r7 - s6 * o5, p3 = e51 * c3 + n29 * u3 + i12 * d3;
        if (0 === p3) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const m3 = 1 / p3;
        return t87[0] = c3 * m3, t87[1] = (i12 * l5 - h5 * n29) * m3, t87[2] = (a5 * n29 - i12 * s6) * m3, t87[3] = u3 * m3, t87[4] = (h5 * e51 - i12 * o5) * m3, t87[5] = (i12 * r7 - a5 * e51) * m3, t87[6] = d3 * m3, t87[7] = (n29 * o5 - l5 * e51) * m3, t87[8] = (s6 * e51 - n29 * r7) * m3, this;
    }
    transpose() {
        let t88;
        const e52 = this.elements;
        return t88 = e52[1], e52[1] = e52[3], e52[3] = t88, t88 = e52[2], e52[2] = e52[6], e52[6] = t88, t88 = e52[5], e52[5] = e52[7], e52[7] = t88, this;
    }
    getNormalMatrix(t89) {
        return this.setFromMatrix4(t89).invert().transpose();
    }
    transposeIntoArray(t90) {
        const e53 = this.elements;
        return t90[0] = e53[0], t90[1] = e53[3], t90[2] = e53[6], t90[3] = e53[1], t90[4] = e53[4], t90[5] = e53[7], t90[6] = e53[2], t90[7] = e53[5], t90[8] = e53[8], this;
    }
    setUvTransform(t91, e54, n30, i13, r8, s7, a6) {
        const o6 = Math.cos(r8), l6 = Math.sin(r8);
        return this.set(n30 * o6, n30 * l6, -n30 * (o6 * s7 + l6 * a6) + s7 + t91, -i13 * l6, i13 * o6, -i13 * (-l6 * s7 + o6 * a6) + a6 + e54, 0, 0, 1), this;
    }
    scale(t92, e55) {
        const n31 = this.elements;
        return n31[0] *= t92, n31[3] *= t92, n31[6] *= t92, n31[1] *= e55, n31[4] *= e55, n31[7] *= e55, this;
    }
    rotate(t93) {
        const e56 = Math.cos(t93), n32 = Math.sin(t93), i14 = this.elements, r9 = i14[0], s8 = i14[3], a7 = i14[6], o7 = i14[1], l7 = i14[4], h6 = i14[7];
        return i14[0] = e56 * r9 + n32 * o7, i14[3] = e56 * s8 + n32 * l7, i14[6] = e56 * a7 + n32 * h6, i14[1] = -n32 * r9 + e56 * o7, i14[4] = -n32 * s8 + e56 * l7, i14[7] = -n32 * a7 + e56 * h6, this;
    }
    translate(t94, e57) {
        const n33 = this.elements;
        return n33[0] += t94 * n33[2], n33[3] += t94 * n33[5], n33[6] += t94 * n33[8], n33[1] += e57 * n33[2], n33[4] += e57 * n33[5], n33[7] += e57 * n33[8], this;
    }
    equals(t96) {
        const e58 = this.elements, n34 = t96.elements;
        for(let t95 = 0; t95 < 9; t95++)if (e58[t95] !== n34[t95]) return !1;
        return !0;
    }
    fromArray(t97, e59 = 0) {
        for(let n35 = 0; n35 < 9; n35++)this.elements[n35] = t97[n35 + e59];
        return this;
    }
    toArray(t98 = [], e60 = 0) {
        const n36 = this.elements;
        return t98[e60] = n36[0], t98[e60 + 1] = n36[1], t98[e60 + 2] = n36[2], t98[e60 + 3] = n36[3], t98[e60 + 4] = n36[4], t98[e60 + 5] = n36[5], t98[e60 + 6] = n36[6], t98[e60 + 7] = n36[7], t98[e60 + 8] = n36[8], t98;
    }
    clone() {
        return (new this.constructor).fromArray(this.elements);
    }
}
function y(t99) {
    for(let e61 = t99.length - 1; e61 >= 0; --e61)if (t99[e61] > 65535) return !0;
    return !1;
}
function x(t100) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t100);
}
function b(t101) {
    return t101 < .04045 ? .0773993808 * t101 : Math.pow(.9478672986 * t101 + .0521327014, 2.4);
}
function _(t102) {
    return t102 < .0031308 ? 12.92 * t102 : 1.055 * Math.pow(t102, .41666) - .055;
}
v.prototype.isMatrix3 = !0;
const w = {
    srgb: {
        "srgb-linear": b
    },
    "srgb-linear": {
        srgb: _
    }
}, M = {
    legacyMode: !0,
    get workingColorSpace () {
        return "srgb-linear";
    },
    set workingColorSpace (t){
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function(t, e62, n37) {
        if (this.legacyMode || e62 === n37 || !e62 || !n37) return t;
        if (w[e62] && void 0 !== w[e62][n37]) {
            const i15 = w[e62][n37];
            return t.r = i15(t.r), t.g = i15(t.g), t.b = i15(t.b), t;
        }
        throw new Error("Unsupported color space conversion.");
    },
    fromWorkingColorSpace: function(t, e63) {
        return this.convert(t, this.workingColorSpace, e63);
    },
    toWorkingColorSpace: function(t, e64) {
        return this.convert(t, e64, this.workingColorSpace);
    }
}, S = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}, T = {
    r: 0,
    g: 0,
    b: 0
}, E = {
    h: 0,
    s: 0,
    l: 0
}, A = {
    h: 0,
    s: 0,
    l: 0
};
function R(t, e65, n38) {
    return n38 < 0 && (n38 += 1), n38 > 1 && (n38 -= 1), n38 < 1 / 6 ? t + 6 * (e65 - t) * n38 : n38 < .5 ? e65 : n38 < 2 / 3 ? t + 6 * (e65 - t) * (2 / 3 - n38) : t;
}
function C(t, e66) {
    return e66.r = t.r, e66.g = t.g, e66.b = t.b, e66;
}
class L {
    constructor(t, e67, n39){
        return void 0 === e67 && void 0 === n39 ? this.set(t) : this.setRGB(t, e67, n39);
    }
    set(t) {
        return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this;
    }
    setScalar(t) {
        return this.r = t, this.g = t, this.b = t, this;
    }
    setHex(t, e68 = "srgb") {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, M.toWorkingColorSpace(this, e68), this;
    }
    setRGB(t, e69, n40, i16 = "srgb-linear") {
        return this.r = t, this.g = e69, this.b = n40, M.toWorkingColorSpace(this, i16), this;
    }
    setHSL(t, e70, n41, i18 = "srgb-linear") {
        if (t = c(t, 1), e70 = h(e70, 0, 1), n41 = h(n41, 0, 1), 0 === e70) this.r = this.g = this.b = n41;
        else {
            const i17 = n41 <= .5 ? n41 * (1 + e70) : n41 + e70 - n41 * e70, r10 = 2 * n41 - i17;
            this.r = R(r10, i17, t + 1 / 3), this.g = R(r10, i17, t), this.b = R(r10, i17, t - 1 / 3);
        }
        return M.toWorkingColorSpace(this, i18), this;
    }
    setStyle(t, e71 = "srgb") {
        function n42(e72) {
            void 0 !== e72 && parseFloat(e72) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
        }
        let i19;
        if (i19 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
            let t;
            const r11 = i19[1], s9 = i19[2];
            switch(r11){
                case "rgb":
                case "rgba":
                    if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s9)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, M.toWorkingColorSpace(this, e71), n42(t[4]), this;
                    if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s9)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, M.toWorkingColorSpace(this, e71), n42(t[4]), this;
                    break;
                case "hsl":
                case "hsla":
                    if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s9)) {
                        const i20 = parseFloat(t[1]) / 360, r12 = parseInt(t[2], 10) / 100, s10 = parseInt(t[3], 10) / 100;
                        return n42(t[4]), this.setHSL(i20, r12, s10, e71);
                    }
            }
        } else if (i19 = /^\#([A-Fa-f\d]+)$/.exec(t)) {
            const t = i19[1], n43 = t.length;
            if (3 === n43) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, M.toWorkingColorSpace(this, e71), this;
            if (6 === n43) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, M.toWorkingColorSpace(this, e71), this;
        }
        return t && t.length > 0 ? this.setColorName(t, e71) : this;
    }
    setColorName(t, e73 = "srgb") {
        const n44 = S[t.toLowerCase()];
        return void 0 !== n44 ? this.setHex(n44, e73) : console.warn("THREE.Color: Unknown color " + t), this;
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b);
    }
    copy(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this;
    }
    copySRGBToLinear(t) {
        return this.r = b(t.r), this.g = b(t.g), this.b = b(t.b), this;
    }
    copyLinearToSRGB(t) {
        return this.r = _(t.r), this.g = _(t.g), this.b = _(t.b), this;
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
    }
    getHex(t = "srgb") {
        return M.fromWorkingColorSpace(C(this, T), t), h(255 * T.r, 0, 255) << 16 ^ h(255 * T.g, 0, 255) << 8 ^ h(255 * T.b, 0, 255) << 0;
    }
    getHexString(t = "srgb") {
        return ("000000" + this.getHex(t).toString(16)).slice(-6);
    }
    getHSL(t, e74 = "srgb-linear") {
        M.fromWorkingColorSpace(C(this, T), e74);
        const n45 = T.r, i21 = T.g, r13 = T.b, s11 = Math.max(n45, i21, r13), a8 = Math.min(n45, i21, r13);
        let o8, l8;
        const h7 = (a8 + s11) / 2;
        if (a8 === s11) o8 = 0, l8 = 0;
        else {
            const t = s11 - a8;
            switch(l8 = h7 <= .5 ? t / (s11 + a8) : t / (2 - s11 - a8), s11){
                case n45:
                    o8 = (i21 - r13) / t + (i21 < r13 ? 6 : 0);
                    break;
                case i21:
                    o8 = (r13 - n45) / t + 2;
                    break;
                case r13:
                    o8 = (n45 - i21) / t + 4;
            }
            o8 /= 6;
        }
        return t.h = o8, t.s = l8, t.l = h7, t;
    }
    getRGB(t, e75 = "srgb-linear") {
        return M.fromWorkingColorSpace(C(this, T), e75), t.r = T.r, t.g = T.g, t.b = T.b, t;
    }
    getStyle(t = "srgb") {
        return M.fromWorkingColorSpace(C(this, T), t), "srgb" !== t ? `color(${t} ${T.r} ${T.g} ${T.b})` : `rgb(${255 * T.r | 0},${255 * T.g | 0},${255 * T.b | 0})`;
    }
    offsetHSL(t, e76, n46) {
        return this.getHSL(E), E.h += t, E.s += e76, E.l += n46, this.setHSL(E.h, E.s, E.l), this;
    }
    add(t) {
        return this.r += t.r, this.g += t.g, this.b += t.b, this;
    }
    addColors(t, e77) {
        return this.r = t.r + e77.r, this.g = t.g + e77.g, this.b = t.b + e77.b, this;
    }
    addScalar(t) {
        return this.r += t, this.g += t, this.b += t, this;
    }
    sub(t) {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
    }
    multiply(t) {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
    }
    multiplyScalar(t) {
        return this.r *= t, this.g *= t, this.b *= t, this;
    }
    lerp(t, e78) {
        return this.r += (t.r - this.r) * e78, this.g += (t.g - this.g) * e78, this.b += (t.b - this.b) * e78, this;
    }
    lerpColors(t, e79, n47) {
        return this.r = t.r + (e79.r - t.r) * n47, this.g = t.g + (e79.g - t.g) * n47, this.b = t.b + (e79.b - t.b) * n47, this;
    }
    lerpHSL(t, e80) {
        this.getHSL(E), t.getHSL(A);
        const n48 = u(E.h, A.h, e80), i22 = u(E.s, A.s, e80), r14 = u(E.l, A.l, e80);
        return this.setHSL(n48, i22, r14), this;
    }
    equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
    }
    fromArray(t, e81 = 0) {
        return this.r = t[e81], this.g = t[e81 + 1], this.b = t[e81 + 2], this;
    }
    toArray(t = [], e82 = 0) {
        return t[e82] = this.r, t[e82 + 1] = this.g, t[e82 + 2] = this.b, t;
    }
    fromBufferAttribute(t, e83) {
        return this.r = t.getX(e83), this.g = t.getY(e83), this.b = t.getZ(e83), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
    }
    toJSON() {
        return this.getHex();
    }
}
let P;
L.NAMES = S, L.prototype.isColor = !0, L.prototype.r = 1, L.prototype.g = 1, L.prototype.b = 1;
class D {
    static getDataURL(t) {
        if (/^data:/i.test(t.src)) return t.src;
        if ("undefined" == typeof HTMLCanvasElement) return t.src;
        let e84;
        if (t instanceof HTMLCanvasElement) e84 = t;
        else {
            void 0 === P && (P = x("canvas")), P.width = t.width, P.height = t.height;
            const n49 = P.getContext("2d");
            t instanceof ImageData ? n49.putImageData(t, 0, 0) : n49.drawImage(t, 0, 0, t.width, t.height), e84 = P;
        }
        return e84.width > 2048 || e84.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e84.toDataURL("image/jpeg", .6)) : e84.toDataURL("image/png");
    }
    static sRGBToLinear(t) {
        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
            const e85 = x("canvas");
            e85.width = t.width, e85.height = t.height;
            const n50 = e85.getContext("2d");
            n50.drawImage(t, 0, 0, t.width, t.height);
            const i23 = n50.getImageData(0, 0, t.width, t.height), r15 = i23.data;
            for(let t104 = 0; t104 < r15.length; t104++)r15[t104] = 255 * b(r15[t104] / 255);
            return n50.putImageData(i23, 0, 0), e85;
        }
        if (t.data) {
            const e86 = t.data.slice(0);
            for(let t105 = 0; t105 < e86.length; t105++)e86 instanceof Uint8Array || e86 instanceof Uint8ClampedArray ? e86[t105] = Math.floor(255 * b(e86[t105] / 255)) : e86[t105] = b(e86[t105]);
            return {
                data: e86,
                width: t.width,
                height: t.height
            };
        }
        return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
    }
}
class I {
    constructor(t = null){
        this.uuid = l(), this.data = t, this.version = 0;
    }
    set needsUpdate(t) {
        !0 === t && this.version++;
    }
    toJSON(t) {
        const e87 = void 0 === t || "string" == typeof t;
        if (!e87 && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
        const n52 = {
            uuid: this.uuid,
            url: ""
        }, i24 = this.data;
        if (null !== i24) {
            let t;
            if (Array.isArray(i24)) {
                t = [];
                for(let e88 = 0, n51 = i24.length; e88 < n51; e88++)i24[e88].isDataTexture ? t.push(O(i24[e88].image)) : t.push(O(i24[e88]));
            } else t = O(i24);
            n52.url = t;
        }
        return e87 || (t.images[this.uuid] = n52), n52;
    }
}
function O(t) {
    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? D.getDataURL(t) : t.data ? {
        data: Array.prototype.slice.call(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
I.prototype.isSource = !0;
let N = 0;
class F extends i {
    constructor(t = F.DEFAULT_IMAGE, e89 = F.DEFAULT_MAPPING, n53 = 1001, i25 = 1001, r16 = 1006, s12 = 1008, a9 = 1023, o9 = 1009, h8 = 1, c4 = 3e3){
        super(), Object.defineProperty(this, "id", {
            value: N++
        }), this.uuid = l(), this.name = "", this.source = new I(t), this.mipmaps = [], this.mapping = e89, this.wrapS = n53, this.wrapT = i25, this.magFilter = r16, this.minFilter = s12, this.anisotropy = h8, this.format = a9, this.internalFormat = null, this.type = o9, this.offset = new g(0, 0), this.repeat = new g(1, 1), this.center = new g(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new v, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c4, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
    }
    get image() {
        return this.source.data;
    }
    set image(t) {
        this.source.data = t;
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    copy(t) {
        return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this;
    }
    toJSON(t) {
        const e90 = void 0 === t || "string" == typeof t;
        if (!e90 && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
        const n54 = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return "{}" !== JSON.stringify(this.userData) && (n54.userData = this.userData), e90 || (t.textures[this.uuid] = n54), n54;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
    transformUv(t) {
        if (300 !== this.mapping) return t;
        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch(this.wrapS){
            case 1e3:
                t.x = t.x - Math.floor(t.x);
                break;
            case 1001:
                t.x = t.x < 0 ? 0 : 1;
                break;
            case 1002:
                1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
        }
        if (t.y < 0 || t.y > 1) switch(this.wrapT){
            case 1e3:
                t.y = t.y - Math.floor(t.y);
                break;
            case 1001:
                t.y = t.y < 0 ? 0 : 1;
                break;
            case 1002:
                1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
        }
        return this.flipY && (t.y = 1 - t.y), t;
    }
    set needsUpdate(t) {
        !0 === t && (this.version++, this.source.needsUpdate = !0);
    }
}
F.DEFAULT_IMAGE = null, F.DEFAULT_MAPPING = 300, F.prototype.isTexture = !0;
class U {
    constructor(t = 0, e91 = 0, n55 = 0, i26 = 1){
        this.x = t, this.y = e91, this.z = n55, this.w = i26;
    }
    get width() {
        return this.z;
    }
    set width(t) {
        this.z = t;
    }
    get height() {
        return this.w;
    }
    set height(t) {
        this.w = t;
    }
    set(t, e92, n56, i27) {
        return this.x = t, this.y = e92, this.z = n56, this.w = i27, this;
    }
    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this.w = t, this;
    }
    setX(t) {
        return this.x = t, this;
    }
    setY(t) {
        return this.y = t, this;
    }
    setZ(t) {
        return this.z = t, this;
    }
    setW(t) {
        return this.w = t, this;
    }
    setComponent(t, e93) {
        switch(t){
            case 0:
                this.x = e93;
                break;
            case 1:
                this.y = e93;
                break;
            case 2:
                this.z = e93;
                break;
            case 3:
                this.w = e93;
                break;
            default:
                throw new Error("index is out of range: " + t);
        }
        return this;
    }
    getComponent(t) {
        switch(t){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this;
    }
    add(t, e94) {
        return void 0 !== e94 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e94)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
    }
    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this.w += t, this;
    }
    addVectors(t, e95) {
        return this.x = t.x + e95.x, this.y = t.y + e95.y, this.z = t.z + e95.z, this.w = t.w + e95.w, this;
    }
    addScaledVector(t, e96) {
        return this.x += t.x * e96, this.y += t.y * e96, this.z += t.z * e96, this.w += t.w * e96, this;
    }
    sub(t, e97) {
        return void 0 !== e97 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e97)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
    }
    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    }
    subVectors(t, e98) {
        return this.x = t.x - e98.x, this.y = t.y - e98.y, this.z = t.z - e98.z, this.w = t.w - e98.w, this;
    }
    multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
    }
    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    }
    applyMatrix4(t) {
        const e99 = this.x, n57 = this.y, i28 = this.z, r17 = this.w, s13 = t.elements;
        return this.x = s13[0] * e99 + s13[4] * n57 + s13[8] * i28 + s13[12] * r17, this.y = s13[1] * e99 + s13[5] * n57 + s13[9] * i28 + s13[13] * r17, this.z = s13[2] * e99 + s13[6] * n57 + s13[10] * i28 + s13[14] * r17, this.w = s13[3] * e99 + s13[7] * n57 + s13[11] * i28 + s13[15] * r17, this;
    }
    divideScalar(t) {
        return this.multiplyScalar(1 / t);
    }
    setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e100 = Math.sqrt(1 - t.w * t.w);
        return e100 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e100, this.y = t.y / e100, this.z = t.z / e100), this;
    }
    setAxisAngleFromRotationMatrix(t) {
        let e101, n58, i29, r18;
        const s14 = .01, a10 = .1, o10 = t.elements, l9 = o10[0], h9 = o10[4], c5 = o10[8], u4 = o10[1], d4 = o10[5], p4 = o10[9], m4 = o10[2], f2 = o10[6], g2 = o10[10];
        if (Math.abs(h9 - u4) < s14 && Math.abs(c5 - m4) < s14 && Math.abs(p4 - f2) < s14) {
            if (Math.abs(h9 + u4) < a10 && Math.abs(c5 + m4) < a10 && Math.abs(p4 + f2) < a10 && Math.abs(l9 + d4 + g2 - 3) < a10) return this.set(1, 0, 0, 0), this;
            e101 = Math.PI;
            const t = (l9 + 1) / 2, o11 = (d4 + 1) / 2, v2 = (g2 + 1) / 2, y2 = (h9 + u4) / 4, x2 = (c5 + m4) / 4, b2 = (p4 + f2) / 4;
            return t > o11 && t > v2 ? t < s14 ? (n58 = 0, i29 = .707106781, r18 = .707106781) : (n58 = Math.sqrt(t), i29 = y2 / n58, r18 = x2 / n58) : o11 > v2 ? o11 < s14 ? (n58 = .707106781, i29 = 0, r18 = .707106781) : (i29 = Math.sqrt(o11), n58 = y2 / i29, r18 = b2 / i29) : v2 < s14 ? (n58 = .707106781, i29 = .707106781, r18 = 0) : (r18 = Math.sqrt(v2), n58 = x2 / r18, i29 = b2 / r18), this.set(n58, i29, r18, e101), this;
        }
        let v3 = Math.sqrt((f2 - p4) * (f2 - p4) + (c5 - m4) * (c5 - m4) + (u4 - h9) * (u4 - h9));
        return Math.abs(v3) < .001 && (v3 = 1), this.x = (f2 - p4) / v3, this.y = (c5 - m4) / v3, this.z = (u4 - h9) / v3, this.w = Math.acos((l9 + d4 + g2 - 1) / 2), this;
    }
    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    }
    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    }
    clamp(t, e102) {
        return this.x = Math.max(t.x, Math.min(e102.x, this.x)), this.y = Math.max(t.y, Math.min(e102.y, this.y)), this.z = Math.max(t.z, Math.min(e102.z, this.z)), this.w = Math.max(t.w, Math.min(e102.w, this.w)), this;
    }
    clampScalar(t, e103) {
        return this.x = Math.max(t, Math.min(e103, this.x)), this.y = Math.max(t, Math.min(e103, this.y)), this.z = Math.max(t, Math.min(e103, this.z)), this.w = Math.max(t, Math.min(e103, this.w)), this;
    }
    clampLength(t, e104) {
        const n59 = this.length();
        return this.divideScalar(n59 || 1).multiplyScalar(Math.max(t, Math.min(e104, n59)));
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
        return this.normalize().multiplyScalar(t);
    }
    lerp(t, e105) {
        return this.x += (t.x - this.x) * e105, this.y += (t.y - this.y) * e105, this.z += (t.z - this.z) * e105, this.w += (t.w - this.w) * e105, this;
    }
    lerpVectors(t, e106, n60) {
        return this.x = t.x + (e106.x - t.x) * n60, this.y = t.y + (e106.y - t.y) * n60, this.z = t.z + (e106.z - t.z) * n60, this.w = t.w + (e106.w - t.w) * n60, this;
    }
    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    }
    fromArray(t, e107 = 0) {
        return this.x = t[e107], this.y = t[e107 + 1], this.z = t[e107 + 2], this.w = t[e107 + 3], this;
    }
    toArray(t = [], e108 = 0) {
        return t[e108] = this.x, t[e108 + 1] = this.y, t[e108 + 2] = this.z, t[e108 + 3] = this.w, t;
    }
    fromBufferAttribute(t, e109, n61) {
        return void 0 !== n61 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e109), this.y = t.getY(e109), this.z = t.getZ(e109), this.w = t.getW(e109), this;
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
    }
}
U.prototype.isVector4 = !0;
class k extends i {
    constructor(t, e110, n62 = {}){
        super(), this.width = t, this.height = e110, this.depth = 1, this.scissor = new U(0, 0, t, e110), this.scissorTest = !1, this.viewport = new U(0, 0, t, e110);
        const i30 = {
            width: t,
            height: e110,
            depth: 1
        };
        this.texture = new F(i30, n62.mapping, n62.wrapS, n62.wrapT, n62.magFilter, n62.minFilter, n62.format, n62.type, n62.anisotropy, n62.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = void 0 !== n62.generateMipmaps && n62.generateMipmaps, this.texture.internalFormat = void 0 !== n62.internalFormat ? n62.internalFormat : null, this.texture.minFilter = void 0 !== n62.minFilter ? n62.minFilter : 1006, this.depthBuffer = void 0 === n62.depthBuffer || n62.depthBuffer, this.stencilBuffer = void 0 !== n62.stencilBuffer && n62.stencilBuffer, this.depthTexture = void 0 !== n62.depthTexture ? n62.depthTexture : null, this.samples = void 0 !== n62.samples ? n62.samples : 0;
    }
    setSize(t, e111, n63 = 1) {
        this.width === t && this.height === e111 && this.depth === n63 || (this.width = t, this.height = e111, this.depth = n63, this.texture.image.width = t, this.texture.image.height = e111, this.texture.image.depth = n63, this.dispose()), this.viewport.set(0, 0, t, e111), this.scissor.set(0, 0, t, e111);
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    copy(t) {
        return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0, this.texture.image = Object.assign({}, t.texture.image), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}
k.prototype.isWebGLRenderTarget = !0;
class B extends F {
    constructor(t = null, e112 = 1, n64 = 1, i31 = 1){
        super(null), this.image = {
            data: t,
            width: e112,
            height: n64,
            depth: i31
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
    }
}
B.prototype.isDataArrayTexture = !0;
(class extends k {
    constructor(t, e113, n65){
        super(t, e113), this.depth = n65, this.texture = new B(null, t, e113, n65), this.texture.isRenderTargetTexture = !0;
    }
}).prototype.isWebGLArrayRenderTarget = !0;
class z extends F {
    constructor(t = null, e114 = 1, n66 = 1, i32 = 1){
        super(null), this.image = {
            data: t,
            width: e114,
            height: n66,
            depth: i32
        }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
    }
}
z.prototype.isData3DTexture = !0;
(class extends k {
    constructor(t, e115, n67){
        super(t, e115), this.depth = n67, this.texture = new z(null, t, e115, n67), this.texture.isRenderTargetTexture = !0;
    }
}).prototype.isWebGL3DRenderTarget = !0;
(class extends k {
    constructor(t, e116, n68, i33 = {}){
        super(t, e116, i33);
        const r19 = this.texture;
        this.texture = [];
        for(let t106 = 0; t106 < n68; t106++)this.texture[t106] = r19.clone(), this.texture[t106].isRenderTargetTexture = !0;
    }
    setSize(t, e117, n69 = 1) {
        if (this.width !== t || this.height !== e117 || this.depth !== n69) {
            this.width = t, this.height = e117, this.depth = n69;
            for(let i34 = 0, r20 = this.texture.length; i34 < r20; i34++)this.texture[i34].image.width = t, this.texture[i34].image.height = e117, this.texture[i34].image.depth = n69;
            this.dispose();
        }
        return this.viewport.set(0, 0, t, e117), this.scissor.set(0, 0, t, e117), this;
    }
    copy(t) {
        this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
        for(let e118 = 0, n70 = t.texture.length; e118 < n70; e118++)this.texture[e118] = t.texture[e118].clone();
        return this;
    }
}).prototype.isWebGLMultipleRenderTargets = !0;
class H {
    constructor(t = 0, e119 = 0, n71 = 0, i35 = 1){
        this._x = t, this._y = e119, this._z = n71, this._w = i35;
    }
    static slerp(t, e120, n72, i36) {
        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n72.slerpQuaternions(t, e120, i36);
    }
    static slerpFlat(t, e121, n73, i37, r21, s15, a11) {
        let o12 = n73[i37 + 0], l10 = n73[i37 + 1], h10 = n73[i37 + 2], c6 = n73[i37 + 3];
        const u5 = r21[s15 + 0], d5 = r21[s15 + 1], p5 = r21[s15 + 2], m5 = r21[s15 + 3];
        if (0 === a11) return t[e121 + 0] = o12, t[e121 + 1] = l10, t[e121 + 2] = h10, void (t[e121 + 3] = c6);
        if (1 === a11) return t[e121 + 0] = u5, t[e121 + 1] = d5, t[e121 + 2] = p5, void (t[e121 + 3] = m5);
        if (c6 !== m5 || o12 !== u5 || l10 !== d5 || h10 !== p5) {
            let t = 1 - a11;
            const e122 = o12 * u5 + l10 * d5 + h10 * p5 + c6 * m5, n74 = e122 >= 0 ? 1 : -1, i38 = 1 - e122 * e122;
            if (i38 > Number.EPSILON) {
                const r22 = Math.sqrt(i38), s16 = Math.atan2(r22, e122 * n74);
                t = Math.sin(t * s16) / r22, a11 = Math.sin(a11 * s16) / r22;
            }
            const r23 = a11 * n74;
            if (o12 = o12 * t + u5 * r23, l10 = l10 * t + d5 * r23, h10 = h10 * t + p5 * r23, c6 = c6 * t + m5 * r23, t === 1 - a11) {
                const t = 1 / Math.sqrt(o12 * o12 + l10 * l10 + h10 * h10 + c6 * c6);
                o12 *= t, l10 *= t, h10 *= t, c6 *= t;
            }
        }
        t[e121] = o12, t[e121 + 1] = l10, t[e121 + 2] = h10, t[e121 + 3] = c6;
    }
    static multiplyQuaternionsFlat(t, e123, n75, i39, r24, s17) {
        const a12 = n75[i39], o13 = n75[i39 + 1], l11 = n75[i39 + 2], h11 = n75[i39 + 3], c7 = r24[s17], u6 = r24[s17 + 1], d6 = r24[s17 + 2], p6 = r24[s17 + 3];
        return t[e123] = a12 * p6 + h11 * c7 + o13 * d6 - l11 * u6, t[e123 + 1] = o13 * p6 + h11 * u6 + l11 * c7 - a12 * d6, t[e123 + 2] = l11 * p6 + h11 * d6 + a12 * u6 - o13 * c7, t[e123 + 3] = h11 * p6 - a12 * c7 - o13 * u6 - l11 * d6, t;
    }
    get x() {
        return this._x;
    }
    set x(t) {
        this._x = t, this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(t) {
        this._y = t, this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(t) {
        this._z = t, this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(t) {
        this._w = t, this._onChangeCallback();
    }
    set(t, e124, n76, i40) {
        return this._x = t, this._y = e124, this._z = n76, this._w = i40, this._onChangeCallback(), this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t) {
        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
    }
    setFromEuler(t, e125) {
        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        const n77 = t._x, i41 = t._y, r25 = t._z, s18 = t._order, a13 = Math.cos, o14 = Math.sin, l12 = a13(n77 / 2), h12 = a13(i41 / 2), c8 = a13(r25 / 2), u7 = o14(n77 / 2), d7 = o14(i41 / 2), p7 = o14(r25 / 2);
        switch(s18){
            case "XYZ":
                this._x = u7 * h12 * c8 + l12 * d7 * p7, this._y = l12 * d7 * c8 - u7 * h12 * p7, this._z = l12 * h12 * p7 + u7 * d7 * c8, this._w = l12 * h12 * c8 - u7 * d7 * p7;
                break;
            case "YXZ":
                this._x = u7 * h12 * c8 + l12 * d7 * p7, this._y = l12 * d7 * c8 - u7 * h12 * p7, this._z = l12 * h12 * p7 - u7 * d7 * c8, this._w = l12 * h12 * c8 + u7 * d7 * p7;
                break;
            case "ZXY":
                this._x = u7 * h12 * c8 - l12 * d7 * p7, this._y = l12 * d7 * c8 + u7 * h12 * p7, this._z = l12 * h12 * p7 + u7 * d7 * c8, this._w = l12 * h12 * c8 - u7 * d7 * p7;
                break;
            case "ZYX":
                this._x = u7 * h12 * c8 - l12 * d7 * p7, this._y = l12 * d7 * c8 + u7 * h12 * p7, this._z = l12 * h12 * p7 - u7 * d7 * c8, this._w = l12 * h12 * c8 + u7 * d7 * p7;
                break;
            case "YZX":
                this._x = u7 * h12 * c8 + l12 * d7 * p7, this._y = l12 * d7 * c8 + u7 * h12 * p7, this._z = l12 * h12 * p7 - u7 * d7 * c8, this._w = l12 * h12 * c8 - u7 * d7 * p7;
                break;
            case "XZY":
                this._x = u7 * h12 * c8 - l12 * d7 * p7, this._y = l12 * d7 * c8 - u7 * h12 * p7, this._z = l12 * h12 * p7 + u7 * d7 * c8, this._w = l12 * h12 * c8 + u7 * d7 * p7;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s18);
        }
        return !1 !== e125 && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t, e126) {
        const n78 = e126 / 2, i42 = Math.sin(n78);
        return this._x = t.x * i42, this._y = t.y * i42, this._z = t.z * i42, this._w = Math.cos(n78), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t) {
        const e127 = t.elements, n79 = e127[0], i43 = e127[4], r26 = e127[8], s19 = e127[1], a14 = e127[5], o15 = e127[9], l13 = e127[2], h13 = e127[6], c9 = e127[10], u8 = n79 + a14 + c9;
        if (u8 > 0) {
            const t = .5 / Math.sqrt(u8 + 1);
            this._w = .25 / t, this._x = (h13 - o15) * t, this._y = (r26 - l13) * t, this._z = (s19 - i43) * t;
        } else if (n79 > a14 && n79 > c9) {
            const t = 2 * Math.sqrt(1 + n79 - a14 - c9);
            this._w = (h13 - o15) / t, this._x = .25 * t, this._y = (i43 + s19) / t, this._z = (r26 + l13) / t;
        } else if (a14 > c9) {
            const t = 2 * Math.sqrt(1 + a14 - n79 - c9);
            this._w = (r26 - l13) / t, this._x = (i43 + s19) / t, this._y = .25 * t, this._z = (o15 + h13) / t;
        } else {
            const t = 2 * Math.sqrt(1 + c9 - n79 - a14);
            this._w = (s19 - i43) / t, this._x = (r26 + l13) / t, this._y = (o15 + h13) / t, this._z = .25 * t;
        }
        return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t, e128) {
        let n80 = t.dot(e128) + 1;
        return n80 < Number.EPSILON ? (n80 = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n80) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n80)) : (this._x = t.y * e128.z - t.z * e128.y, this._y = t.z * e128.x - t.x * e128.z, this._z = t.x * e128.y - t.y * e128.x, this._w = n80), this.normalize();
    }
    angleTo(t) {
        return 2 * Math.acos(Math.abs(h(this.dot(t), -1, 1)));
    }
    rotateTowards(t, e129) {
        const n81 = this.angleTo(t);
        if (0 === n81) return this;
        const i44 = Math.min(1, e129 / n81);
        return this.slerp(t, i44), this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    invert() {
        return this.conjugate();
    }
    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
        let t = this.length();
        return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
    }
    multiply(t, e130) {
        return void 0 !== e130 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e130)) : this.multiplyQuaternions(this, t);
    }
    premultiply(t) {
        return this.multiplyQuaternions(t, this);
    }
    multiplyQuaternions(t, e131) {
        const n82 = t._x, i45 = t._y, r27 = t._z, s20 = t._w, a15 = e131._x, o16 = e131._y, l14 = e131._z, h14 = e131._w;
        return this._x = n82 * h14 + s20 * a15 + i45 * l14 - r27 * o16, this._y = i45 * h14 + s20 * o16 + r27 * a15 - n82 * l14, this._z = r27 * h14 + s20 * l14 + n82 * o16 - i45 * a15, this._w = s20 * h14 - n82 * a15 - i45 * o16 - r27 * l14, this._onChangeCallback(), this;
    }
    slerp(t, e132) {
        if (0 === e132) return this;
        if (1 === e132) return this.copy(t);
        const n83 = this._x, i46 = this._y, r28 = this._z, s21 = this._w;
        let a16 = s21 * t._w + n83 * t._x + i46 * t._y + r28 * t._z;
        if (a16 < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a16 = -a16) : this.copy(t), a16 >= 1) return this._w = s21, this._x = n83, this._y = i46, this._z = r28, this;
        const o17 = 1 - a16 * a16;
        if (o17 <= Number.EPSILON) {
            const t = 1 - e132;
            return this._w = t * s21 + e132 * this._w, this._x = t * n83 + e132 * this._x, this._y = t * i46 + e132 * this._y, this._z = t * r28 + e132 * this._z, this.normalize(), this._onChangeCallback(), this;
        }
        const l15 = Math.sqrt(o17), h15 = Math.atan2(l15, a16), c10 = Math.sin((1 - e132) * h15) / l15, u9 = Math.sin(e132 * h15) / l15;
        return this._w = s21 * c10 + this._w * u9, this._x = n83 * c10 + this._x * u9, this._y = i46 * c10 + this._y * u9, this._z = r28 * c10 + this._z * u9, this._onChangeCallback(), this;
    }
    slerpQuaternions(t, e133, n84) {
        return this.copy(t).slerp(e133, n84);
    }
    random() {
        const t = Math.random(), e134 = Math.sqrt(1 - t), n85 = Math.sqrt(t), i47 = 2 * Math.PI * Math.random(), r29 = 2 * Math.PI * Math.random();
        return this.set(e134 * Math.cos(i47), n85 * Math.sin(r29), n85 * Math.cos(r29), e134 * Math.sin(i47));
    }
    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    }
    fromArray(t, e135 = 0) {
        return this._x = t[e135], this._y = t[e135 + 1], this._z = t[e135 + 2], this._w = t[e135 + 3], this._onChangeCallback(), this;
    }
    toArray(t = [], e136 = 0) {
        return t[e136] = this._x, t[e136 + 1] = this._y, t[e136 + 2] = this._z, t[e136 + 3] = this._w, t;
    }
    fromBufferAttribute(t, e137) {
        return this._x = t.getX(e137), this._y = t.getY(e137), this._z = t.getZ(e137), this._w = t.getW(e137), this;
    }
    _onChange(t) {
        return this._onChangeCallback = t, this;
    }
    _onChangeCallback() {}
}
H.prototype.isQuaternion = !0;
class V {
    constructor(t = 0, e138 = 0, n86 = 0){
        this.x = t, this.y = e138, this.z = n86;
    }
    set(t, e139, n87) {
        return void 0 === n87 && (n87 = this.z), this.x = t, this.y = e139, this.z = n87, this;
    }
    setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this;
    }
    setX(t) {
        return this.x = t, this;
    }
    setY(t) {
        return this.y = t, this;
    }
    setZ(t) {
        return this.z = t, this;
    }
    setComponent(t, e140) {
        switch(t){
            case 0:
                this.x = e140;
                break;
            case 1:
                this.y = e140;
                break;
            case 2:
                this.z = e140;
                break;
            default:
                throw new Error("index is out of range: " + t);
        }
        return this;
    }
    getComponent(t) {
        switch(t){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this;
    }
    add(t, e141) {
        return void 0 !== e141 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e141)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
    }
    addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this;
    }
    addVectors(t, e142) {
        return this.x = t.x + e142.x, this.y = t.y + e142.y, this.z = t.z + e142.z, this;
    }
    addScaledVector(t, e143) {
        return this.x += t.x * e143, this.y += t.y * e143, this.z += t.z * e143, this;
    }
    sub(t, e144) {
        return void 0 !== e144 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e144)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
    }
    subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this;
    }
    subVectors(t, e145) {
        return this.x = t.x - e145.x, this.y = t.y - e145.y, this.z = t.z - e145.z, this;
    }
    multiply(t, e146) {
        return void 0 !== e146 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e146)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
    }
    multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this;
    }
    multiplyVectors(t, e147) {
        return this.x = t.x * e147.x, this.y = t.y * e147.y, this.z = t.z * e147.z, this;
    }
    applyEuler(t) {
        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(W.setFromEuler(t));
    }
    applyAxisAngle(t, e148) {
        return this.applyQuaternion(W.setFromAxisAngle(t, e148));
    }
    applyMatrix3(t) {
        const e149 = this.x, n88 = this.y, i48 = this.z, r30 = t.elements;
        return this.x = r30[0] * e149 + r30[3] * n88 + r30[6] * i48, this.y = r30[1] * e149 + r30[4] * n88 + r30[7] * i48, this.z = r30[2] * e149 + r30[5] * n88 + r30[8] * i48, this;
    }
    applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize();
    }
    applyMatrix4(t) {
        const e150 = this.x, n89 = this.y, i49 = this.z, r31 = t.elements, s22 = 1 / (r31[3] * e150 + r31[7] * n89 + r31[11] * i49 + r31[15]);
        return this.x = (r31[0] * e150 + r31[4] * n89 + r31[8] * i49 + r31[12]) * s22, this.y = (r31[1] * e150 + r31[5] * n89 + r31[9] * i49 + r31[13]) * s22, this.z = (r31[2] * e150 + r31[6] * n89 + r31[10] * i49 + r31[14]) * s22, this;
    }
    applyQuaternion(t) {
        const e151 = this.x, n90 = this.y, i50 = this.z, r32 = t.x, s23 = t.y, a17 = t.z, o18 = t.w, l16 = o18 * e151 + s23 * i50 - a17 * n90, h16 = o18 * n90 + a17 * e151 - r32 * i50, c11 = o18 * i50 + r32 * n90 - s23 * e151, u10 = -r32 * e151 - s23 * n90 - a17 * i50;
        return this.x = l16 * o18 + u10 * -r32 + h16 * -a17 - c11 * -s23, this.y = h16 * o18 + u10 * -s23 + c11 * -r32 - l16 * -a17, this.z = c11 * o18 + u10 * -a17 + l16 * -s23 - h16 * -r32, this;
    }
    project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
    }
    unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
    }
    transformDirection(t) {
        const e152 = this.x, n91 = this.y, i51 = this.z, r33 = t.elements;
        return this.x = r33[0] * e152 + r33[4] * n91 + r33[8] * i51, this.y = r33[1] * e152 + r33[5] * n91 + r33[9] * i51, this.z = r33[2] * e152 + r33[6] * n91 + r33[10] * i51, this.normalize();
    }
    divide(t) {
        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    }
    divideScalar(t) {
        return this.multiplyScalar(1 / t);
    }
    min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    }
    max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    }
    clamp(t, e153) {
        return this.x = Math.max(t.x, Math.min(e153.x, this.x)), this.y = Math.max(t.y, Math.min(e153.y, this.y)), this.z = Math.max(t.z, Math.min(e153.z, this.z)), this;
    }
    clampScalar(t, e154) {
        return this.x = Math.max(t, Math.min(e154, this.x)), this.y = Math.max(t, Math.min(e154, this.y)), this.z = Math.max(t, Math.min(e154, this.z)), this;
    }
    clampLength(t, e155) {
        const n92 = this.length();
        return this.divideScalar(n92 || 1).multiplyScalar(Math.max(t, Math.min(e155, n92)));
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
        return this.normalize().multiplyScalar(t);
    }
    lerp(t, e156) {
        return this.x += (t.x - this.x) * e156, this.y += (t.y - this.y) * e156, this.z += (t.z - this.z) * e156, this;
    }
    lerpVectors(t, e157, n93) {
        return this.x = t.x + (e157.x - t.x) * n93, this.y = t.y + (e157.y - t.y) * n93, this.z = t.z + (e157.z - t.z) * n93, this;
    }
    cross(t, e158) {
        return void 0 !== e158 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e158)) : this.crossVectors(this, t);
    }
    crossVectors(t, e159) {
        const n94 = t.x, i52 = t.y, r34 = t.z, s24 = e159.x, a18 = e159.y, o19 = e159.z;
        return this.x = i52 * o19 - r34 * a18, this.y = r34 * s24 - n94 * o19, this.z = n94 * a18 - i52 * s24, this;
    }
    projectOnVector(t) {
        const e160 = t.lengthSq();
        if (0 === e160) return this.set(0, 0, 0);
        const n95 = t.dot(this) / e160;
        return this.copy(t).multiplyScalar(n95);
    }
    projectOnPlane(t) {
        return G.copy(this).projectOnVector(t), this.sub(G);
    }
    reflect(t) {
        return this.sub(G.copy(t).multiplyScalar(2 * this.dot(t)));
    }
    angleTo(t) {
        const e161 = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e161) return Math.PI / 2;
        const n96 = this.dot(t) / e161;
        return Math.acos(h(n96, -1, 1));
    }
    distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
        const e162 = this.x - t.x, n97 = this.y - t.y, i53 = this.z - t.z;
        return e162 * e162 + n97 * n97 + i53 * i53;
    }
    manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    }
    setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
    setFromSphericalCoords(t, e163, n98) {
        const i54 = Math.sin(e163) * t;
        return this.x = i54 * Math.sin(n98), this.y = Math.cos(e163) * t, this.z = i54 * Math.cos(n98), this;
    }
    setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
    setFromCylindricalCoords(t, e164, n99) {
        return this.x = t * Math.sin(e164), this.y = n99, this.z = t * Math.cos(e164), this;
    }
    setFromMatrixPosition(t) {
        const e165 = t.elements;
        return this.x = e165[12], this.y = e165[13], this.z = e165[14], this;
    }
    setFromMatrixScale(t) {
        const e166 = this.setFromMatrixColumn(t, 0).length(), n100 = this.setFromMatrixColumn(t, 1).length(), i55 = this.setFromMatrixColumn(t, 2).length();
        return this.x = e166, this.y = n100, this.z = i55, this;
    }
    setFromMatrixColumn(t, e167) {
        return this.fromArray(t.elements, 4 * e167);
    }
    setFromMatrix3Column(t, e168) {
        return this.fromArray(t.elements, 3 * e168);
    }
    setFromEuler(t) {
        return this.x = t._x, this.y = t._y, this.z = t._z, this;
    }
    equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
    }
    fromArray(t, e169 = 0) {
        return this.x = t[e169], this.y = t[e169 + 1], this.z = t[e169 + 2], this;
    }
    toArray(t = [], e170 = 0) {
        return t[e170] = this.x, t[e170 + 1] = this.y, t[e170 + 2] = this.z, t;
    }
    fromBufferAttribute(t, e171, n101) {
        return void 0 !== n101 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e171), this.y = t.getY(e171), this.z = t.getZ(e171), this;
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
        const t = 2 * (Math.random() - .5), e172 = Math.random() * Math.PI * 2, n102 = Math.sqrt(1 - t ** 2);
        return this.x = n102 * Math.cos(e172), this.y = n102 * Math.sin(e172), this.z = t, this;
    }
    *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
    }
}
V.prototype.isVector3 = !0;
const G = new V, W = new H;
class j {
    constructor(t = new V(1 / 0, 1 / 0, 1 / 0), e173 = new V(-1 / 0, -1 / 0, -1 / 0)){
        this.min = t, this.max = e173;
    }
    set(t, e174) {
        return this.min.copy(t), this.max.copy(e174), this;
    }
    setFromArray(t) {
        let e175 = 1 / 0, n103 = 1 / 0, i56 = 1 / 0, r35 = -1 / 0, s25 = -1 / 0, a19 = -1 / 0;
        for(let o20 = 0, l17 = t.length; o20 < l17; o20 += 3){
            const l18 = t[o20], h17 = t[o20 + 1], c12 = t[o20 + 2];
            l18 < e175 && (e175 = l18), h17 < n103 && (n103 = h17), c12 < i56 && (i56 = c12), l18 > r35 && (r35 = l18), h17 > s25 && (s25 = h17), c12 > a19 && (a19 = c12);
        }
        return this.min.set(e175, n103, i56), this.max.set(r35, s25, a19), this;
    }
    setFromBufferAttribute(t) {
        let e176 = 1 / 0, n104 = 1 / 0, i57 = 1 / 0, r36 = -1 / 0, s26 = -1 / 0, a20 = -1 / 0;
        for(let o21 = 0, l19 = t.count; o21 < l19; o21++){
            const l20 = t.getX(o21), h18 = t.getY(o21), c13 = t.getZ(o21);
            l20 < e176 && (e176 = l20), h18 < n104 && (n104 = h18), c13 < i57 && (i57 = c13), l20 > r36 && (r36 = l20), h18 > s26 && (s26 = h18), c13 > a20 && (a20 = c13);
        }
        return this.min.set(e176, n104, i57), this.max.set(r36, s26, a20), this;
    }
    setFromPoints(t) {
        this.makeEmpty();
        for(let e177 = 0, n105 = t.length; e177 < n105; e177++)this.expandByPoint(t[e177]);
        return this;
    }
    setFromCenterAndSize(t, e178) {
        const n106 = X.copy(e178).multiplyScalar(.5);
        return this.min.copy(t).sub(n106), this.max.copy(t).add(n106), this;
    }
    setFromObject(t, e179 = !1) {
        return this.makeEmpty(), this.expandByObject(t, e179);
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5);
    }
    getSize(t) {
        return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
    expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this;
    }
    expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this;
    }
    expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
    expandByObject(t, e180 = !1) {
        t.updateWorldMatrix(!1, !1);
        const n108 = t.geometry;
        if (void 0 !== n108) {
            if (e180 && null != n108.attributes && void 0 !== n108.attributes.position) {
                const e181 = n108.attributes.position;
                for(let n109 = 0, i58 = e181.count; n109 < i58; n109++)X.fromBufferAttribute(e181, n109).applyMatrix4(t.matrixWorld), this.expandByPoint(X);
            } else null === n108.boundingBox && n108.computeBoundingBox(), $.copy(n108.boundingBox), $.applyMatrix4(t.matrixWorld), this.union($);
        }
        const i59 = t.children;
        for(let t107 = 0, n107 = i59.length; t107 < n107; t107++)this.expandByObject(i59[t107], e180);
        return this;
    }
    containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    }
    containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    }
    getParameter(t, e182) {
        return e182.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    }
    intersectsSphere(t) {
        return this.clampPoint(t.center, X), X.distanceToSquared(t.center) <= t.radius * t.radius;
    }
    intersectsPlane(t) {
        let e183, n110;
        return t.normal.x > 0 ? (e183 = t.normal.x * this.min.x, n110 = t.normal.x * this.max.x) : (e183 = t.normal.x * this.max.x, n110 = t.normal.x * this.min.x), t.normal.y > 0 ? (e183 += t.normal.y * this.min.y, n110 += t.normal.y * this.max.y) : (e183 += t.normal.y * this.max.y, n110 += t.normal.y * this.min.y), t.normal.z > 0 ? (e183 += t.normal.z * this.min.z, n110 += t.normal.z * this.max.z) : (e183 += t.normal.z * this.max.z, n110 += t.normal.z * this.min.z), e183 <= -t.constant && n110 >= -t.constant;
    }
    intersectsTriangle(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(et), nt.subVectors(this.max, et), Y.subVectors(t.a, et), J.subVectors(t.b, et), K.subVectors(t.c, et), Z.subVectors(J, Y), Q.subVectors(K, J), tt.subVectors(Y, K);
        let e184 = [
            0,
            -Z.z,
            Z.y,
            0,
            -Q.z,
            Q.y,
            0,
            -tt.z,
            tt.y,
            Z.z,
            0,
            -Z.x,
            Q.z,
            0,
            -Q.x,
            tt.z,
            0,
            -tt.x,
            -Z.y,
            Z.x,
            0,
            -Q.y,
            Q.x,
            0,
            -tt.y,
            tt.x,
            0
        ];
        return !!st(e184, Y, J, K, nt) && (e184 = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ], !!st(e184, Y, J, K, nt) && (it.crossVectors(Z, Q), e184 = [
            it.x,
            it.y,
            it.z
        ], st(e184, Y, J, K, nt)));
    }
    clampPoint(t, e185) {
        return e185.copy(t).clamp(this.min, this.max);
    }
    distanceToPoint(t) {
        return X.copy(t).clamp(this.min, this.max).sub(t).length();
    }
    getBoundingSphere(t) {
        return this.getCenter(t.center), t.radius = .5 * this.getSize(X).length(), t;
    }
    intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(t) {
        return this.min.min(t.min), this.max.max(t.max), this;
    }
    applyMatrix4(t) {
        return this.isEmpty() || (q[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), q[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), q[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), q[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), q[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), q[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), q[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), q[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(q)), this;
    }
    translate(t) {
        return this.min.add(t), this.max.add(t), this;
    }
    equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
    }
}
j.prototype.isBox3 = !0;
const q = [
    new V,
    new V,
    new V,
    new V,
    new V,
    new V,
    new V,
    new V
], X = new V, $ = new j, Y = new V, J = new V, K = new V, Z = new V, Q = new V, tt = new V, et = new V, nt = new V, it = new V, rt = new V;
function st(t, e186, n111, i60, r37) {
    for(let s27 = 0, a21 = t.length - 3; s27 <= a21; s27 += 3){
        rt.fromArray(t, s27);
        const a22 = r37.x * Math.abs(rt.x) + r37.y * Math.abs(rt.y) + r37.z * Math.abs(rt.z), o22 = e186.dot(rt), l21 = n111.dot(rt), h19 = i60.dot(rt);
        if (Math.max(-Math.max(o22, l21, h19), Math.min(o22, l21, h19)) > a22) return !1;
    }
    return !0;
}
const at = new j, ot = new V, lt = new V, ht = new V;
class ct {
    constructor(t = new V, e187 = -1){
        this.center = t, this.radius = e187;
    }
    set(t, e188) {
        return this.center.copy(t), this.radius = e188, this;
    }
    setFromPoints(t, e190) {
        const n112 = this.center;
        void 0 !== e190 ? n112.copy(e190) : at.setFromPoints(t).getCenter(n112);
        let i61 = 0;
        for(let e189 = 0, r38 = t.length; e189 < r38; e189++)i61 = Math.max(i61, n112.distanceToSquared(t[e189]));
        return this.radius = Math.sqrt(i61), this;
    }
    copy(t) {
        return this.center.copy(t.center), this.radius = t.radius, this;
    }
    isEmpty() {
        return this.radius < 0;
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t) {
        const e191 = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e191 * e191;
    }
    intersectsBox(t) {
        return t.intersectsSphere(this);
    }
    intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t, e192) {
        const n113 = this.center.distanceToSquared(t);
        return e192.copy(t), n113 > this.radius * this.radius && (e192.sub(this.center).normalize(), e192.multiplyScalar(this.radius).add(this.center)), e192;
    }
    getBoundingBox(t) {
        return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
    applyMatrix4(t) {
        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
    }
    translate(t) {
        return this.center.add(t), this;
    }
    expandByPoint(t) {
        ht.subVectors(t, this.center);
        const e193 = ht.lengthSq();
        if (e193 > this.radius * this.radius) {
            const t = Math.sqrt(e193), n114 = .5 * (t - this.radius);
            this.center.add(ht.multiplyScalar(n114 / t)), this.radius += n114;
        }
        return this;
    }
    union(t) {
        return !0 === this.center.equals(t.center) ? lt.set(0, 0, 1).multiplyScalar(t.radius) : lt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(ot.copy(t.center).add(lt)), this.expandByPoint(ot.copy(t.center).sub(lt)), this;
    }
    equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius;
    }
    clone() {
        return (new this.constructor).copy(this);
    }
}
const ut = new V, dt = new V, pt = new V, mt = new V, ft = new V, gt = new V, vt = new V;
class yt {
    constructor(t = new V, e194 = new V(0, 0, -1)){
        this.origin = t, this.direction = e194;
    }
    set(t, e195) {
        return this.origin.copy(t), this.direction.copy(e195), this;
    }
    copy(t) {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
    at(t, e196) {
        return e196.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
    recast(t) {
        return this.origin.copy(this.at(t, ut)), this;
    }
    closestPointToPoint(t, e197) {
        e197.subVectors(t, this.origin);
        const n115 = e197.dot(this.direction);
        return n115 < 0 ? e197.copy(this.origin) : e197.copy(this.direction).multiplyScalar(n115).add(this.origin);
    }
    distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t));
    }
    distanceSqToPoint(t) {
        const e198 = ut.subVectors(t, this.origin).dot(this.direction);
        return e198 < 0 ? this.origin.distanceToSquared(t) : (ut.copy(this.direction).multiplyScalar(e198).add(this.origin), ut.distanceToSquared(t));
    }
    distanceSqToSegment(t, e199, n116, i62) {
        dt.copy(t).add(e199).multiplyScalar(.5), pt.copy(e199).sub(t).normalize(), mt.copy(this.origin).sub(dt);
        const r39 = .5 * t.distanceTo(e199), s28 = -this.direction.dot(pt), a23 = mt.dot(this.direction), o23 = -mt.dot(pt), l22 = mt.lengthSq(), h20 = Math.abs(1 - s28 * s28);
        let c14, u11, d8, p8;
        if (h20 > 0) {
            if (c14 = s28 * o23 - a23, u11 = s28 * a23 - o23, p8 = r39 * h20, c14 >= 0) {
                if (u11 >= -p8) {
                    if (u11 <= p8) {
                        const t = 1 / h20;
                        c14 *= t, u11 *= t, d8 = c14 * (c14 + s28 * u11 + 2 * a23) + u11 * (s28 * c14 + u11 + 2 * o23) + l22;
                    } else u11 = r39, c14 = Math.max(0, -(s28 * u11 + a23)), d8 = -c14 * c14 + u11 * (u11 + 2 * o23) + l22;
                } else u11 = -r39, c14 = Math.max(0, -(s28 * u11 + a23)), d8 = -c14 * c14 + u11 * (u11 + 2 * o23) + l22;
            } else u11 <= -p8 ? (c14 = Math.max(0, -(-s28 * r39 + a23)), u11 = c14 > 0 ? -r39 : Math.min(Math.max(-r39, -o23), r39), d8 = -c14 * c14 + u11 * (u11 + 2 * o23) + l22) : u11 <= p8 ? (c14 = 0, u11 = Math.min(Math.max(-r39, -o23), r39), d8 = u11 * (u11 + 2 * o23) + l22) : (c14 = Math.max(0, -(s28 * r39 + a23)), u11 = c14 > 0 ? r39 : Math.min(Math.max(-r39, -o23), r39), d8 = -c14 * c14 + u11 * (u11 + 2 * o23) + l22);
        } else u11 = s28 > 0 ? -r39 : r39, c14 = Math.max(0, -(s28 * u11 + a23)), d8 = -c14 * c14 + u11 * (u11 + 2 * o23) + l22;
        return n116 && n116.copy(this.direction).multiplyScalar(c14).add(this.origin), i62 && i62.copy(pt).multiplyScalar(u11).add(dt), d8;
    }
    intersectSphere(t, e200) {
        ut.subVectors(t.center, this.origin);
        const n117 = ut.dot(this.direction), i63 = ut.dot(ut) - n117 * n117, r40 = t.radius * t.radius;
        if (i63 > r40) return null;
        const s29 = Math.sqrt(r40 - i63), a24 = n117 - s29, o24 = n117 + s29;
        return a24 < 0 && o24 < 0 ? null : a24 < 0 ? this.at(o24, e200) : this.at(a24, e200);
    }
    intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
    distanceToPlane(t) {
        const e201 = t.normal.dot(this.direction);
        if (0 === e201) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const n118 = -(this.origin.dot(t.normal) + t.constant) / e201;
        return n118 >= 0 ? n118 : null;
    }
    intersectPlane(t, e202) {
        const n119 = this.distanceToPlane(t);
        return null === n119 ? null : this.at(n119, e202);
    }
    intersectsPlane(t) {
        const e203 = t.distanceToPoint(this.origin);
        if (0 === e203) return !0;
        return t.normal.dot(this.direction) * e203 < 0;
    }
    intersectBox(t, e204) {
        let n120, i64, r41, s30, a25, o25;
        const l23 = 1 / this.direction.x, h21 = 1 / this.direction.y, c15 = 1 / this.direction.z, u12 = this.origin;
        return l23 >= 0 ? (n120 = (t.min.x - u12.x) * l23, i64 = (t.max.x - u12.x) * l23) : (n120 = (t.max.x - u12.x) * l23, i64 = (t.min.x - u12.x) * l23), h21 >= 0 ? (r41 = (t.min.y - u12.y) * h21, s30 = (t.max.y - u12.y) * h21) : (r41 = (t.max.y - u12.y) * h21, s30 = (t.min.y - u12.y) * h21), n120 > s30 || r41 > i64 ? null : ((r41 > n120 || n120 != n120) && (n120 = r41), (s30 < i64 || i64 != i64) && (i64 = s30), c15 >= 0 ? (a25 = (t.min.z - u12.z) * c15, o25 = (t.max.z - u12.z) * c15) : (a25 = (t.max.z - u12.z) * c15, o25 = (t.min.z - u12.z) * c15), n120 > o25 || a25 > i64 ? null : ((a25 > n120 || n120 != n120) && (n120 = a25), (o25 < i64 || i64 != i64) && (i64 = o25), i64 < 0 ? null : this.at(n120 >= 0 ? n120 : i64, e204)));
    }
    intersectsBox(t) {
        return null !== this.intersectBox(t, ut);
    }
    intersectTriangle(t, e205, n121, i65, r42) {
        ft.subVectors(e205, t), gt.subVectors(n121, t), vt.crossVectors(ft, gt);
        let s31, a26 = this.direction.dot(vt);
        if (a26 > 0) {
            if (i65) return null;
            s31 = 1;
        } else {
            if (!(a26 < 0)) return null;
            s31 = -1, a26 = -a26;
        }
        mt.subVectors(this.origin, t);
        const o26 = s31 * this.direction.dot(gt.crossVectors(mt, gt));
        if (o26 < 0) return null;
        const l24 = s31 * this.direction.dot(ft.cross(mt));
        if (l24 < 0) return null;
        if (o26 + l24 > a26) return null;
        const h22 = -s31 * mt.dot(vt);
        return h22 < 0 ? null : this.at(h22 / a26, r42);
    }
    applyMatrix4(t) {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    }
    equals(t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
    clone() {
        return (new this.constructor).copy(this);
    }
}
class xt {
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t, e206, n122, i66, r43, s32, a27, o27, l25, h23, c16, u13, d9, p9, m6, f3) {
        const g3 = this.elements;
        return g3[0] = t, g3[4] = e206, g3[8] = n122, g3[12] = i66, g3[1] = r43, g3[5] = s32, g3[9] = a27, g3[13] = o27, g3[2] = l25, g3[6] = h23, g3[10] = c16, g3[14] = u13, g3[3] = d9, g3[7] = p9, g3[11] = m6, g3[15] = f3, this;
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
        return (new xt).fromArray(this.elements);
    }
    copy(t) {
        const e207 = this.elements, n123 = t.elements;
        return e207[0] = n123[0], e207[1] = n123[1], e207[2] = n123[2], e207[3] = n123[3], e207[4] = n123[4], e207[5] = n123[5], e207[6] = n123[6], e207[7] = n123[7], e207[8] = n123[8], e207[9] = n123[9], e207[10] = n123[10], e207[11] = n123[11], e207[12] = n123[12], e207[13] = n123[13], e207[14] = n123[14], e207[15] = n123[15], this;
    }
    copyPosition(t) {
        const e208 = this.elements, n124 = t.elements;
        return e208[12] = n124[12], e208[13] = n124[13], e208[14] = n124[14], this;
    }
    setFromMatrix3(t) {
        const e209 = t.elements;
        return this.set(e209[0], e209[3], e209[6], 0, e209[1], e209[4], e209[7], 0, e209[2], e209[5], e209[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(t, e210, n125) {
        return t.setFromMatrixColumn(this, 0), e210.setFromMatrixColumn(this, 1), n125.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(t, e211, n126) {
        return this.set(t.x, e211.x, n126.x, 0, t.y, e211.y, n126.y, 0, t.z, e211.z, n126.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(t) {
        const e212 = this.elements, n127 = t.elements, i67 = 1 / bt.setFromMatrixColumn(t, 0).length(), r44 = 1 / bt.setFromMatrixColumn(t, 1).length(), s33 = 1 / bt.setFromMatrixColumn(t, 2).length();
        return e212[0] = n127[0] * i67, e212[1] = n127[1] * i67, e212[2] = n127[2] * i67, e212[3] = 0, e212[4] = n127[4] * r44, e212[5] = n127[5] * r44, e212[6] = n127[6] * r44, e212[7] = 0, e212[8] = n127[8] * s33, e212[9] = n127[9] * s33, e212[10] = n127[10] * s33, e212[11] = 0, e212[12] = 0, e212[13] = 0, e212[14] = 0, e212[15] = 1, this;
    }
    makeRotationFromEuler(t) {
        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        const e213 = this.elements, n128 = t.x, i68 = t.y, r45 = t.z, s34 = Math.cos(n128), a28 = Math.sin(n128), o28 = Math.cos(i68), l26 = Math.sin(i68), h24 = Math.cos(r45), c17 = Math.sin(r45);
        if ("XYZ" === t.order) {
            const t = s34 * h24, n129 = s34 * c17, i69 = a28 * h24, r46 = a28 * c17;
            e213[0] = o28 * h24, e213[4] = -o28 * c17, e213[8] = l26, e213[1] = n129 + i69 * l26, e213[5] = t - r46 * l26, e213[9] = -a28 * o28, e213[2] = r46 - t * l26, e213[6] = i69 + n129 * l26, e213[10] = s34 * o28;
        } else if ("YXZ" === t.order) {
            const t = o28 * h24, n130 = o28 * c17, i70 = l26 * h24, r47 = l26 * c17;
            e213[0] = t + r47 * a28, e213[4] = i70 * a28 - n130, e213[8] = s34 * l26, e213[1] = s34 * c17, e213[5] = s34 * h24, e213[9] = -a28, e213[2] = n130 * a28 - i70, e213[6] = r47 + t * a28, e213[10] = s34 * o28;
        } else if ("ZXY" === t.order) {
            const t = o28 * h24, n131 = o28 * c17, i71 = l26 * h24, r48 = l26 * c17;
            e213[0] = t - r48 * a28, e213[4] = -s34 * c17, e213[8] = i71 + n131 * a28, e213[1] = n131 + i71 * a28, e213[5] = s34 * h24, e213[9] = r48 - t * a28, e213[2] = -s34 * l26, e213[6] = a28, e213[10] = s34 * o28;
        } else if ("ZYX" === t.order) {
            const t = s34 * h24, n132 = s34 * c17, i72 = a28 * h24, r49 = a28 * c17;
            e213[0] = o28 * h24, e213[4] = i72 * l26 - n132, e213[8] = t * l26 + r49, e213[1] = o28 * c17, e213[5] = r49 * l26 + t, e213[9] = n132 * l26 - i72, e213[2] = -l26, e213[6] = a28 * o28, e213[10] = s34 * o28;
        } else if ("YZX" === t.order) {
            const t = s34 * o28, n133 = s34 * l26, i73 = a28 * o28, r50 = a28 * l26;
            e213[0] = o28 * h24, e213[4] = r50 - t * c17, e213[8] = i73 * c17 + n133, e213[1] = c17, e213[5] = s34 * h24, e213[9] = -a28 * h24, e213[2] = -l26 * h24, e213[6] = n133 * c17 + i73, e213[10] = t - r50 * c17;
        } else if ("XZY" === t.order) {
            const t = s34 * o28, n134 = s34 * l26, i74 = a28 * o28, r51 = a28 * l26;
            e213[0] = o28 * h24, e213[4] = -c17, e213[8] = l26 * h24, e213[1] = t * c17 + r51, e213[5] = s34 * h24, e213[9] = n134 * c17 - i74, e213[2] = i74 * c17 - n134, e213[6] = a28 * h24, e213[10] = r51 * c17 + t;
        }
        return e213[3] = 0, e213[7] = 0, e213[11] = 0, e213[12] = 0, e213[13] = 0, e213[14] = 0, e213[15] = 1, this;
    }
    makeRotationFromQuaternion(t) {
        return this.compose(wt, t, Mt);
    }
    lookAt(t, e214, n135) {
        const i75 = this.elements;
        return Et.subVectors(t, e214), 0 === Et.lengthSq() && (Et.z = 1), Et.normalize(), St.crossVectors(n135, Et), 0 === St.lengthSq() && (1 === Math.abs(n135.z) ? Et.x += 1e-4 : Et.z += 1e-4, Et.normalize(), St.crossVectors(n135, Et)), St.normalize(), Tt.crossVectors(Et, St), i75[0] = St.x, i75[4] = Tt.x, i75[8] = Et.x, i75[1] = St.y, i75[5] = Tt.y, i75[9] = Et.y, i75[2] = St.z, i75[6] = Tt.z, i75[10] = Et.z, this;
    }
    multiply(t, e215) {
        return void 0 !== e215 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e215)) : this.multiplyMatrices(this, t);
    }
    premultiply(t) {
        return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e216) {
        const n136 = t.elements, i76 = e216.elements, r52 = this.elements, s35 = n136[0], a29 = n136[4], o29 = n136[8], l27 = n136[12], h25 = n136[1], c18 = n136[5], u14 = n136[9], d10 = n136[13], p10 = n136[2], m7 = n136[6], f4 = n136[10], g4 = n136[14], v4 = n136[3], y3 = n136[7], x3 = n136[11], b3 = n136[15], _2 = i76[0], w2 = i76[4], M1 = i76[8], S1 = i76[12], T1 = i76[1], E1 = i76[5], A1 = i76[9], R1 = i76[13], C1 = i76[2], L1 = i76[6], P1 = i76[10], D1 = i76[14], I1 = i76[3], O1 = i76[7], N1 = i76[11], F1 = i76[15];
        return r52[0] = s35 * _2 + a29 * T1 + o29 * C1 + l27 * I1, r52[4] = s35 * w2 + a29 * E1 + o29 * L1 + l27 * O1, r52[8] = s35 * M1 + a29 * A1 + o29 * P1 + l27 * N1, r52[12] = s35 * S1 + a29 * R1 + o29 * D1 + l27 * F1, r52[1] = h25 * _2 + c18 * T1 + u14 * C1 + d10 * I1, r52[5] = h25 * w2 + c18 * E1 + u14 * L1 + d10 * O1, r52[9] = h25 * M1 + c18 * A1 + u14 * P1 + d10 * N1, r52[13] = h25 * S1 + c18 * R1 + u14 * D1 + d10 * F1, r52[2] = p10 * _2 + m7 * T1 + f4 * C1 + g4 * I1, r52[6] = p10 * w2 + m7 * E1 + f4 * L1 + g4 * O1, r52[10] = p10 * M1 + m7 * A1 + f4 * P1 + g4 * N1, r52[14] = p10 * S1 + m7 * R1 + f4 * D1 + g4 * F1, r52[3] = v4 * _2 + y3 * T1 + x3 * C1 + b3 * I1, r52[7] = v4 * w2 + y3 * E1 + x3 * L1 + b3 * O1, r52[11] = v4 * M1 + y3 * A1 + x3 * P1 + b3 * N1, r52[15] = v4 * S1 + y3 * R1 + x3 * D1 + b3 * F1, this;
    }
    multiplyScalar(t) {
        const e217 = this.elements;
        return e217[0] *= t, e217[4] *= t, e217[8] *= t, e217[12] *= t, e217[1] *= t, e217[5] *= t, e217[9] *= t, e217[13] *= t, e217[2] *= t, e217[6] *= t, e217[10] *= t, e217[14] *= t, e217[3] *= t, e217[7] *= t, e217[11] *= t, e217[15] *= t, this;
    }
    determinant() {
        const t = this.elements, e218 = t[0], n137 = t[4], i77 = t[8], r53 = t[12], s36 = t[1], a30 = t[5], o30 = t[9], l28 = t[13], h26 = t[2], c19 = t[6], u15 = t[10], d11 = t[14];
        return t[3] * (+r53 * o30 * c19 - i77 * l28 * c19 - r53 * a30 * u15 + n137 * l28 * u15 + i77 * a30 * d11 - n137 * o30 * d11) + t[7] * (+e218 * o30 * d11 - e218 * l28 * u15 + r53 * s36 * u15 - i77 * s36 * d11 + i77 * l28 * h26 - r53 * o30 * h26) + t[11] * (+e218 * l28 * c19 - e218 * a30 * d11 - r53 * s36 * c19 + n137 * s36 * d11 + r53 * a30 * h26 - n137 * l28 * h26) + t[15] * (-i77 * a30 * h26 - e218 * o30 * c19 + e218 * a30 * u15 + i77 * s36 * c19 - n137 * s36 * u15 + n137 * o30 * h26);
    }
    transpose() {
        const t = this.elements;
        let e219;
        return e219 = t[1], t[1] = t[4], t[4] = e219, e219 = t[2], t[2] = t[8], t[8] = e219, e219 = t[6], t[6] = t[9], t[9] = e219, e219 = t[3], t[3] = t[12], t[12] = e219, e219 = t[7], t[7] = t[13], t[13] = e219, e219 = t[11], t[11] = t[14], t[14] = e219, this;
    }
    setPosition(t, e220, n138) {
        const i78 = this.elements;
        return t.isVector3 ? (i78[12] = t.x, i78[13] = t.y, i78[14] = t.z) : (i78[12] = t, i78[13] = e220, i78[14] = n138), this;
    }
    invert() {
        const t = this.elements, e221 = t[0], n139 = t[1], i79 = t[2], r54 = t[3], s37 = t[4], a31 = t[5], o31 = t[6], l29 = t[7], h27 = t[8], c20 = t[9], u16 = t[10], d12 = t[11], p11 = t[12], m8 = t[13], f5 = t[14], g5 = t[15], v5 = c20 * f5 * l29 - m8 * u16 * l29 + m8 * o31 * d12 - a31 * f5 * d12 - c20 * o31 * g5 + a31 * u16 * g5, y4 = p11 * u16 * l29 - h27 * f5 * l29 - p11 * o31 * d12 + s37 * f5 * d12 + h27 * o31 * g5 - s37 * u16 * g5, x4 = h27 * m8 * l29 - p11 * c20 * l29 + p11 * a31 * d12 - s37 * m8 * d12 - h27 * a31 * g5 + s37 * c20 * g5, b4 = p11 * c20 * o31 - h27 * m8 * o31 - p11 * a31 * u16 + s37 * m8 * u16 + h27 * a31 * f5 - s37 * c20 * f5, _3 = e221 * v5 + n139 * y4 + i79 * x4 + r54 * b4;
        if (0 === _3) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const w3 = 1 / _3;
        return t[0] = v5 * w3, t[1] = (m8 * u16 * r54 - c20 * f5 * r54 - m8 * i79 * d12 + n139 * f5 * d12 + c20 * i79 * g5 - n139 * u16 * g5) * w3, t[2] = (a31 * f5 * r54 - m8 * o31 * r54 + m8 * i79 * l29 - n139 * f5 * l29 - a31 * i79 * g5 + n139 * o31 * g5) * w3, t[3] = (c20 * o31 * r54 - a31 * u16 * r54 - c20 * i79 * l29 + n139 * u16 * l29 + a31 * i79 * d12 - n139 * o31 * d12) * w3, t[4] = y4 * w3, t[5] = (h27 * f5 * r54 - p11 * u16 * r54 + p11 * i79 * d12 - e221 * f5 * d12 - h27 * i79 * g5 + e221 * u16 * g5) * w3, t[6] = (p11 * o31 * r54 - s37 * f5 * r54 - p11 * i79 * l29 + e221 * f5 * l29 + s37 * i79 * g5 - e221 * o31 * g5) * w3, t[7] = (s37 * u16 * r54 - h27 * o31 * r54 + h27 * i79 * l29 - e221 * u16 * l29 - s37 * i79 * d12 + e221 * o31 * d12) * w3, t[8] = x4 * w3, t[9] = (p11 * c20 * r54 - h27 * m8 * r54 - p11 * n139 * d12 + e221 * m8 * d12 + h27 * n139 * g5 - e221 * c20 * g5) * w3, t[10] = (s37 * m8 * r54 - p11 * a31 * r54 + p11 * n139 * l29 - e221 * m8 * l29 - s37 * n139 * g5 + e221 * a31 * g5) * w3, t[11] = (h27 * a31 * r54 - s37 * c20 * r54 - h27 * n139 * l29 + e221 * c20 * l29 + s37 * n139 * d12 - e221 * a31 * d12) * w3, t[12] = b4 * w3, t[13] = (h27 * m8 * i79 - p11 * c20 * i79 + p11 * n139 * u16 - e221 * m8 * u16 - h27 * n139 * f5 + e221 * c20 * f5) * w3, t[14] = (p11 * a31 * i79 - s37 * m8 * i79 - p11 * n139 * o31 + e221 * m8 * o31 + s37 * n139 * f5 - e221 * a31 * f5) * w3, t[15] = (s37 * c20 * i79 - h27 * a31 * i79 + h27 * n139 * o31 - e221 * c20 * o31 - s37 * n139 * u16 + e221 * a31 * u16) * w3, this;
    }
    scale(t) {
        const e222 = this.elements, n140 = t.x, i80 = t.y, r55 = t.z;
        return e222[0] *= n140, e222[4] *= i80, e222[8] *= r55, e222[1] *= n140, e222[5] *= i80, e222[9] *= r55, e222[2] *= n140, e222[6] *= i80, e222[10] *= r55, e222[3] *= n140, e222[7] *= i80, e222[11] *= r55, this;
    }
    getMaxScaleOnAxis() {
        const t = this.elements, e223 = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n141 = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], i81 = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e223, n141, i81));
    }
    makeTranslation(t, e224, n142) {
        return this.set(1, 0, 0, t, 0, 1, 0, e224, 0, 0, 1, n142, 0, 0, 0, 1), this;
    }
    makeRotationX(t) {
        const e225 = Math.cos(t), n143 = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e225, -n143, 0, 0, n143, e225, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t) {
        const e226 = Math.cos(t), n144 = Math.sin(t);
        return this.set(e226, 0, n144, 0, 0, 1, 0, 0, -n144, 0, e226, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t) {
        const e227 = Math.cos(t), n145 = Math.sin(t);
        return this.set(e227, -n145, 0, 0, n145, e227, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t, e228) {
        const n146 = Math.cos(e228), i82 = Math.sin(e228), r56 = 1 - n146, s38 = t.x, a32 = t.y, o32 = t.z, l30 = r56 * s38, h28 = r56 * a32;
        return this.set(l30 * s38 + n146, l30 * a32 - i82 * o32, l30 * o32 + i82 * a32, 0, l30 * a32 + i82 * o32, h28 * a32 + n146, h28 * o32 - i82 * s38, 0, l30 * o32 - i82 * a32, h28 * o32 + i82 * s38, r56 * o32 * o32 + n146, 0, 0, 0, 0, 1), this;
    }
    makeScale(t, e229, n147) {
        return this.set(t, 0, 0, 0, 0, e229, 0, 0, 0, 0, n147, 0, 0, 0, 0, 1), this;
    }
    makeShear(t, e230, n148, i83, r57, s39) {
        return this.set(1, n148, r57, 0, t, 1, s39, 0, e230, i83, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t, e231, n149) {
        const i84 = this.elements, r58 = e231._x, s40 = e231._y, a33 = e231._z, o33 = e231._w, l31 = r58 + r58, h29 = s40 + s40, c21 = a33 + a33, u17 = r58 * l31, d13 = r58 * h29, p12 = r58 * c21, m9 = s40 * h29, f6 = s40 * c21, g6 = a33 * c21, v6 = o33 * l31, y5 = o33 * h29, x5 = o33 * c21, b5 = n149.x, _4 = n149.y, w4 = n149.z;
        return i84[0] = (1 - (m9 + g6)) * b5, i84[1] = (d13 + x5) * b5, i84[2] = (p12 - y5) * b5, i84[3] = 0, i84[4] = (d13 - x5) * _4, i84[5] = (1 - (u17 + g6)) * _4, i84[6] = (f6 + v6) * _4, i84[7] = 0, i84[8] = (p12 + y5) * w4, i84[9] = (f6 - v6) * w4, i84[10] = (1 - (u17 + m9)) * w4, i84[11] = 0, i84[12] = t.x, i84[13] = t.y, i84[14] = t.z, i84[15] = 1, this;
    }
    decompose(t, e232, n150) {
        const i85 = this.elements;
        let r59 = bt.set(i85[0], i85[1], i85[2]).length();
        const s41 = bt.set(i85[4], i85[5], i85[6]).length(), a34 = bt.set(i85[8], i85[9], i85[10]).length();
        this.determinant() < 0 && (r59 = -r59), t.x = i85[12], t.y = i85[13], t.z = i85[14], _t.copy(this);
        const o34 = 1 / r59, l32 = 1 / s41, h30 = 1 / a34;
        return _t.elements[0] *= o34, _t.elements[1] *= o34, _t.elements[2] *= o34, _t.elements[4] *= l32, _t.elements[5] *= l32, _t.elements[6] *= l32, _t.elements[8] *= h30, _t.elements[9] *= h30, _t.elements[10] *= h30, e232.setFromRotationMatrix(_t), n150.x = r59, n150.y = s41, n150.z = a34, this;
    }
    makePerspective(t, e233, n151, i86, r60, s42) {
        void 0 === s42 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        const a35 = this.elements, o35 = 2 * r60 / (e233 - t), l33 = 2 * r60 / (n151 - i86), h31 = (e233 + t) / (e233 - t), c22 = (n151 + i86) / (n151 - i86), u18 = -(s42 + r60) / (s42 - r60), d14 = -2 * s42 * r60 / (s42 - r60);
        return a35[0] = o35, a35[4] = 0, a35[8] = h31, a35[12] = 0, a35[1] = 0, a35[5] = l33, a35[9] = c22, a35[13] = 0, a35[2] = 0, a35[6] = 0, a35[10] = u18, a35[14] = d14, a35[3] = 0, a35[7] = 0, a35[11] = -1, a35[15] = 0, this;
    }
    makeOrthographic(t, e234, n152, i87, r61, s43) {
        const a36 = this.elements, o36 = 1 / (e234 - t), l34 = 1 / (n152 - i87), h32 = 1 / (s43 - r61), c23 = (e234 + t) * o36, u19 = (n152 + i87) * l34, d15 = (s43 + r61) * h32;
        return a36[0] = 2 * o36, a36[4] = 0, a36[8] = 0, a36[12] = -c23, a36[1] = 0, a36[5] = 2 * l34, a36[9] = 0, a36[13] = -u19, a36[2] = 0, a36[6] = 0, a36[10] = -2 * h32, a36[14] = -d15, a36[3] = 0, a36[7] = 0, a36[11] = 0, a36[15] = 1, this;
    }
    equals(t) {
        const e235 = this.elements, n153 = t.elements;
        for(let t108 = 0; t108 < 16; t108++)if (e235[t108] !== n153[t108]) return !1;
        return !0;
    }
    fromArray(t, e236 = 0) {
        for(let n154 = 0; n154 < 16; n154++)this.elements[n154] = t[n154 + e236];
        return this;
    }
    toArray(t = [], e237 = 0) {
        const n155 = this.elements;
        return t[e237] = n155[0], t[e237 + 1] = n155[1], t[e237 + 2] = n155[2], t[e237 + 3] = n155[3], t[e237 + 4] = n155[4], t[e237 + 5] = n155[5], t[e237 + 6] = n155[6], t[e237 + 7] = n155[7], t[e237 + 8] = n155[8], t[e237 + 9] = n155[9], t[e237 + 10] = n155[10], t[e237 + 11] = n155[11], t[e237 + 12] = n155[12], t[e237 + 13] = n155[13], t[e237 + 14] = n155[14], t[e237 + 15] = n155[15], t;
    }
}
xt.prototype.isMatrix4 = !0;
const bt = new V, _t = new xt, wt = new V(0, 0, 0), Mt = new V(1, 1, 1), St = new V, Tt = new V, Et = new V, At = new xt, Rt = new H;
class Ct {
    constructor(t = 0, e238 = 0, n156 = 0, i88 = Ct.DefaultOrder){
        this._x = t, this._y = e238, this._z = n156, this._order = i88;
    }
    get x() {
        return this._x;
    }
    set x(t) {
        this._x = t, this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(t) {
        this._y = t, this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(t) {
        this._z = t, this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(t) {
        this._order = t, this._onChangeCallback();
    }
    set(t, e239, n157, i89 = this._order) {
        return this._x = t, this._y = e239, this._z = n157, this._order = i89, this._onChangeCallback(), this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t) {
        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t, e240 = this._order, n158 = !0) {
        const i90 = t.elements, r62 = i90[0], s44 = i90[4], a37 = i90[8], o37 = i90[1], l35 = i90[5], c24 = i90[9], u20 = i90[2], d16 = i90[6], p13 = i90[10];
        switch(e240){
            case "XYZ":
                this._y = Math.asin(h(a37, -1, 1)), Math.abs(a37) < .9999999 ? (this._x = Math.atan2(-c24, p13), this._z = Math.atan2(-s44, r62)) : (this._x = Math.atan2(d16, l35), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-h(c24, -1, 1)), Math.abs(c24) < .9999999 ? (this._y = Math.atan2(a37, p13), this._z = Math.atan2(o37, l35)) : (this._y = Math.atan2(-u20, r62), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(h(d16, -1, 1)), Math.abs(d16) < .9999999 ? (this._y = Math.atan2(-u20, p13), this._z = Math.atan2(-s44, l35)) : (this._y = 0, this._z = Math.atan2(o37, r62));
                break;
            case "ZYX":
                this._y = Math.asin(-h(u20, -1, 1)), Math.abs(u20) < .9999999 ? (this._x = Math.atan2(d16, p13), this._z = Math.atan2(o37, r62)) : (this._x = 0, this._z = Math.atan2(-s44, l35));
                break;
            case "YZX":
                this._z = Math.asin(h(o37, -1, 1)), Math.abs(o37) < .9999999 ? (this._x = Math.atan2(-c24, l35), this._y = Math.atan2(-u20, r62)) : (this._x = 0, this._y = Math.atan2(a37, p13));
                break;
            case "XZY":
                this._z = Math.asin(-h(s44, -1, 1)), Math.abs(s44) < .9999999 ? (this._x = Math.atan2(d16, l35), this._y = Math.atan2(a37, r62)) : (this._x = Math.atan2(-c24, p13), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e240);
        }
        return this._order = e240, !0 === n158 && this._onChangeCallback(), this;
    }
    setFromQuaternion(t, e241, n159) {
        return At.makeRotationFromQuaternion(t), this.setFromRotationMatrix(At, e241, n159);
    }
    setFromVector3(t, e242 = this._order) {
        return this.set(t.x, t.y, t.z, e242);
    }
    reorder(t) {
        return Rt.setFromEuler(this), this.setFromQuaternion(Rt, t);
    }
    equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    }
    fromArray(t) {
        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this;
    }
    toArray(t = [], e243 = 0) {
        return t[e243] = this._x, t[e243 + 1] = this._y, t[e243 + 2] = this._z, t[e243 + 3] = this._order, t;
    }
    _onChange(t) {
        return this._onChangeCallback = t, this;
    }
    _onChangeCallback() {}
}
Ct.prototype.isEuler = !0, Ct.DefaultOrder = "XYZ", Ct.RotationOrders = [
    "XYZ",
    "YZX",
    "ZXY",
    "XZY",
    "YXZ",
    "ZYX"
];
class Lt {
    constructor(){
        this.mask = 1;
    }
    set(t) {
        this.mask = (1 << t | 0) >>> 0;
    }
    enable(t) {
        this.mask |= 1 << t | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(t) {
        this.mask ^= 1 << t | 0;
    }
    disable(t) {
        this.mask &= ~(1 << t | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(t) {
        return 0 != (this.mask & t.mask);
    }
    isEnabled(t) {
        return 0 != (this.mask & (1 << t | 0));
    }
}
let Pt = 0;
const Dt = new V, It = new H, Ot = new xt, Nt = new V, Ft = new V, Ut = new V, kt = new H, Bt = new V(1, 0, 0), zt = new V(0, 1, 0), Ht = new V(0, 0, 1), Vt = {
    type: "added"
}, Gt = {
    type: "removed"
};
class Wt extends i {
    constructor(){
        super(), Object.defineProperty(this, "id", {
            value: Pt++
        }), this.uuid = l(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Wt.DefaultUp.clone();
        const t = new V, e244 = new Ct, n160 = new H, i91 = new V(1, 1, 1);
        e244._onChange(function() {
            n160.setFromEuler(e244, !1);
        }), n160._onChange(function() {
            e244.setFromQuaternion(n160, void 0, !1);
        }), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: e244
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n160
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i91
            },
            modelViewMatrix: {
                value: new xt
            },
            normalMatrix: {
                value: new v
            }
        }), this.matrix = new xt, this.matrixWorld = new xt, this.matrixAutoUpdate = Wt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Lt, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t) {
        return this.quaternion.premultiply(t), this;
    }
    setRotationFromAxisAngle(t, e245) {
        this.quaternion.setFromAxisAngle(t, e245);
    }
    setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, !0);
    }
    setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t);
    }
    setRotationFromQuaternion(t) {
        this.quaternion.copy(t);
    }
    rotateOnAxis(t, e246) {
        return It.setFromAxisAngle(t, e246), this.quaternion.multiply(It), this;
    }
    rotateOnWorldAxis(t, e247) {
        return It.setFromAxisAngle(t, e247), this.quaternion.premultiply(It), this;
    }
    rotateX(t) {
        return this.rotateOnAxis(Bt, t);
    }
    rotateY(t) {
        return this.rotateOnAxis(zt, t);
    }
    rotateZ(t) {
        return this.rotateOnAxis(Ht, t);
    }
    translateOnAxis(t, e248) {
        return Dt.copy(t).applyQuaternion(this.quaternion), this.position.add(Dt.multiplyScalar(e248)), this;
    }
    translateX(t) {
        return this.translateOnAxis(Bt, t);
    }
    translateY(t) {
        return this.translateOnAxis(zt, t);
    }
    translateZ(t) {
        return this.translateOnAxis(Ht, t);
    }
    localToWorld(t) {
        return t.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t) {
        return t.applyMatrix4(Ot.copy(this.matrixWorld).invert());
    }
    lookAt(t, e249, n161) {
        t.isVector3 ? Nt.copy(t) : Nt.set(t, e249, n161);
        const i92 = this.parent;
        this.updateWorldMatrix(!0, !1), Ft.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ot.lookAt(Ft, Nt, this.up) : Ot.lookAt(Nt, Ft, this.up), this.quaternion.setFromRotationMatrix(Ot), i92 && (Ot.extractRotation(i92.matrixWorld), It.setFromRotationMatrix(Ot), this.quaternion.premultiply(It.invert()));
    }
    add(t) {
        if (arguments.length > 1) {
            for(let t = 0; t < arguments.length; t++)this.add(arguments[t]);
            return this;
        }
        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Vt)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
    }
    remove(t) {
        if (arguments.length > 1) {
            for(let t = 0; t < arguments.length; t++)this.remove(arguments[t]);
            return this;
        }
        const e250 = this.children.indexOf(t);
        return -1 !== e250 && (t.parent = null, this.children.splice(e250, 1), t.dispatchEvent(Gt)), this;
    }
    removeFromParent() {
        const t = this.parent;
        return null !== t && t.remove(this), this;
    }
    clear() {
        for(let t = 0; t < this.children.length; t++){
            const e251 = this.children[t];
            e251.parent = null, e251.dispatchEvent(Gt);
        }
        return this.children.length = 0, this;
    }
    attach(t) {
        return this.updateWorldMatrix(!0, !1), Ot.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), Ot.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ot), this.add(t), t.updateWorldMatrix(!1, !0), this;
    }
    getObjectById(t) {
        return this.getObjectByProperty("id", t);
    }
    getObjectByName(t) {
        return this.getObjectByProperty("name", t);
    }
    getObjectByProperty(t, e252) {
        if (this[t] === e252) return this;
        for(let n162 = 0, i93 = this.children.length; n162 < i93; n162++){
            const i94 = this.children[n162].getObjectByProperty(t, e252);
            if (void 0 !== i94) return i94;
        }
    }
    getWorldPosition(t) {
        return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(t) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ft, t, Ut), t;
    }
    getWorldScale(t) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ft, kt, t), t;
    }
    getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const e253 = this.matrixWorld.elements;
        return t.set(e253[8], e253[9], e253[10]).normalize();
    }
    raycast() {}
    traverse(t) {
        t(this);
        const e254 = this.children;
        for(let n163 = 0, i95 = e254.length; n163 < i95; n163++)e254[n163].traverse(t);
    }
    traverseVisible(t) {
        if (!1 === this.visible) return;
        t(this);
        const e255 = this.children;
        for(let n164 = 0, i96 = e255.length; n164 < i96; n164++)e255[n164].traverseVisible(t);
    }
    traverseAncestors(t) {
        const e256 = this.parent;
        null !== e256 && (t(e256), e256.traverseAncestors(t));
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
    }
    updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
        const e257 = this.children;
        for(let n165 = 0, i97 = e257.length; n165 < i97; n165++)e257[n165].updateMatrixWorld(t);
    }
    updateWorldMatrix(t, e258) {
        const n166 = this.parent;
        if (!0 === t && null !== n166 && n166.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e258) {
            const t = this.children;
            for(let e259 = 0, n167 = t.length; e259 < n167; e259++)t[e259].updateWorldMatrix(!1, !0);
        }
    }
    toJSON(t109) {
        const e260 = void 0 === t109 || "string" == typeof t109, n168 = {};
        e260 && (t109 = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, n168.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i98 = {};
        function r63(e261, n169) {
            return void 0 === e261[n169.uuid] && (e261[n169.uuid] = n169.toJSON(t109)), n169.uuid;
        }
        if (i98.uuid = this.uuid, i98.type = this.type, "" !== this.name && (i98.name = this.name), !0 === this.castShadow && (i98.castShadow = !0), !0 === this.receiveShadow && (i98.receiveShadow = !0), !1 === this.visible && (i98.visible = !1), !1 === this.frustumCulled && (i98.frustumCulled = !1), 0 !== this.renderOrder && (i98.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i98.userData = this.userData), i98.layers = this.layers.mask, i98.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i98.matrixAutoUpdate = !1), this.isInstancedMesh && (i98.type = "InstancedMesh", i98.count = this.count, i98.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i98.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? i98.background = this.background.toJSON() : this.background.isTexture && (i98.background = this.background.toJSON(t109).uuid)), this.environment && this.environment.isTexture && (i98.environment = this.environment.toJSON(t109).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i98.geometry = r63(t109.geometries, this.geometry);
            const e262 = this.geometry.parameters;
            if (void 0 !== e262 && void 0 !== e262.shapes) {
                const n170 = e262.shapes;
                if (Array.isArray(n170)) for(let e263 = 0, i99 = n170.length; e263 < i99; e263++){
                    const i100 = n170[e263];
                    r63(t109.shapes, i100);
                }
                else r63(t109.shapes, n170);
            }
        }
        if (this.isSkinnedMesh && (i98.bindMode = this.bindMode, i98.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r63(t109.skeletons, this.skeleton), i98.skeleton = this.skeleton.uuid)), void 0 !== this.material) {
            if (Array.isArray(this.material)) {
                const e264 = [];
                for(let n171 = 0, i101 = this.material.length; n171 < i101; n171++)e264.push(r63(t109.materials, this.material[n171]));
                i98.material = e264;
            } else i98.material = r63(t109.materials, this.material);
        }
        if (this.children.length > 0) {
            i98.children = [];
            for(let e265 = 0; e265 < this.children.length; e265++)i98.children.push(this.children[e265].toJSON(t109).object);
        }
        if (this.animations.length > 0) {
            i98.animations = [];
            for(let e266 = 0; e266 < this.animations.length; e266++){
                const n172 = this.animations[e266];
                i98.animations.push(r63(t109.animations, n172));
            }
        }
        if (e260) {
            const e267 = s45(t109.geometries), i102 = s45(t109.materials), r64 = s45(t109.textures), a38 = s45(t109.images), o38 = s45(t109.shapes), l36 = s45(t109.skeletons), h33 = s45(t109.animations), c25 = s45(t109.nodes);
            e267.length > 0 && (n168.geometries = e267), i102.length > 0 && (n168.materials = i102), r64.length > 0 && (n168.textures = r64), a38.length > 0 && (n168.images = a38), o38.length > 0 && (n168.shapes = o38), l36.length > 0 && (n168.skeletons = l36), h33.length > 0 && (n168.animations = h33), c25.length > 0 && (n168.nodes = c25);
        }
        return n168.object = i98, n168;
        function s45(t) {
            const e268 = [];
            for(const n173 in t){
                const i103 = t[n173];
                delete i103.metadata, e268.push(i103);
            }
            return e268;
        }
    }
    clone(t) {
        return (new this.constructor).copy(this, t);
    }
    copy(t, e270 = !0) {
        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e270) for(let e269 = 0; e269 < t.children.length; e269++){
            const n174 = t.children[e269];
            this.add(n174.clone());
        }
        return this;
    }
}
Wt.DefaultUp = new V(0, 1, 0), Wt.DefaultMatrixAutoUpdate = !0, Wt.prototype.isObject3D = !0;
const jt = new V, qt = new V, Xt = new V, $t = new V, Yt = new V, Jt = new V, Kt = new V, Zt = new V, Qt = new V, te = new V;
class ee {
    constructor(t = new V, e271 = new V, n175 = new V){
        this.a = t, this.b = e271, this.c = n175;
    }
    static getNormal(t, e272, n176, i104) {
        i104.subVectors(n176, e272), jt.subVectors(t, e272), i104.cross(jt);
        const r65 = i104.lengthSq();
        return r65 > 0 ? i104.multiplyScalar(1 / Math.sqrt(r65)) : i104.set(0, 0, 0);
    }
    static getBarycoord(t, e273, n177, i105, r66) {
        jt.subVectors(i105, e273), qt.subVectors(n177, e273), Xt.subVectors(t, e273);
        const s46 = jt.dot(jt), a39 = jt.dot(qt), o39 = jt.dot(Xt), l37 = qt.dot(qt), h34 = qt.dot(Xt), c26 = s46 * l37 - a39 * a39;
        if (0 === c26) return r66.set(-2, -1, -1);
        const u21 = 1 / c26, d17 = (l37 * o39 - a39 * h34) * u21, p14 = (s46 * h34 - a39 * o39) * u21;
        return r66.set(1 - d17 - p14, p14, d17);
    }
    static containsPoint(t, e274, n178, i106) {
        return this.getBarycoord(t, e274, n178, i106, $t), $t.x >= 0 && $t.y >= 0 && $t.x + $t.y <= 1;
    }
    static getUV(t, e275, n179, i107, r67, s47, a40, o40) {
        return this.getBarycoord(t, e275, n179, i107, $t), o40.set(0, 0), o40.addScaledVector(r67, $t.x), o40.addScaledVector(s47, $t.y), o40.addScaledVector(a40, $t.z), o40;
    }
    static isFrontFacing(t, e276, n180, i108) {
        return jt.subVectors(n180, e276), qt.subVectors(t, e276), jt.cross(qt).dot(i108) < 0;
    }
    set(t, e277, n181) {
        return this.a.copy(t), this.b.copy(e277), this.c.copy(n181), this;
    }
    setFromPointsAndIndices(t, e278, n182, i109) {
        return this.a.copy(t[e278]), this.b.copy(t[n182]), this.c.copy(t[i109]), this;
    }
    setFromAttributeAndIndices(t, e279, n183, i110) {
        return this.a.fromBufferAttribute(t, e279), this.b.fromBufferAttribute(t, n183), this.c.fromBufferAttribute(t, i110), this;
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
    getArea() {
        return jt.subVectors(this.c, this.b), qt.subVectors(this.a, this.b), .5 * jt.cross(qt).length();
    }
    getMidpoint(t) {
        return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(t) {
        return ee.getNormal(this.a, this.b, this.c, t);
    }
    getPlane(t) {
        return t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t, e280) {
        return ee.getBarycoord(t, this.a, this.b, this.c, e280);
    }
    getUV(t, e281, n184, i111, r68) {
        return ee.getUV(t, this.a, this.b, this.c, e281, n184, i111, r68);
    }
    containsPoint(t) {
        return ee.containsPoint(t, this.a, this.b, this.c);
    }
    isFrontFacing(t) {
        return ee.isFrontFacing(this.a, this.b, this.c, t);
    }
    intersectsBox(t) {
        return t.intersectsTriangle(this);
    }
    closestPointToPoint(t, e282) {
        const n185 = this.a, i112 = this.b, r69 = this.c;
        let s48, a41;
        Yt.subVectors(i112, n185), Jt.subVectors(r69, n185), Zt.subVectors(t, n185);
        const o41 = Yt.dot(Zt), l38 = Jt.dot(Zt);
        if (o41 <= 0 && l38 <= 0) return e282.copy(n185);
        Qt.subVectors(t, i112);
        const h35 = Yt.dot(Qt), c27 = Jt.dot(Qt);
        if (h35 >= 0 && c27 <= h35) return e282.copy(i112);
        const u22 = o41 * c27 - h35 * l38;
        if (u22 <= 0 && o41 >= 0 && h35 <= 0) return s48 = o41 / (o41 - h35), e282.copy(n185).addScaledVector(Yt, s48);
        te.subVectors(t, r69);
        const d18 = Yt.dot(te), p15 = Jt.dot(te);
        if (p15 >= 0 && d18 <= p15) return e282.copy(r69);
        const m10 = d18 * l38 - o41 * p15;
        if (m10 <= 0 && l38 >= 0 && p15 <= 0) return a41 = l38 / (l38 - p15), e282.copy(n185).addScaledVector(Jt, a41);
        const f7 = h35 * p15 - d18 * c27;
        if (f7 <= 0 && c27 - h35 >= 0 && d18 - p15 >= 0) return Kt.subVectors(r69, i112), a41 = (c27 - h35) / (c27 - h35 + (d18 - p15)), e282.copy(i112).addScaledVector(Kt, a41);
        const g7 = 1 / (f7 + m10 + u22);
        return s48 = m10 * g7, a41 = u22 * g7, e282.copy(n185).addScaledVector(Yt, s48).addScaledVector(Jt, a41);
    }
    equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
}
let ne = 0;
class ie extends i {
    constructor(){
        super(), Object.defineProperty(this, "id", {
            value: ne++
        }), this.uuid = l(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
        return this._alphaTest;
    }
    set alphaTest(t) {
        this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString();
    }
    setValues(t) {
        if (void 0 !== t) for(const e283 in t){
            const n186 = t[e283];
            if (void 0 === n186) {
                console.warn("THREE.Material: '" + e283 + "' parameter is undefined.");
                continue;
            }
            if ("shading" === e283) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n186;
                continue;
            }
            const i113 = this[e283];
            void 0 !== i113 ? i113 && i113.isColor ? i113.set(n186) : i113 && i113.isVector3 && n186 && n186.isVector3 ? i113.copy(n186) : this[e283] = n186 : console.warn("THREE." + this.type + ": '" + e283 + "' is not a property of this material.");
        }
    }
    toJSON(t110) {
        const e284 = void 0 === t110 || "string" == typeof t110;
        e284 && (t110 = {
            textures: {},
            images: {}
        });
        const n187 = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        function i114(t) {
            const e285 = [];
            for(const n188 in t){
                const i115 = t[n188];
                delete i115.metadata, e285.push(i115);
            }
            return e285;
        }
        if (n187.uuid = this.uuid, n187.type = this.type, "" !== this.name && (n187.name = this.name), this.color && this.color.isColor && (n187.color = this.color.getHex()), void 0 !== this.roughness && (n187.roughness = this.roughness), void 0 !== this.metalness && (n187.metalness = this.metalness), void 0 !== this.sheen && (n187.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n187.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n187.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n187.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n187.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n187.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n187.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n187.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n187.shininess = this.shininess), void 0 !== this.clearcoat && (n187.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n187.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n187.clearcoatMap = this.clearcoatMap.toJSON(t110).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n187.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t110).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n187.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t110).uuid, n187.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n187.map = this.map.toJSON(t110).uuid), this.matcap && this.matcap.isTexture && (n187.matcap = this.matcap.toJSON(t110).uuid), this.alphaMap && this.alphaMap.isTexture && (n187.alphaMap = this.alphaMap.toJSON(t110).uuid), this.lightMap && this.lightMap.isTexture && (n187.lightMap = this.lightMap.toJSON(t110).uuid, n187.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n187.aoMap = this.aoMap.toJSON(t110).uuid, n187.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n187.bumpMap = this.bumpMap.toJSON(t110).uuid, n187.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n187.normalMap = this.normalMap.toJSON(t110).uuid, n187.normalMapType = this.normalMapType, n187.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n187.displacementMap = this.displacementMap.toJSON(t110).uuid, n187.displacementScale = this.displacementScale, n187.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n187.roughnessMap = this.roughnessMap.toJSON(t110).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n187.metalnessMap = this.metalnessMap.toJSON(t110).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n187.emissiveMap = this.emissiveMap.toJSON(t110).uuid), this.specularMap && this.specularMap.isTexture && (n187.specularMap = this.specularMap.toJSON(t110).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n187.specularIntensityMap = this.specularIntensityMap.toJSON(t110).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n187.specularColorMap = this.specularColorMap.toJSON(t110).uuid), this.envMap && this.envMap.isTexture && (n187.envMap = this.envMap.toJSON(t110).uuid, void 0 !== this.combine && (n187.combine = this.combine)), void 0 !== this.envMapIntensity && (n187.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n187.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n187.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n187.gradientMap = this.gradientMap.toJSON(t110).uuid), void 0 !== this.transmission && (n187.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n187.transmissionMap = this.transmissionMap.toJSON(t110).uuid), void 0 !== this.thickness && (n187.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n187.thicknessMap = this.thicknessMap.toJSON(t110).uuid), void 0 !== this.attenuationDistance && (n187.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n187.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n187.size = this.size), null !== this.shadowSide && (n187.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n187.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n187.blending = this.blending), 0 !== this.side && (n187.side = this.side), this.vertexColors && (n187.vertexColors = !0), this.opacity < 1 && (n187.opacity = this.opacity), !0 === this.transparent && (n187.transparent = this.transparent), n187.depthFunc = this.depthFunc, n187.depthTest = this.depthTest, n187.depthWrite = this.depthWrite, n187.colorWrite = this.colorWrite, n187.stencilWrite = this.stencilWrite, n187.stencilWriteMask = this.stencilWriteMask, n187.stencilFunc = this.stencilFunc, n187.stencilRef = this.stencilRef, n187.stencilFuncMask = this.stencilFuncMask, n187.stencilFail = this.stencilFail, n187.stencilZFail = this.stencilZFail, n187.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n187.rotation = this.rotation), !0 === this.polygonOffset && (n187.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n187.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n187.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n187.linewidth = this.linewidth), void 0 !== this.dashSize && (n187.dashSize = this.dashSize), void 0 !== this.gapSize && (n187.gapSize = this.gapSize), void 0 !== this.scale && (n187.scale = this.scale), !0 === this.dithering && (n187.dithering = !0), this.alphaTest > 0 && (n187.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n187.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n187.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n187.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n187.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n187.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n187.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n187.flatShading = this.flatShading), !1 === this.visible && (n187.visible = !1), !1 === this.toneMapped && (n187.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n187.userData = this.userData), e284) {
            const e286 = i114(t110.textures), r70 = i114(t110.images);
            e286.length > 0 && (n187.textures = e286), r70.length > 0 && (n187.images = r70);
        }
        return n187;
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    copy(t) {
        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
        const e287 = t.clippingPlanes;
        let n189 = null;
        if (null !== e287) {
            const t = e287.length;
            n189 = new Array(t);
            for(let i116 = 0; i116 !== t; ++i116)n189[i116] = e287[i116].clone();
        }
        return this.clippingPlanes = n189, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
    set needsUpdate(t) {
        !0 === t && this.version++;
    }
}
ie.prototype.isMaterial = !0, ie.fromType = function() {
    return null;
};
class re extends ie {
    constructor(t){
        super(), this.type = "MeshBasicMaterial", this.color = new L(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
    }
}
re.prototype.isMeshBasicMaterial = !0;
const se = new V, ae = new g;
class oe {
    constructor(t, e288, n190){
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e288, this.count = void 0 !== t ? t.length / e288 : 0, this.normalized = !0 === n190, this.usage = 35044, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0;
    }
    onUploadCallback() {}
    set needsUpdate(t) {
        !0 === t && this.version++;
    }
    setUsage(t) {
        return this.usage = t, this;
    }
    copy(t) {
        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
    }
    copyAt(t, e289, n191) {
        t *= this.itemSize, n191 *= e289.itemSize;
        for(let i117 = 0, r71 = this.itemSize; i117 < r71; i117++)this.array[t + i117] = e289.array[n191 + i117];
        return this;
    }
    copyArray(t) {
        return this.array.set(t), this;
    }
    copyColorsArray(t) {
        const e290 = this.array;
        let n192 = 0;
        for(let i118 = 0, r72 = t.length; i118 < r72; i118++){
            let r73 = t[i118];
            void 0 === r73 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i118), r73 = new L), e290[n192++] = r73.r, e290[n192++] = r73.g, e290[n192++] = r73.b;
        }
        return this;
    }
    copyVector2sArray(t) {
        const e291 = this.array;
        let n193 = 0;
        for(let i119 = 0, r74 = t.length; i119 < r74; i119++){
            let r75 = t[i119];
            void 0 === r75 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i119), r75 = new g), e291[n193++] = r75.x, e291[n193++] = r75.y;
        }
        return this;
    }
    copyVector3sArray(t) {
        const e292 = this.array;
        let n194 = 0;
        for(let i120 = 0, r76 = t.length; i120 < r76; i120++){
            let r77 = t[i120];
            void 0 === r77 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i120), r77 = new V), e292[n194++] = r77.x, e292[n194++] = r77.y, e292[n194++] = r77.z;
        }
        return this;
    }
    copyVector4sArray(t) {
        const e293 = this.array;
        let n195 = 0;
        for(let i121 = 0, r78 = t.length; i121 < r78; i121++){
            let r79 = t[i121];
            void 0 === r79 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i121), r79 = new U), e293[n195++] = r79.x, e293[n195++] = r79.y, e293[n195++] = r79.z, e293[n195++] = r79.w;
        }
        return this;
    }
    applyMatrix3(t) {
        if (2 === this.itemSize) for(let e295 = 0, n197 = this.count; e295 < n197; e295++)ae.fromBufferAttribute(this, e295), ae.applyMatrix3(t), this.setXY(e295, ae.x, ae.y);
        else if (3 === this.itemSize) for(let e294 = 0, n196 = this.count; e294 < n196; e294++)se.fromBufferAttribute(this, e294), se.applyMatrix3(t), this.setXYZ(e294, se.x, se.y, se.z);
        return this;
    }
    applyMatrix4(t) {
        for(let e296 = 0, n198 = this.count; e296 < n198; e296++)se.fromBufferAttribute(this, e296), se.applyMatrix4(t), this.setXYZ(e296, se.x, se.y, se.z);
        return this;
    }
    applyNormalMatrix(t) {
        for(let e297 = 0, n199 = this.count; e297 < n199; e297++)se.fromBufferAttribute(this, e297), se.applyNormalMatrix(t), this.setXYZ(e297, se.x, se.y, se.z);
        return this;
    }
    transformDirection(t) {
        for(let e298 = 0, n200 = this.count; e298 < n200; e298++)se.fromBufferAttribute(this, e298), se.transformDirection(t), this.setXYZ(e298, se.x, se.y, se.z);
        return this;
    }
    set(t, e299 = 0) {
        return this.array.set(t, e299), this;
    }
    getX(t) {
        return this.array[t * this.itemSize];
    }
    setX(t, e300) {
        return this.array[t * this.itemSize] = e300, this;
    }
    getY(t) {
        return this.array[t * this.itemSize + 1];
    }
    setY(t, e301) {
        return this.array[t * this.itemSize + 1] = e301, this;
    }
    getZ(t) {
        return this.array[t * this.itemSize + 2];
    }
    setZ(t, e302) {
        return this.array[t * this.itemSize + 2] = e302, this;
    }
    getW(t) {
        return this.array[t * this.itemSize + 3];
    }
    setW(t, e303) {
        return this.array[t * this.itemSize + 3] = e303, this;
    }
    setXY(t, e304, n201) {
        return t *= this.itemSize, this.array[t + 0] = e304, this.array[t + 1] = n201, this;
    }
    setXYZ(t, e305, n202, i122) {
        return t *= this.itemSize, this.array[t + 0] = e305, this.array[t + 1] = n202, this.array[t + 2] = i122, this;
    }
    setXYZW(t, e306, n203, i123, r80) {
        return t *= this.itemSize, this.array[t + 0] = e306, this.array[t + 1] = n203, this.array[t + 2] = i123, this.array[t + 3] = r80, this;
    }
    onUpload(t) {
        return this.onUploadCallback = t, this;
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
        const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
        return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t;
    }
}
oe.prototype.isBufferAttribute = !0;
class le extends oe {
    constructor(t, e307, n204){
        super(new Uint16Array(t), e307, n204);
    }
}
class he extends oe {
    constructor(t, e308, n205){
        super(new Uint32Array(t), e308, n205);
    }
}
(class extends oe {
    constructor(t, e309, n206){
        super(new Uint16Array(t), e309, n206);
    }
}).prototype.isFloat16BufferAttribute = !0;
class ce extends oe {
    constructor(t, e310, n207){
        super(new Float32Array(t), e310, n207);
    }
}
let ue = 0;
const de = new xt, pe = new Wt, me = new V, fe = new j, ge = new j, ve = new V;
class ye extends i {
    constructor(){
        super(), Object.defineProperty(this, "id", {
            value: ue++
        }), this.uuid = l(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {};
    }
    getIndex() {
        return this.index;
    }
    setIndex(t) {
        return Array.isArray(t) ? this.index = new (y(t) ? he : le)(t, 1) : this.index = t, this;
    }
    getAttribute(t) {
        return this.attributes[t];
    }
    setAttribute(t, e311) {
        return this.attributes[t] = e311, this;
    }
    deleteAttribute(t) {
        return delete this.attributes[t], this;
    }
    hasAttribute(t) {
        return void 0 !== this.attributes[t];
    }
    addGroup(t, e312, n208 = 0) {
        this.groups.push({
            start: t,
            count: e312,
            materialIndex: n208
        });
    }
    clearGroups() {
        this.groups = [];
    }
    setDrawRange(t, e313) {
        this.drawRange.start = t, this.drawRange.count = e313;
    }
    applyMatrix4(t) {
        const e314 = this.attributes.position;
        void 0 !== e314 && (e314.applyMatrix4(t), e314.needsUpdate = !0);
        const n209 = this.attributes.normal;
        if (void 0 !== n209) {
            const e315 = (new v).getNormalMatrix(t);
            n209.applyNormalMatrix(e315), n209.needsUpdate = !0;
        }
        const i124 = this.attributes.tangent;
        return void 0 !== i124 && (i124.transformDirection(t), i124.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
    }
    applyQuaternion(t) {
        return de.makeRotationFromQuaternion(t), this.applyMatrix4(de), this;
    }
    rotateX(t) {
        return de.makeRotationX(t), this.applyMatrix4(de), this;
    }
    rotateY(t) {
        return de.makeRotationY(t), this.applyMatrix4(de), this;
    }
    rotateZ(t) {
        return de.makeRotationZ(t), this.applyMatrix4(de), this;
    }
    translate(t, e316, n210) {
        return de.makeTranslation(t, e316, n210), this.applyMatrix4(de), this;
    }
    scale(t, e317, n211) {
        return de.makeScale(t, e317, n211), this.applyMatrix4(de), this;
    }
    lookAt(t) {
        return pe.lookAt(t), pe.updateMatrix(), this.applyMatrix4(pe.matrix), this;
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(me).negate(), this.translate(me.x, me.y, me.z), this;
    }
    setFromPoints(t) {
        const e318 = [];
        for(let n212 = 0, i125 = t.length; n212 < i125; n212++){
            const i126 = t[n212];
            e318.push(i126.x, i126.y, i126.z || 0);
        }
        return this.setAttribute("position", new ce(e318, 3)), this;
    }
    computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new j);
        const t = this.attributes.position, e319 = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new V(-1 / 0, -1 / 0, -1 / 0), new V(1 / 0, 1 / 0, 1 / 0));
        if (void 0 !== t) {
            if (this.boundingBox.setFromBufferAttribute(t), e319) for(let t111 = 0, n213 = e319.length; t111 < n213; t111++){
                const n214 = e319[t111];
                fe.setFromBufferAttribute(n214), this.morphTargetsRelative ? (ve.addVectors(this.boundingBox.min, fe.min), this.boundingBox.expandByPoint(ve), ve.addVectors(this.boundingBox.max, fe.max), this.boundingBox.expandByPoint(ve)) : (this.boundingBox.expandByPoint(fe.min), this.boundingBox.expandByPoint(fe.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new ct);
        const t = this.attributes.position, e321 = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new V, 1 / 0);
        if (t) {
            const n217 = this.boundingSphere.center;
            if (fe.setFromBufferAttribute(t), e321) for(let t112 = 0, n215 = e321.length; t112 < n215; t112++){
                const n216 = e321[t112];
                ge.setFromBufferAttribute(n216), this.morphTargetsRelative ? (ve.addVectors(fe.min, ge.min), fe.expandByPoint(ve), ve.addVectors(fe.max, ge.max), fe.expandByPoint(ve)) : (fe.expandByPoint(ge.min), fe.expandByPoint(ge.max));
            }
            fe.getCenter(n217);
            let i127 = 0;
            for(let e320 = 0, r82 = t.count; e320 < r82; e320++)ve.fromBufferAttribute(t, e320), i127 = Math.max(i127, n217.distanceToSquared(ve));
            if (e321) for(let r81 = 0, s49 = e321.length; r81 < s49; r81++){
                const s50 = e321[r81], a42 = this.morphTargetsRelative;
                for(let e322 = 0, r83 = s50.count; e322 < r83; e322++)ve.fromBufferAttribute(s50, e322), a42 && (me.fromBufferAttribute(t, e322), ve.add(me)), i127 = Math.max(i127, n217.distanceToSquared(ve));
            }
            this.boundingSphere.radius = Math.sqrt(i127), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    }
    computeTangents() {
        const t116 = this.index, e325 = this.attributes;
        if (null === t116 || void 0 === e325.position || void 0 === e325.normal || void 0 === e325.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        const n218 = t116.array, i128 = e325.position.array, r84 = e325.normal.array, s51 = e325.uv.array, a43 = i128.length / 3;
        !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new oe(new Float32Array(4 * a43), 4));
        const o42 = this.getAttribute("tangent").array, l39 = [], h36 = [];
        for(let t113 = 0; t113 < a43; t113++)l39[t113] = new V, h36[t113] = new V;
        const c28 = new V, u23 = new V, d19 = new V, p16 = new g, m11 = new g, f8 = new g, v7 = new V, y6 = new V;
        function x6(t, e326, n219) {
            c28.fromArray(i128, 3 * t), u23.fromArray(i128, 3 * e326), d19.fromArray(i128, 3 * n219), p16.fromArray(s51, 2 * t), m11.fromArray(s51, 2 * e326), f8.fromArray(s51, 2 * n219), u23.sub(c28), d19.sub(c28), m11.sub(p16), f8.sub(p16);
            const r85 = 1 / (m11.x * f8.y - f8.x * m11.y);
            isFinite(r85) && (v7.copy(u23).multiplyScalar(f8.y).addScaledVector(d19, -m11.y).multiplyScalar(r85), y6.copy(d19).multiplyScalar(m11.x).addScaledVector(u23, -f8.x).multiplyScalar(r85), l39[t].add(v7), l39[e326].add(v7), l39[n219].add(v7), h36[t].add(y6), h36[e326].add(y6), h36[n219].add(y6));
        }
        let b6 = this.groups;
        0 === b6.length && (b6 = [
            {
                start: 0,
                count: n218.length
            }
        ]);
        for(let t114 = 0, e323 = b6.length; t114 < e323; ++t114){
            const e327 = b6[t114], i129 = e327.start;
            for(let t = i129, r86 = i129 + e327.count; t < r86; t += 3)x6(n218[t + 0], n218[t + 1], n218[t + 2]);
        }
        const _5 = new V, w5 = new V, M2 = new V, S2 = new V;
        function T2(t) {
            M2.fromArray(r84, 3 * t), S2.copy(M2);
            const e328 = l39[t];
            _5.copy(e328), _5.sub(M2.multiplyScalar(M2.dot(e328))).normalize(), w5.crossVectors(S2, e328);
            const n220 = w5.dot(h36[t]) < 0 ? -1 : 1;
            o42[4 * t] = _5.x, o42[4 * t + 1] = _5.y, o42[4 * t + 2] = _5.z, o42[4 * t + 3] = n220;
        }
        for(let t115 = 0, e324 = b6.length; t115 < e324; ++t115){
            const e329 = b6[t115], i130 = e329.start;
            for(let t = i130, r87 = i130 + e329.count; t < r87; t += 3)T2(n218[t + 0]), T2(n218[t + 1]), T2(n218[t + 2]);
        }
    }
    computeVertexNormals() {
        const t = this.index, e330 = this.getAttribute("position");
        if (void 0 !== e330) {
            let n221 = this.getAttribute("normal");
            if (void 0 === n221) n221 = new oe(new Float32Array(3 * e330.count), 3), this.setAttribute("normal", n221);
            else for(let t118 = 0, e331 = n221.count; t118 < e331; t118++)n221.setXYZ(t118, 0, 0, 0);
            const i131 = new V, r88 = new V, s52 = new V, a45 = new V, o43 = new V, l40 = new V, h37 = new V, c29 = new V;
            if (t) for(let u24 = 0, d20 = t.count; u24 < d20; u24 += 3){
                const d21 = t.getX(u24 + 0), p17 = t.getX(u24 + 1), m12 = t.getX(u24 + 2);
                i131.fromBufferAttribute(e330, d21), r88.fromBufferAttribute(e330, p17), s52.fromBufferAttribute(e330, m12), h37.subVectors(s52, r88), c29.subVectors(i131, r88), h37.cross(c29), a45.fromBufferAttribute(n221, d21), o43.fromBufferAttribute(n221, p17), l40.fromBufferAttribute(n221, m12), a45.add(h37), o43.add(h37), l40.add(h37), n221.setXYZ(d21, a45.x, a45.y, a45.z), n221.setXYZ(p17, o43.x, o43.y, o43.z), n221.setXYZ(m12, l40.x, l40.y, l40.z);
            }
            else for(let t117 = 0, a44 = e330.count; t117 < a44; t117 += 3)i131.fromBufferAttribute(e330, t117 + 0), r88.fromBufferAttribute(e330, t117 + 1), s52.fromBufferAttribute(e330, t117 + 2), h37.subVectors(s52, r88), c29.subVectors(i131, r88), h37.cross(c29), n221.setXYZ(t117 + 0, h37.x, h37.y, h37.z), n221.setXYZ(t117 + 1, h37.x, h37.y, h37.z), n221.setXYZ(t117 + 2, h37.x, h37.y, h37.z);
            this.normalizeNormals(), n221.needsUpdate = !0;
        }
    }
    merge(t, e332) {
        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
        void 0 === e332 && (e332 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        const n222 = this.attributes;
        for(const i132 in n222){
            if (void 0 === t.attributes[i132]) continue;
            const r89 = n222[i132].array, s53 = t.attributes[i132], a46 = s53.array, o44 = s53.itemSize * e332, l41 = Math.min(a46.length, r89.length - o44);
            for(let t119 = 0, e333 = o44; t119 < l41; t119++, e333++)r89[e333] = a46[t119];
        }
        return this;
    }
    normalizeNormals() {
        const t = this.attributes.normal;
        for(let e334 = 0, n223 = t.count; e334 < n223; e334++)ve.fromBufferAttribute(t, e334), ve.normalize(), t.setXYZ(e334, ve.x, ve.y, ve.z);
    }
    toNonIndexed() {
        function t121(t, e336) {
            const n226 = t.array, i135 = t.itemSize, r93 = t.normalized, s55 = new n226.constructor(e336.length * i135);
            let a47 = 0, o45 = 0;
            for(let r91 = 0, l42 = e336.length; r91 < l42; r91++){
                a47 = t.isInterleavedBufferAttribute ? e336[r91] * t.data.stride + t.offset : e336[r91] * i135;
                for(let t122 = 0; t122 < i135; t122++)s55[o45++] = n226[a47++];
            }
            return new oe(s55, i135, r93);
        }
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const e335 = new ye, n225 = this.index.array, i134 = this.attributes;
        for(const r92 in i134){
            const s56 = t121(i134[r92], n225);
            e335.setAttribute(r92, s56);
        }
        const r90 = this.morphAttributes;
        for(const i133 in r90){
            const s57 = [], a48 = r90[i133];
            for(let e337 = 0, i136 = a48.length; e337 < i136; e337++){
                const i137 = t121(a48[e337], n225);
                s57.push(i137);
            }
            e335.morphAttributes[i133] = s57;
        }
        e335.morphTargetsRelative = this.morphTargetsRelative;
        const s54 = this.groups;
        for(let t120 = 0, n224 = s54.length; t120 < n224; t120++){
            const n227 = s54[t120];
            e335.addGroup(n227.start, n227.count, n227.materialIndex);
        }
        return e335;
    }
    toJSON() {
        const t = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
            const e340 = this.parameters;
            for(const n228 in e340)void 0 !== e340[n228] && (t[n228] = e340[n228]);
            return t;
        }
        t.data = {
            attributes: {}
        };
        const e341 = this.index;
        null !== e341 && (t.data.index = {
            type: e341.array.constructor.name,
            array: Array.prototype.slice.call(e341.array)
        });
        const n229 = this.attributes;
        for(const e338 in n229){
            const i138 = n229[e338];
            t.data.attributes[e338] = i138.toJSON(t.data);
        }
        const i141 = {};
        let r94 = !1;
        for(const e339 in this.morphAttributes){
            const n230 = this.morphAttributes[e339], s58 = [];
            for(let e342 = 0, i139 = n230.length; e342 < i139; e342++){
                const i140 = n230[e342];
                s58.push(i140.toJSON(t.data));
            }
            s58.length > 0 && (i141[e339] = s58, r94 = !0);
        }
        r94 && (t.data.morphAttributes = i141, t.data.morphTargetsRelative = this.morphTargetsRelative);
        const s59 = this.groups;
        s59.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s59)));
        const a49 = this.boundingSphere;
        return null !== a49 && (t.data.boundingSphere = {
            center: a49.center.toArray(),
            radius: a49.radius
        }), t;
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    copy(t) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const e344 = {};
        this.name = t.name;
        const n231 = t.index;
        null !== n231 && this.setIndex(n231.clone(e344));
        const i142 = t.attributes;
        for(const t123 in i142){
            const n232 = i142[t123];
            this.setAttribute(t123, n232.clone(e344));
        }
        const r95 = t.morphAttributes;
        for(const t124 in r95){
            const n233 = [], i143 = r95[t124];
            for(let t = 0, r96 = i143.length; t < r96; t++)n233.push(i143[t].clone(e344));
            this.morphAttributes[t124] = n233;
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const s60 = t.groups;
        for(let t125 = 0, e343 = s60.length; t125 < e343; t125++){
            const e345 = s60[t125];
            this.addGroup(e345.start, e345.count, e345.materialIndex);
        }
        const a50 = t.boundingBox;
        null !== a50 && (this.boundingBox = a50.clone());
        const o46 = t.boundingSphere;
        return null !== o46 && (this.boundingSphere = o46.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, void 0 !== t.parameters && (this.parameters = Object.assign({}, t.parameters)), this;
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}
ye.prototype.isBufferGeometry = !0;
const xe = new xt, be = new yt, _e = new ct, we = new V, Me = new V, Se = new V, Te = new V, Ee = new V, Ae = new V, Re = new V, Ce = new V, Le = new V, Pe = new g, De = new g, Ie = new g, Oe = new V, Ne = new V;
class Fe extends Wt {
    constructor(t = new ye, e346 = new re){
        super(), this.type = "Mesh", this.geometry = t, this.material = e346, this.updateMorphTargets();
    }
    copy(t) {
        return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
    }
    updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
            const e347 = t.morphAttributes, n234 = Object.keys(e347);
            if (n234.length > 0) {
                const t = e347[n234[0]];
                if (void 0 !== t) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let e348 = 0, n235 = t.length; e348 < n235; e348++){
                        const n236 = t[e348].name || String(e348);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n236] = e348;
                    }
                }
            }
        } else {
            const e349 = t.morphTargets;
            void 0 !== e349 && e349.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
    }
    raycast(t, e350) {
        const n237 = this.geometry, i144 = this.material, r97 = this.matrixWorld;
        if (void 0 === i144) return;
        if (null === n237.boundingSphere && n237.computeBoundingSphere(), _e.copy(n237.boundingSphere), _e.applyMatrix4(r97), !1 === t.ray.intersectsSphere(_e)) return;
        if (xe.copy(r97).invert(), be.copy(t.ray).applyMatrix4(xe), null !== n237.boundingBox && !1 === be.intersectsBox(n237.boundingBox)) return;
        let s61;
        if (n237.isBufferGeometry) {
            const r98 = n237.index, a51 = n237.attributes.position, o47 = n237.morphAttributes.position, l43 = n237.morphTargetsRelative, h38 = n237.attributes.uv, c30 = n237.attributes.uv2, u26 = n237.groups, d22 = n237.drawRange;
            if (null !== r98) {
                if (Array.isArray(i144)) for(let n239 = 0, p18 = u26.length; n239 < p18; n239++){
                    const p19 = u26[n239], m13 = i144[p19.materialIndex];
                    for(let n240 = Math.max(p19.start, d22.start), i145 = Math.min(r98.count, Math.min(p19.start + p19.count, d22.start + d22.count)); n240 < i145; n240 += 3){
                        const i146 = r98.getX(n240), u27 = r98.getX(n240 + 1), d23 = r98.getX(n240 + 2);
                        s61 = Ue(this, m13, t, be, a51, o47, l43, h38, c30, i146, u27, d23), s61 && (s61.faceIndex = Math.floor(n240 / 3), s61.face.materialIndex = p19.materialIndex, e350.push(s61));
                    }
                }
                else for(let n238 = Math.max(0, d22.start), u25 = Math.min(r98.count, d22.start + d22.count); n238 < u25; n238 += 3){
                    const u28 = r98.getX(n238), d24 = r98.getX(n238 + 1), p20 = r98.getX(n238 + 2);
                    s61 = Ue(this, i144, t, be, a51, o47, l43, h38, c30, u28, d24, p20), s61 && (s61.faceIndex = Math.floor(n238 / 3), e350.push(s61));
                }
            } else if (void 0 !== a51) {
                if (Array.isArray(i144)) for(let n242 = 0, r100 = u26.length; n242 < r100; n242++){
                    const r101 = u26[n242], p21 = i144[r101.materialIndex];
                    for(let n243 = Math.max(r101.start, d22.start), i147 = Math.min(a51.count, Math.min(r101.start + r101.count, d22.start + d22.count)); n243 < i147; n243 += 3)s61 = Ue(this, p21, t, be, a51, o47, l43, h38, c30, n243, n243 + 1, n243 + 2), s61 && (s61.faceIndex = Math.floor(n243 / 3), s61.face.materialIndex = r101.materialIndex, e350.push(s61));
                }
                else for(let n241 = Math.max(0, d22.start), r99 = Math.min(a51.count, d22.start + d22.count); n241 < r99; n241 += 3)s61 = Ue(this, i144, t, be, a51, o47, l43, h38, c30, n241, n241 + 1, n241 + 2), s61 && (s61.faceIndex = Math.floor(n241 / 3), e350.push(s61));
            }
        } else n237.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
}
function Ue(t126, e353, n245, i148, r102, s62, a52, o48, l44, h39, c31, u29) {
    we.fromBufferAttribute(r102, h39), Me.fromBufferAttribute(r102, c31), Se.fromBufferAttribute(r102, u29);
    const d25 = t126.morphTargetInfluences;
    if (s62 && d25) {
        Re.set(0, 0, 0), Ce.set(0, 0, 0), Le.set(0, 0, 0);
        for(let t = 0, e351 = s62.length; t < e351; t++){
            const e352 = d25[t], n244 = s62[t];
            0 !== e352 && (Te.fromBufferAttribute(n244, h39), Ee.fromBufferAttribute(n244, c31), Ae.fromBufferAttribute(n244, u29), a52 ? (Re.addScaledVector(Te, e352), Ce.addScaledVector(Ee, e352), Le.addScaledVector(Ae, e352)) : (Re.addScaledVector(Te.sub(we), e352), Ce.addScaledVector(Ee.sub(Me), e352), Le.addScaledVector(Ae.sub(Se), e352)));
        }
        we.add(Re), Me.add(Ce), Se.add(Le);
    }
    t126.isSkinnedMesh && (t126.boneTransform(h39, we), t126.boneTransform(c31, Me), t126.boneTransform(u29, Se));
    const p22 = function(t, e354, n246, i149, r103, s63, a53, o49) {
        let l45;
        if (l45 = 1 === e354.side ? i149.intersectTriangle(a53, s63, r103, !0, o49) : i149.intersectTriangle(r103, s63, a53, 2 !== e354.side, o49), null === l45) return null;
        Ne.copy(o49), Ne.applyMatrix4(t.matrixWorld);
        const h40 = n246.ray.origin.distanceTo(Ne);
        return h40 < n246.near || h40 > n246.far ? null : {
            distance: h40,
            point: Ne.clone(),
            object: t
        };
    }(t126, e353, n245, i148, we, Me, Se, Oe);
    if (p22) {
        o48 && (Pe.fromBufferAttribute(o48, h39), De.fromBufferAttribute(o48, c31), Ie.fromBufferAttribute(o48, u29), p22.uv = ee.getUV(Oe, we, Me, Se, Pe, De, Ie, new g)), l44 && (Pe.fromBufferAttribute(l44, h39), De.fromBufferAttribute(l44, c31), Ie.fromBufferAttribute(l44, u29), p22.uv2 = ee.getUV(Oe, we, Me, Se, Pe, De, Ie, new g));
        const t = {
            a: h39,
            b: c31,
            c: u29,
            normal: new V,
            materialIndex: 0
        };
        ee.getNormal(we, Me, Se, t.normal), p22.face = t;
    }
    return p22;
}
Fe.prototype.isMesh = !0;
class ke extends ye {
    constructor(t128 = 1, e355 = 1, n247 = 1, i150 = 1, r104 = 1, s64 = 1){
        super(), this.type = "BoxGeometry", this.parameters = {
            width: t128,
            height: e355,
            depth: n247,
            widthSegments: i150,
            heightSegments: r104,
            depthSegments: s64
        };
        const a54 = this;
        i150 = Math.floor(i150), r104 = Math.floor(r104), s64 = Math.floor(s64);
        const o50 = [], l46 = [], h41 = [], c32 = [];
        let u30 = 0, d26 = 0;
        function p23(t, e357, n248, i151, r105, s66, p24, m14, f9, g8, v8) {
            const y7 = s66 / f9, x7 = p24 / g8, b7 = s66 / 2, _6 = p24 / 2, w6 = m14 / 2, M3 = f9 + 1, S3 = g8 + 1;
            let T3 = 0, E2 = 0;
            const A2 = new V;
            for(let s65 = 0; s65 < S3; s65++){
                const a55 = s65 * x7 - _6;
                for(let o51 = 0; o51 < M3; o51++){
                    const u31 = o51 * y7 - b7;
                    A2[t] = u31 * i151, A2[e357] = a55 * r105, A2[n248] = w6, l46.push(A2.x, A2.y, A2.z), A2[t] = 0, A2[e357] = 0, A2[n248] = m14 > 0 ? 1 : -1, h41.push(A2.x, A2.y, A2.z), c32.push(o51 / f9), c32.push(1 - s65 / g8), T3 += 1;
                }
            }
            for(let t127 = 0; t127 < g8; t127++)for(let e356 = 0; e356 < f9; e356++){
                const n249 = u30 + e356 + M3 * t127, i152 = u30 + e356 + M3 * (t127 + 1), r106 = u30 + (e356 + 1) + M3 * (t127 + 1), s67 = u30 + (e356 + 1) + M3 * t127;
                o50.push(n249, i152, s67), o50.push(i152, r106, s67), E2 += 6;
            }
            a54.addGroup(d26, E2, v8), d26 += E2, u30 += T3;
        }
        p23("z", "y", "x", -1, -1, n247, e355, t128, s64, r104, 0), p23("z", "y", "x", 1, -1, n247, e355, -t128, s64, r104, 1), p23("x", "z", "y", 1, 1, t128, n247, e355, i150, s64, 2), p23("x", "z", "y", 1, -1, t128, n247, -e355, i150, s64, 3), p23("x", "y", "z", 1, -1, t128, e355, n247, i150, r104, 4), p23("x", "y", "z", -1, -1, t128, e355, -n247, i150, r104, 5), this.setIndex(o50), this.setAttribute("position", new ce(l46, 3)), this.setAttribute("normal", new ce(h41, 3)), this.setAttribute("uv", new ce(c32, 2));
    }
    static fromJSON(t) {
        return new ke(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
    }
}
function Be(t) {
    const e358 = {};
    for(const n250 in t){
        e358[n250] = {};
        for(const i153 in t[n250]){
            const r107 = t[n250][i153];
            r107 && (r107.isColor || r107.isMatrix3 || r107.isMatrix4 || r107.isVector2 || r107.isVector3 || r107.isVector4 || r107.isTexture || r107.isQuaternion) ? e358[n250][i153] = r107.clone() : Array.isArray(r107) ? e358[n250][i153] = r107.slice() : e358[n250][i153] = r107;
        }
    }
    return e358;
}
function ze(t) {
    const e359 = {};
    for(let n251 = 0; n251 < t.length; n251++){
        const i154 = Be(t[n251]);
        for(const t129 in i154)e359[t129] = i154[t129];
    }
    return e359;
}
const He = {
    clone: Be,
    merge: ze
};
class Ve extends ie {
    constructor(t){
        super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [
                1,
                1,
                1
            ],
            uv: [
                0,
                0
            ],
            uv2: [
                0,
                0
            ]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
    }
    copy(t) {
        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Be(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
    }
    toJSON(t) {
        const e360 = super.toJSON(t);
        e360.glslVersion = this.glslVersion, e360.uniforms = {};
        for(const n253 in this.uniforms){
            const i155 = this.uniforms[n253].value;
            i155 && i155.isTexture ? e360.uniforms[n253] = {
                type: "t",
                value: i155.toJSON(t).uuid
            } : i155 && i155.isColor ? e360.uniforms[n253] = {
                type: "c",
                value: i155.getHex()
            } : i155 && i155.isVector2 ? e360.uniforms[n253] = {
                type: "v2",
                value: i155.toArray()
            } : i155 && i155.isVector3 ? e360.uniforms[n253] = {
                type: "v3",
                value: i155.toArray()
            } : i155 && i155.isVector4 ? e360.uniforms[n253] = {
                type: "v4",
                value: i155.toArray()
            } : i155 && i155.isMatrix3 ? e360.uniforms[n253] = {
                type: "m3",
                value: i155.toArray()
            } : i155 && i155.isMatrix4 ? e360.uniforms[n253] = {
                type: "m4",
                value: i155.toArray()
            } : e360.uniforms[n253] = {
                value: i155
            };
        }
        Object.keys(this.defines).length > 0 && (e360.defines = this.defines), e360.vertexShader = this.vertexShader, e360.fragmentShader = this.fragmentShader;
        const n252 = {};
        for(const t130 in this.extensions)!0 === this.extensions[t130] && (n252[t130] = !0);
        return Object.keys(n252).length > 0 && (e360.extensions = n252), e360;
    }
}
Ve.prototype.isShaderMaterial = !0;
class Ge extends Wt {
    constructor(){
        super(), this.type = "Camera", this.matrixWorldInverse = new xt, this.projectionMatrix = new xt, this.projectionMatrixInverse = new xt;
    }
    copy(t, e361) {
        return super.copy(t, e361), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
    }
    getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const e362 = this.matrixWorld.elements;
        return t.set(-e362[8], -e362[9], -e362[10]).normalize();
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, e363) {
        super.updateWorldMatrix(t, e363), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
        return (new this.constructor).copy(this);
    }
}
Ge.prototype.isCamera = !0;
class We extends Ge {
    constructor(t = 50, e364 = 1, n254 = .1, i156 = 2e3){
        super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n254, this.far = i156, this.focus = 10, this.aspect = e364, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(t, e365) {
        return super.copy(t, e365), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    }
    setFocalLength(t) {
        const e366 = .5 * this.getFilmHeight() / t;
        this.fov = 2 * o * Math.atan(e366), this.updateProjectionMatrix();
    }
    getFocalLength() {
        const t = Math.tan(.5 * a * this.fov);
        return .5 * this.getFilmHeight() / t;
    }
    getEffectiveFOV() {
        return 2 * o * Math.atan(Math.tan(.5 * a * this.fov) / this.zoom);
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(t, e367, n255, i157, r108, s68) {
        this.aspect = t / e367, null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e367, this.view.offsetX = n255, this.view.offsetY = i157, this.view.width = r108, this.view.height = s68, this.updateProjectionMatrix();
    }
    clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const t = this.near;
        let e368 = t * Math.tan(.5 * a * this.fov) / this.zoom, n256 = 2 * e368, i158 = this.aspect * n256, r109 = -0.5 * i158;
        const s69 = this.view;
        if (null !== this.view && this.view.enabled) {
            const t = s69.fullWidth, a56 = s69.fullHeight;
            r109 += s69.offsetX * i158 / t, e368 -= s69.offsetY * n256 / a56, i158 *= s69.width / t, n256 *= s69.height / a56;
        }
        const o52 = this.filmOffset;
        0 !== o52 && (r109 += t * o52 / this.getFilmWidth()), this.projectionMatrix.makePerspective(r109, r109 + i158, e368, e368 - n256, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
        const e369 = super.toJSON(t);
        return e369.object.fov = this.fov, e369.object.zoom = this.zoom, e369.object.near = this.near, e369.object.far = this.far, e369.object.focus = this.focus, e369.object.aspect = this.aspect, null !== this.view && (e369.object.view = Object.assign({}, this.view)), e369.object.filmGauge = this.filmGauge, e369.object.filmOffset = this.filmOffset, e369;
    }
}
We.prototype.isPerspectiveCamera = !0;
class je extends Wt {
    constructor(t, e370, n257){
        if (super(), this.type = "CubeCamera", !0 !== n257.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        this.renderTarget = n257;
        const i159 = new We(90, 1, t, e370);
        i159.layers = this.layers, i159.up.set(0, -1, 0), i159.lookAt(new V(1, 0, 0)), this.add(i159);
        const r110 = new We(90, 1, t, e370);
        r110.layers = this.layers, r110.up.set(0, -1, 0), r110.lookAt(new V(-1, 0, 0)), this.add(r110);
        const s70 = new We(90, 1, t, e370);
        s70.layers = this.layers, s70.up.set(0, 0, 1), s70.lookAt(new V(0, 1, 0)), this.add(s70);
        const a57 = new We(90, 1, t, e370);
        a57.layers = this.layers, a57.up.set(0, 0, -1), a57.lookAt(new V(0, -1, 0)), this.add(a57);
        const o53 = new We(90, 1, t, e370);
        o53.layers = this.layers, o53.up.set(0, -1, 0), o53.lookAt(new V(0, 0, 1)), this.add(o53);
        const l47 = new We(90, 1, t, e370);
        l47.layers = this.layers, l47.up.set(0, -1, 0), l47.lookAt(new V(0, 0, -1)), this.add(l47);
    }
    update(t, e371) {
        null === this.parent && this.updateMatrixWorld();
        const n258 = this.renderTarget, [i160, r111, s71, a58, o54, l48] = this.children, h42 = t.getRenderTarget(), c33 = t.outputEncoding, u32 = t.toneMapping, d27 = t.xr.enabled;
        t.outputEncoding = 3e3, t.toneMapping = 0, t.xr.enabled = !1;
        const p25 = n258.texture.generateMipmaps;
        n258.texture.generateMipmaps = !1, t.setRenderTarget(n258, 0), t.render(e371, i160), t.setRenderTarget(n258, 1), t.render(e371, r111), t.setRenderTarget(n258, 2), t.render(e371, s71), t.setRenderTarget(n258, 3), t.render(e371, a58), t.setRenderTarget(n258, 4), t.render(e371, o54), n258.texture.generateMipmaps = p25, t.setRenderTarget(n258, 5), t.render(e371, l48), t.setRenderTarget(h42), t.outputEncoding = c33, t.toneMapping = u32, t.xr.enabled = d27, n258.texture.needsPMREMUpdate = !0;
    }
}
class qe extends F {
    constructor(t, e372, n259, i161, r112, s72, a59, o55, l49, h43){
        super(t = void 0 !== t ? t : [], e372 = void 0 !== e372 ? e372 : 301, n259, i161, r112, s72, a59, o55, l49, h43), this.flipY = !1;
    }
    get images() {
        return this.image;
    }
    set images(t) {
        this.image = t;
    }
}
qe.prototype.isCubeTexture = !0;
class Xe extends k {
    constructor(t, e373 = {}){
        super(t, t, e373);
        const n260 = {
            width: t,
            height: t,
            depth: 1
        }, i162 = [
            n260,
            n260,
            n260,
            n260,
            n260,
            n260
        ];
        this.texture = new qe(i162, e373.mapping, e373.wrapS, e373.wrapT, e373.magFilter, e373.minFilter, e373.format, e373.type, e373.anisotropy, e373.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e373.generateMipmaps && e373.generateMipmaps, this.texture.minFilter = void 0 !== e373.minFilter ? e373.minFilter : 1006;
    }
    fromEquirectangularTexture(t, e374) {
        this.texture.type = e374.type, this.texture.encoding = e374.encoding, this.texture.generateMipmaps = e374.generateMipmaps, this.texture.minFilter = e374.minFilter, this.texture.magFilter = e374.magFilter;
        const n261 = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			",
            fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			"
        }, i163 = new ke(5, 5, 5), r113 = new Ve({
            name: "CubemapFromEquirect",
            uniforms: Be(n261.uniforms),
            vertexShader: n261.vertexShader,
            fragmentShader: n261.fragmentShader,
            side: 1,
            blending: 0
        });
        r113.uniforms.tEquirect.value = e374;
        const s73 = new Fe(i163, r113), a60 = e374.minFilter;
        1008 === e374.minFilter && (e374.minFilter = 1006);
        return new je(1, 10, this).update(t, s73), e374.minFilter = a60, s73.geometry.dispose(), s73.material.dispose(), this;
    }
    clear(t, e375, n262, i164) {
        const r115 = t.getRenderTarget();
        for(let r114 = 0; r114 < 6; r114++)t.setRenderTarget(this, r114), t.clear(e375, n262, i164);
        t.setRenderTarget(r115);
    }
}
Xe.prototype.isWebGLCubeRenderTarget = !0;
const $e = new V, Ye = new V, Je = new v;
class Ke {
    constructor(t = new V(1, 0, 0), e376 = 0){
        this.normal = t, this.constant = e376;
    }
    set(t, e377) {
        return this.normal.copy(t), this.constant = e377, this;
    }
    setComponents(t, e378, n263, i165) {
        return this.normal.set(t, e378, n263), this.constant = i165, this;
    }
    setFromNormalAndCoplanarPoint(t, e379) {
        return this.normal.copy(t), this.constant = -e379.dot(this.normal), this;
    }
    setFromCoplanarPoints(t, e380, n264) {
        const i166 = $e.subVectors(n264, e380).cross(Ye.subVectors(t, e380)).normalize();
        return this.setFromNormalAndCoplanarPoint(i166, t), this;
    }
    copy(t) {
        return this.normal.copy(t.normal), this.constant = t.constant, this;
    }
    normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), this.constant *= t, this;
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(t) {
        return this.normal.dot(t) + this.constant;
    }
    distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius;
    }
    projectPoint(t, e381) {
        return e381.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
    }
    intersectLine(t, e382) {
        const n265 = t.delta($e), i167 = this.normal.dot(n265);
        if (0 === i167) return 0 === this.distanceToPoint(t.start) ? e382.copy(t.start) : null;
        const r116 = -(t.start.dot(this.normal) + this.constant) / i167;
        return r116 < 0 || r116 > 1 ? null : e382.copy(n265).multiplyScalar(r116).add(t.start);
    }
    intersectsLine(t) {
        const e383 = this.distanceToPoint(t.start), n266 = this.distanceToPoint(t.end);
        return e383 < 0 && n266 > 0 || n266 < 0 && e383 > 0;
    }
    intersectsBox(t) {
        return t.intersectsPlane(this);
    }
    intersectsSphere(t) {
        return t.intersectsPlane(this);
    }
    coplanarPoint(t) {
        return t.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t, e384) {
        const n267 = e384 || Je.getNormalMatrix(t), i168 = this.coplanarPoint($e).applyMatrix4(t), r117 = this.normal.applyMatrix3(n267).normalize();
        return this.constant = -i168.dot(r117), this;
    }
    translate(t) {
        return this.constant -= t.dot(this.normal), this;
    }
    equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
    }
    clone() {
        return (new this.constructor).copy(this);
    }
}
Ke.prototype.isPlane = !0;
const Ze = new ct, Qe = new V;
class tn {
    constructor(t = new Ke, e385 = new Ke, n268 = new Ke, i169 = new Ke, r118 = new Ke, s74 = new Ke){
        this.planes = [
            t,
            e385,
            n268,
            i169,
            r118,
            s74
        ];
    }
    set(t, e386, n269, i170, r119, s75) {
        const a61 = this.planes;
        return a61[0].copy(t), a61[1].copy(e386), a61[2].copy(n269), a61[3].copy(i170), a61[4].copy(r119), a61[5].copy(s75), this;
    }
    copy(t) {
        const e387 = this.planes;
        for(let n270 = 0; n270 < 6; n270++)e387[n270].copy(t.planes[n270]);
        return this;
    }
    setFromProjectionMatrix(t) {
        const e388 = this.planes, n271 = t.elements, i171 = n271[0], r120 = n271[1], s76 = n271[2], a62 = n271[3], o56 = n271[4], l50 = n271[5], h44 = n271[6], c34 = n271[7], u33 = n271[8], d28 = n271[9], p26 = n271[10], m15 = n271[11], f10 = n271[12], g9 = n271[13], v9 = n271[14], y8 = n271[15];
        return e388[0].setComponents(a62 - i171, c34 - o56, m15 - u33, y8 - f10).normalize(), e388[1].setComponents(a62 + i171, c34 + o56, m15 + u33, y8 + f10).normalize(), e388[2].setComponents(a62 + r120, c34 + l50, m15 + d28, y8 + g9).normalize(), e388[3].setComponents(a62 - r120, c34 - l50, m15 - d28, y8 - g9).normalize(), e388[4].setComponents(a62 - s76, c34 - h44, m15 - p26, y8 - v9).normalize(), e388[5].setComponents(a62 + s76, c34 + h44, m15 + p26, y8 + v9).normalize(), this;
    }
    intersectsObject(t) {
        const e389 = t.geometry;
        return null === e389.boundingSphere && e389.computeBoundingSphere(), Ze.copy(e389.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Ze);
    }
    intersectsSprite(t) {
        return Ze.center.set(0, 0, 0), Ze.radius = .7071067811865476, Ze.applyMatrix4(t.matrixWorld), this.intersectsSphere(Ze);
    }
    intersectsSphere(t) {
        const e390 = this.planes, n272 = t.center, i172 = -t.radius;
        for(let t131 = 0; t131 < 6; t131++){
            if (e390[t131].distanceToPoint(n272) < i172) return !1;
        }
        return !0;
    }
    intersectsBox(t) {
        const e391 = this.planes;
        for(let n273 = 0; n273 < 6; n273++){
            const i173 = e391[n273];
            if (Qe.x = i173.normal.x > 0 ? t.max.x : t.min.x, Qe.y = i173.normal.y > 0 ? t.max.y : t.min.y, Qe.z = i173.normal.z > 0 ? t.max.z : t.min.z, i173.distanceToPoint(Qe) < 0) return !1;
        }
        return !0;
    }
    containsPoint(t) {
        const e392 = this.planes;
        for(let n274 = 0; n274 < 6; n274++)if (e392[n274].distanceToPoint(t) < 0) return !1;
        return !0;
    }
    clone() {
        return (new this.constructor).copy(this);
    }
}
function en() {
    let t132 = null, e393 = !1, n275 = null, i174 = null;
    function r121(e394, s77) {
        n275(e394, s77), i174 = t132.requestAnimationFrame(r121);
    }
    return {
        start: function() {
            !0 !== e393 && null !== n275 && (i174 = t132.requestAnimationFrame(r121), e393 = !0);
        },
        stop: function() {
            t132.cancelAnimationFrame(i174), e393 = !1;
        },
        setAnimationLoop: function(t) {
            n275 = t;
        },
        setContext: function(e395) {
            t132 = e395;
        }
    };
}
function nn(t133, e396) {
    const n276 = e396.isWebGL2, i175 = new WeakMap;
    return {
        get: function(t) {
            return t.isInterleavedBufferAttribute && (t = t.data), i175.get(t);
        },
        remove: function(e397) {
            e397.isInterleavedBufferAttribute && (e397 = e397.data);
            const n277 = i175.get(e397);
            n277 && (t133.deleteBuffer(n277.buffer), i175.delete(e397));
        },
        update: function(e398, r122) {
            if (e398.isGLBufferAttribute) {
                const t = i175.get(e398);
                return void ((!t || t.version < e398.version) && i175.set(e398, {
                    buffer: e398.buffer,
                    type: e398.type,
                    bytesPerElement: e398.elementSize,
                    version: e398.version
                }));
            }
            e398.isInterleavedBufferAttribute && (e398 = e398.data);
            const s78 = i175.get(e398);
            void 0 === s78 ? i175.set(e398, function(e399, i176) {
                const r123 = e399.array, s79 = e399.usage, a63 = t133.createBuffer();
                let o57;
                if (t133.bindBuffer(i176, a63), t133.bufferData(i176, r123, s79), e399.onUploadCallback(), r123 instanceof Float32Array) o57 = 5126;
                else if (r123 instanceof Uint16Array) {
                    if (e399.isFloat16BufferAttribute) {
                        if (!n276) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                        o57 = 5131;
                    } else o57 = 5123;
                } else if (r123 instanceof Int16Array) o57 = 5122;
                else if (r123 instanceof Uint32Array) o57 = 5125;
                else if (r123 instanceof Int32Array) o57 = 5124;
                else if (r123 instanceof Int8Array) o57 = 5120;
                else if (r123 instanceof Uint8Array) o57 = 5121;
                else {
                    if (!(r123 instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r123);
                    o57 = 5121;
                }
                return {
                    buffer: a63,
                    type: o57,
                    bytesPerElement: r123.BYTES_PER_ELEMENT,
                    version: e399.version
                };
            }(e398, r122)) : s78.version < e398.version && (!function(e400, i177, r124) {
                const s80 = i177.array, a64 = i177.updateRange;
                t133.bindBuffer(r124, e400), -1 === a64.count ? t133.bufferSubData(r124, 0, s80) : (n276 ? t133.bufferSubData(r124, a64.offset * s80.BYTES_PER_ELEMENT, s80, a64.offset, a64.count) : t133.bufferSubData(r124, a64.offset * s80.BYTES_PER_ELEMENT, s80.subarray(a64.offset, a64.offset + a64.count)), a64.count = -1);
            }(s78.buffer, e398, r122), s78.version = e398.version);
        }
    };
}
class rn extends ye {
    constructor(t = 1, e402 = 1, n278 = 1, i178 = 1){
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e402,
            widthSegments: n278,
            heightSegments: i178
        };
        const r125 = t / 2, s81 = e402 / 2, a65 = Math.floor(n278), o58 = Math.floor(i178), l51 = a65 + 1, h45 = o58 + 1, c35 = t / a65, u34 = e402 / o58, d29 = [], p27 = [], m16 = [], f11 = [];
        for(let t134 = 0; t134 < h45; t134++){
            const e403 = t134 * u34 - s81;
            for(let n279 = 0; n279 < l51; n279++){
                const i179 = n279 * c35 - r125;
                p27.push(i179, -e403, 0), m16.push(0, 0, 1), f11.push(n279 / a65), f11.push(1 - t134 / o58);
            }
        }
        for(let t135 = 0; t135 < o58; t135++)for(let e401 = 0; e401 < a65; e401++){
            const n280 = e401 + l51 * t135, i180 = e401 + l51 * (t135 + 1), r126 = e401 + 1 + l51 * (t135 + 1), s82 = e401 + 1 + l51 * t135;
            d29.push(n280, i180, s82), d29.push(i180, r126, s82);
        }
        this.setIndex(d29), this.setAttribute("position", new ce(p27, 3)), this.setAttribute("normal", new ce(m16, 3)), this.setAttribute("uv", new ce(f11, 2));
    }
    static fromJSON(t) {
        return new rn(t.width, t.height, t.widthSegments, t.heightSegments);
    }
}
const sn = {
    alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
    alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif",
    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",
    aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",
    aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
    begin_vertex: "vec3 transformed = vec3( position );",
    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",
    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",
    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",
    color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",
    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",
    color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",
    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}",
    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",
    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
    envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",
    envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
    envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif",
    envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",
    fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}",
    lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif",
    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",
    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)",
    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)",
    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif",
    lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",
    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",
    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",
    map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
    morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif",
    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif",
    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif",
    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;",
    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
    normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
    normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
    normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif",
    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif",
    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif",
    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif",
    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",
    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif",
    shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",
    skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
    tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
    transmission_fragment: "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif",
    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif",
    uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif",
    uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",
    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif",
    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",
    depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",
    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}",
    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}",
    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",
    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}",
    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}"
}, an = {
    common: {
        diffuse: {
            value: new L(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new v
        },
        uv2Transform: {
            value: new v
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new g(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new L(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new L(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new v
        }
    },
    sprite: {
        diffuse: {
            value: new L(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new g(.5, .5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new v
        }
    }
}, on = {
    basic: {
        uniforms: ze([
            an.common,
            an.specularmap,
            an.envmap,
            an.aomap,
            an.lightmap,
            an.fog
        ]),
        vertexShader: sn.meshbasic_vert,
        fragmentShader: sn.meshbasic_frag
    },
    lambert: {
        uniforms: ze([
            an.common,
            an.specularmap,
            an.envmap,
            an.aomap,
            an.lightmap,
            an.emissivemap,
            an.fog,
            an.lights,
            {
                emissive: {
                    value: new L(0)
                }
            }
        ]),
        vertexShader: sn.meshlambert_vert,
        fragmentShader: sn.meshlambert_frag
    },
    phong: {
        uniforms: ze([
            an.common,
            an.specularmap,
            an.envmap,
            an.aomap,
            an.lightmap,
            an.emissivemap,
            an.bumpmap,
            an.normalmap,
            an.displacementmap,
            an.fog,
            an.lights,
            {
                emissive: {
                    value: new L(0)
                },
                specular: {
                    value: new L(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: sn.meshphong_vert,
        fragmentShader: sn.meshphong_frag
    },
    standard: {
        uniforms: ze([
            an.common,
            an.envmap,
            an.aomap,
            an.lightmap,
            an.emissivemap,
            an.bumpmap,
            an.normalmap,
            an.displacementmap,
            an.roughnessmap,
            an.metalnessmap,
            an.fog,
            an.lights,
            {
                emissive: {
                    value: new L(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }
        ]),
        vertexShader: sn.meshphysical_vert,
        fragmentShader: sn.meshphysical_frag
    },
    toon: {
        uniforms: ze([
            an.common,
            an.aomap,
            an.lightmap,
            an.emissivemap,
            an.bumpmap,
            an.normalmap,
            an.displacementmap,
            an.gradientmap,
            an.fog,
            an.lights,
            {
                emissive: {
                    value: new L(0)
                }
            }
        ]),
        vertexShader: sn.meshtoon_vert,
        fragmentShader: sn.meshtoon_frag
    },
    matcap: {
        uniforms: ze([
            an.common,
            an.bumpmap,
            an.normalmap,
            an.displacementmap,
            an.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: sn.meshmatcap_vert,
        fragmentShader: sn.meshmatcap_frag
    },
    points: {
        uniforms: ze([
            an.points,
            an.fog
        ]),
        vertexShader: sn.points_vert,
        fragmentShader: sn.points_frag
    },
    dashed: {
        uniforms: ze([
            an.common,
            an.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: sn.linedashed_vert,
        fragmentShader: sn.linedashed_frag
    },
    depth: {
        uniforms: ze([
            an.common,
            an.displacementmap
        ]),
        vertexShader: sn.depth_vert,
        fragmentShader: sn.depth_frag
    },
    normal: {
        uniforms: ze([
            an.common,
            an.bumpmap,
            an.normalmap,
            an.displacementmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: sn.meshnormal_vert,
        fragmentShader: sn.meshnormal_frag
    },
    sprite: {
        uniforms: ze([
            an.sprite,
            an.fog
        ]),
        vertexShader: sn.sprite_vert,
        fragmentShader: sn.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new v
            },
            t2D: {
                value: null
            }
        },
        vertexShader: sn.background_vert,
        fragmentShader: sn.background_frag
    },
    cube: {
        uniforms: ze([
            an.envmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: sn.cube_vert,
        fragmentShader: sn.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: sn.equirect_vert,
        fragmentShader: sn.equirect_frag
    },
    distanceRGBA: {
        uniforms: ze([
            an.common,
            an.displacementmap,
            {
                referencePosition: {
                    value: new V
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }
        ]),
        vertexShader: sn.distanceRGBA_vert,
        fragmentShader: sn.distanceRGBA_frag
    },
    shadow: {
        uniforms: ze([
            an.lights,
            an.fog,
            {
                color: {
                    value: new L(0)
                },
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: sn.shadow_vert,
        fragmentShader: sn.shadow_frag
    }
};
function ln(t136, e404, n281, i181, r127, s83) {
    const a66 = new L(0);
    let o59, l52, h46 = !0 === r127 ? 0 : 1, c36 = null, u35 = 0, d30 = null;
    function p28(t, e405) {
        n281.buffers.color.setClear(t.r, t.g, t.b, e405, s83);
    }
    return {
        getClearColor: function() {
            return a66;
        },
        setClearColor: function(t, e406 = 1) {
            a66.set(t), h46 = e406, p28(a66, h46);
        },
        getClearAlpha: function() {
            return h46;
        },
        setClearAlpha: function(t) {
            h46 = t, p28(a66, h46);
        },
        render: function(n282, r128) {
            let s84 = !1, m17 = !0 === r128.isScene ? r128.background : null;
            m17 && m17.isTexture && (m17 = e404.get(m17));
            const f12 = t136.xr, g10 = f12.getSession && f12.getSession();
            g10 && "additive" === g10.environmentBlendMode && (m17 = null), null === m17 ? p28(a66, h46) : m17 && m17.isColor && (p28(m17, 1), s84 = !0), (t136.autoClear || s84) && t136.clear(t136.autoClearColor, t136.autoClearDepth, t136.autoClearStencil), m17 && (m17.isCubeTexture || 306 === m17.mapping) ? (void 0 === l52 && (l52 = new Fe(new ke(1, 1, 1), new Ve({
                name: "BackgroundCubeMaterial",
                uniforms: Be(on.cube.uniforms),
                vertexShader: on.cube.vertexShader,
                fragmentShader: on.cube.fragmentShader,
                side: 1,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), l52.geometry.deleteAttribute("normal"), l52.geometry.deleteAttribute("uv"), l52.onBeforeRender = function(t, e, n283) {
                this.matrixWorld.copyPosition(n283.matrixWorld);
            }, Object.defineProperty(l52.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value;
                }
            }), i181.update(l52)), l52.material.uniforms.envMap.value = m17, l52.material.uniforms.flipEnvMap.value = m17.isCubeTexture && !1 === m17.isRenderTargetTexture ? -1 : 1, c36 === m17 && u35 === m17.version && d30 === t136.toneMapping || (l52.material.needsUpdate = !0, c36 = m17, u35 = m17.version, d30 = t136.toneMapping), n282.unshift(l52, l52.geometry, l52.material, 0, 0, null)) : m17 && m17.isTexture && (void 0 === o59 && (o59 = new Fe(new rn(2, 2), new Ve({
                name: "BackgroundMaterial",
                uniforms: Be(on.background.uniforms),
                vertexShader: on.background.vertexShader,
                fragmentShader: on.background.fragmentShader,
                side: 0,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })), o59.geometry.deleteAttribute("normal"), Object.defineProperty(o59.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value;
                }
            }), i181.update(o59)), o59.material.uniforms.t2D.value = m17, !0 === m17.matrixAutoUpdate && m17.updateMatrix(), o59.material.uniforms.uvTransform.value.copy(m17.matrix), c36 === m17 && u35 === m17.version && d30 === t136.toneMapping || (o59.material.needsUpdate = !0, c36 = m17, u35 = m17.version, d30 = t136.toneMapping), n282.unshift(o59, o59.geometry, o59.material, 0, 0, null));
        }
    };
}
function hn(t138, e407, n284, i182) {
    const r129 = t138.getParameter(34921), s85 = i182.isWebGL2 ? null : e407.get("OES_vertex_array_object"), a67 = i182.isWebGL2 || null !== s85, o60 = {}, l53 = p29(null);
    let h47 = l53, c37 = !1;
    function u36(e408) {
        return i182.isWebGL2 ? t138.bindVertexArray(e408) : s85.bindVertexArrayOES(e408);
    }
    function d31(e409) {
        return i182.isWebGL2 ? t138.deleteVertexArray(e409) : s85.deleteVertexArrayOES(e409);
    }
    function p29(t) {
        const e410 = [], n285 = [], i183 = [];
        for(let t137 = 0; t137 < r129; t137++)e410[t137] = 0, n285[t137] = 0, i183[t137] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: e410,
            enabledAttributes: n285,
            attributeDivisors: i183,
            object: t,
            attributes: {},
            index: null
        };
    }
    function m18() {
        const t = h47.newAttributes;
        for(let e411 = 0, n286 = t.length; e411 < n286; e411++)t[e411] = 0;
    }
    function f13(t) {
        g11(t, 0);
    }
    function g11(n287, r130) {
        const s86 = h47.newAttributes, a68 = h47.enabledAttributes, o61 = h47.attributeDivisors;
        if (s86[n287] = 1, 0 === a68[n287] && (t138.enableVertexAttribArray(n287), a68[n287] = 1), o61[n287] !== r130) (i182.isWebGL2 ? t138 : e407.get("ANGLE_instanced_arrays"))[i182.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n287, r130), o61[n287] = r130;
    }
    function v10() {
        const e412 = h47.newAttributes, n288 = h47.enabledAttributes;
        for(let i184 = 0, r131 = n288.length; i184 < r131; i184++)n288[i184] !== e412[i184] && (t138.disableVertexAttribArray(i184), n288[i184] = 0);
    }
    function y9(e413, n289, r132, s87, a69, o62) {
        !0 !== i182.isWebGL2 || 5124 !== r132 && 5125 !== r132 ? t138.vertexAttribPointer(e413, n289, r132, s87, a69, o62) : t138.vertexAttribIPointer(e413, n289, r132, a69, o62);
    }
    function x8() {
        b8(), c37 = !0, h47 !== l53 && (h47 = l53, u36(h47.object));
    }
    function b8() {
        l53.geometry = null, l53.program = null, l53.wireframe = !1;
    }
    return {
        setup: function(r133, l54, d32, x9, b9) {
            let _7 = !1;
            if (a67) {
                const e414 = function(e416, n290, r134) {
                    const a70 = !0 === r134.wireframe;
                    let l55 = o60[e416.id];
                    void 0 === l55 && (l55 = {}, o60[e416.id] = l55);
                    let h48 = l55[n290.id];
                    void 0 === h48 && (h48 = {}, l55[n290.id] = h48);
                    let c38 = h48[a70];
                    void 0 === c38 && (c38 = p29(i182.isWebGL2 ? t138.createVertexArray() : s85.createVertexArrayOES()), h48[a70] = c38);
                    return c38;
                }(x9, d32, l54);
                h47 !== e414 && (h47 = e414, u36(h47.object)), _7 = function(t, e418) {
                    const n291 = h47.attributes, i185 = t.attributes;
                    let r135 = 0;
                    for(const t139 in i185){
                        const e417 = n291[t139], s88 = i185[t139];
                        if (void 0 === e417) return !0;
                        if (e417.attribute !== s88) return !0;
                        if (e417.data !== s88.data) return !0;
                        r135++;
                    }
                    return h47.attributesNum !== r135 || h47.index !== e418;
                }(x9, b9), _7 && function(t, e420) {
                    const n292 = {}, i186 = t.attributes;
                    let r136 = 0;
                    for(const t140 in i186){
                        const e419 = i186[t140], s89 = {};
                        s89.attribute = e419, e419.data && (s89.data = e419.data), n292[t140] = s89, r136++;
                    }
                    h47.attributes = n292, h47.attributesNum = r136, h47.index = e420;
                }(x9, b9);
            } else {
                const t = !0 === l54.wireframe;
                h47.geometry === x9.id && h47.program === d32.id && h47.wireframe === t || (h47.geometry = x9.id, h47.program = d32.id, h47.wireframe = t, _7 = !0);
            }
            !0 === r133.isInstancedMesh && (_7 = !0), null !== b9 && n284.update(b9, 34963), (_7 || c37) && (c37 = !1, function(r137, s90, a71, o63) {
                if (!1 === i182.isWebGL2 && (r137.isInstancedMesh || o63.isInstancedBufferGeometry) && null === e407.get("ANGLE_instanced_arrays")) return;
                m18();
                const l56 = o63.attributes, h49 = a71.getAttributes(), c40 = s90.defaultAttributeValues;
                for(const e421 in h49){
                    const i187 = h49[e421];
                    if (i187.location >= 0) {
                        let s91 = l56[e421];
                        if (void 0 === s91 && ("instanceMatrix" === e421 && r137.instanceMatrix && (s91 = r137.instanceMatrix), "instanceColor" === e421 && r137.instanceColor && (s91 = r137.instanceColor)), void 0 !== s91) {
                            const e422 = s91.normalized, a72 = s91.itemSize, l57 = n284.get(s91);
                            if (void 0 === l57) continue;
                            const h50 = l57.buffer, c39 = l57.type, u37 = l57.bytesPerElement;
                            if (s91.isInterleavedBufferAttribute) {
                                const n293 = s91.data, l58 = n293.stride, d33 = s91.offset;
                                if (n293.isInstancedInterleavedBuffer) {
                                    for(let t = 0; t < i187.locationSize; t++)g11(i187.location + t, n293.meshPerAttribute);
                                    !0 !== r137.isInstancedMesh && void 0 === o63._maxInstanceCount && (o63._maxInstanceCount = n293.meshPerAttribute * n293.count);
                                } else for(let t = 0; t < i187.locationSize; t++)f13(i187.location + t);
                                t138.bindBuffer(34962, h50);
                                for(let t141 = 0; t141 < i187.locationSize; t141++)y9(i187.location + t141, a72 / i187.locationSize, c39, e422, l58 * u37, (d33 + a72 / i187.locationSize * t141) * u37);
                            } else {
                                if (s91.isInstancedBufferAttribute) {
                                    for(let t = 0; t < i187.locationSize; t++)g11(i187.location + t, s91.meshPerAttribute);
                                    !0 !== r137.isInstancedMesh && void 0 === o63._maxInstanceCount && (o63._maxInstanceCount = s91.meshPerAttribute * s91.count);
                                } else for(let t = 0; t < i187.locationSize; t++)f13(i187.location + t);
                                t138.bindBuffer(34962, h50);
                                for(let t142 = 0; t142 < i187.locationSize; t142++)y9(i187.location + t142, a72 / i187.locationSize, c39, e422, a72 * u37, a72 / i187.locationSize * t142 * u37);
                            }
                        } else if (void 0 !== c40) {
                            const n294 = c40[e421];
                            if (void 0 !== n294) switch(n294.length){
                                case 2:
                                    t138.vertexAttrib2fv(i187.location, n294);
                                    break;
                                case 3:
                                    t138.vertexAttrib3fv(i187.location, n294);
                                    break;
                                case 4:
                                    t138.vertexAttrib4fv(i187.location, n294);
                                    break;
                                default:
                                    t138.vertexAttrib1fv(i187.location, n294);
                            }
                        }
                    }
                }
                v10();
            }(r133, l54, d32, x9), null !== b9 && t138.bindBuffer(34963, n284.get(b9).buffer));
        },
        reset: x8,
        resetDefaultState: b8,
        dispose: function() {
            x8();
            for(const t in o60){
                const e423 = o60[t];
                for(const t143 in e423){
                    const n295 = e423[t143];
                    for(const t in n295)d31(n295[t].object), delete n295[t];
                    delete e423[t143];
                }
                delete o60[t];
            }
        },
        releaseStatesOfGeometry: function(t) {
            if (void 0 === o60[t.id]) return;
            const e424 = o60[t.id];
            for(const t144 in e424){
                const n296 = e424[t144];
                for(const t in n296)d31(n296[t].object), delete n296[t];
                delete e424[t144];
            }
            delete o60[t.id];
        },
        releaseStatesOfProgram: function(t) {
            for(const e425 in o60){
                const n297 = o60[e425];
                if (void 0 === n297[t.id]) continue;
                const i188 = n297[t.id];
                for(const t145 in i188)d31(i188[t145].object), delete i188[t145];
                delete n297[t.id];
            }
        },
        initAttributes: m18,
        enableAttribute: f13,
        disableUnusedAttributes: v10
    };
}
function cn(t146, e426, n298, i189) {
    const r138 = i189.isWebGL2;
    let s92;
    this.setMode = function(t) {
        s92 = t;
    }, this.render = function(e427, i190) {
        t146.drawArrays(s92, e427, i190), n298.update(i190, s92, 1);
    }, this.renderInstances = function(i191, a73, o64) {
        if (0 === o64) return;
        let l59, h51;
        if (r138) l59 = t146, h51 = "drawArraysInstanced";
        else if (l59 = e426.get("ANGLE_instanced_arrays"), h51 = "drawArraysInstancedANGLE", null === l59) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        l59[h51](s92, i191, a73, o64), n298.update(a73, s92, o64);
    };
}
function un(t, e428, n299) {
    let i192;
    function r139(e429) {
        if ("highp" === e429) {
            if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
            e429 = "mediump";
        }
        return "mediump" === e429 && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
    }
    const s93 = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
    let a74 = void 0 !== n299.precision ? n299.precision : "highp";
    const o65 = r139(a74);
    o65 !== a74 && (console.warn("THREE.WebGLRenderer:", a74, "not supported, using", o65, "instead."), a74 = o65);
    const l60 = s93 || e428.has("WEBGL_draw_buffers"), h52 = !0 === n299.logarithmicDepthBuffer, c41 = t.getParameter(34930), u38 = t.getParameter(35660), d34 = t.getParameter(3379), p30 = t.getParameter(34076), m19 = t.getParameter(34921), f14 = t.getParameter(36347), g12 = t.getParameter(36348), v11 = t.getParameter(36349), y10 = u38 > 0, x10 = s93 || e428.has("OES_texture_float");
    return {
        isWebGL2: s93,
        drawBuffers: l60,
        getMaxAnisotropy: function() {
            if (void 0 !== i192) return i192;
            if (!0 === e428.has("EXT_texture_filter_anisotropic")) {
                const n300 = e428.get("EXT_texture_filter_anisotropic");
                i192 = t.getParameter(n300.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else i192 = 0;
            return i192;
        },
        getMaxPrecision: r139,
        precision: a74,
        logarithmicDepthBuffer: h52,
        maxTextures: c41,
        maxVertexTextures: u38,
        maxTextureSize: d34,
        maxCubemapSize: p30,
        maxAttributes: m19,
        maxVertexUniforms: f14,
        maxVaryings: g12,
        maxFragmentUniforms: v11,
        vertexTextures: y10,
        floatFragmentTextures: x10,
        floatVertexTextures: y10 && x10,
        maxSamples: s93 ? t.getParameter(36183) : 0
    };
}
function dn(t147) {
    const e430 = this;
    let n301 = null, i193 = 0, r140 = !1, s94 = !1;
    const a75 = new Ke, o66 = new v, l61 = {
        value: null,
        needsUpdate: !1
    };
    function h53() {
        l61.value !== n301 && (l61.value = n301, l61.needsUpdate = i193 > 0), e430.numPlanes = i193, e430.numIntersection = 0;
    }
    function c42(t, n304, i194, r141) {
        const s95 = null !== t ? t.length : 0;
        let h54 = null;
        if (0 !== s95) {
            if (h54 = l61.value, !0 !== r141 || null === h54) {
                const e432 = i194 + 4 * s95, r142 = n304.matrixWorldInverse;
                o66.getNormalMatrix(r142), (null === h54 || h54.length < e432) && (h54 = new Float32Array(e432));
                for(let e431 = 0, n302 = i194; e431 !== s95; ++e431, n302 += 4)a75.copy(t[e431]).applyMatrix4(r142, o66), a75.normal.toArray(h54, n302), h54[n302 + 3] = a75.constant;
            }
            l61.value = h54, l61.needsUpdate = !0;
        }
        return e430.numPlanes = s95, e430.numIntersection = 0, h54;
    }
    this.uniform = l61, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e433, s96) {
        const a76 = 0 !== t.length || e433 || 0 !== i193 || r140;
        return r140 = e433, n301 = c42(t, s96, 0), i193 = t.length, a76;
    }, this.beginShadows = function() {
        s94 = !0, c42(null);
    }, this.endShadows = function() {
        s94 = !1, h53();
    }, this.setState = function(e434, a77, o67) {
        const u39 = e434.clippingPlanes, d35 = e434.clipIntersection, p31 = e434.clipShadows, m20 = t147.get(e434);
        if (!r140 || null === u39 || 0 === u39.length || s94 && !p31) s94 ? c42(null) : h53();
        else {
            const t = s94 ? 0 : i193, e435 = 4 * t;
            let r143 = m20.clippingState || null;
            l61.value = r143, r143 = c42(u39, a77, e435, o67);
            for(let t148 = 0; t148 !== e435; ++t148)r143[t148] = n301[t148];
            m20.clippingState = r143, this.numIntersection = d35 ? this.numPlanes : 0, this.numPlanes += t;
        }
    };
}
function pn(t149) {
    let e436 = new WeakMap;
    function n305(t, e437) {
        return 303 === e437 ? t.mapping = 301 : 304 === e437 && (t.mapping = 302), t;
    }
    function i195(t) {
        const n306 = t.target;
        n306.removeEventListener("dispose", i195);
        const r144 = e436.get(n306);
        void 0 !== r144 && (e436.delete(n306), r144.dispose());
    }
    return {
        get: function(r145) {
            if (r145 && r145.isTexture && !1 === r145.isRenderTargetTexture) {
                const s97 = r145.mapping;
                if (303 === s97 || 304 === s97) {
                    if (e436.has(r145)) return n305(e436.get(r145).texture, r145.mapping);
                    {
                        const s98 = r145.image;
                        if (s98 && s98.height > 0) {
                            const a78 = new Xe(s98.height / 2);
                            return a78.fromEquirectangularTexture(t149, r145), e436.set(r145, a78), r145.addEventListener("dispose", i195), n305(a78.texture, r145.mapping);
                        }
                        return null;
                    }
                }
            }
            return r145;
        },
        dispose: function() {
            e436 = new WeakMap;
        }
    };
}
on.physical = {
    uniforms: ze([
        on.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new g(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: 0
            },
            sheenColor: {
                value: new L(0)
            },
            sheenColorMap: {
                value: null
            },
            sheenRoughness: {
                value: 1
            },
            sheenRoughnessMap: {
                value: null
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            },
            transmissionSamplerSize: {
                value: new g
            },
            transmissionSamplerMap: {
                value: null
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 0
            },
            attenuationColor: {
                value: new L(0)
            },
            specularIntensity: {
                value: 1
            },
            specularIntensityMap: {
                value: null
            },
            specularColor: {
                value: new L(1, 1, 1)
            },
            specularColorMap: {
                value: null
            }
        }
    ]),
    vertexShader: sn.meshphysical_vert,
    fragmentShader: sn.meshphysical_frag
};
class mn extends Ge {
    constructor(t = -1, e438 = 1, n307 = 1, i196 = -1, r146 = .1, s99 = 2e3){
        super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e438, this.top = n307, this.bottom = i196, this.near = r146, this.far = s99, this.updateProjectionMatrix();
    }
    copy(t, e439) {
        return super.copy(t, e439), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this;
    }
    setViewOffset(t, e440, n308, i197, r147, s100) {
        null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e440, this.view.offsetX = n308, this.view.offsetY = i197, this.view.width = r147, this.view.height = s100, this.updateProjectionMatrix();
    }
    clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom), e441 = (this.top - this.bottom) / (2 * this.zoom), n309 = (this.right + this.left) / 2, i198 = (this.top + this.bottom) / 2;
        let r148 = n309 - t, s101 = n309 + t, a79 = i198 + e441, o68 = i198 - e441;
        if (null !== this.view && this.view.enabled) {
            const t = (this.right - this.left) / this.view.fullWidth / this.zoom, e442 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r148 += t * this.view.offsetX, s101 = r148 + t * this.view.width, a79 -= e442 * this.view.offsetY, o68 = a79 - e442 * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(r148, s101, a79, o68, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
        const e443 = super.toJSON(t);
        return e443.object.zoom = this.zoom, e443.object.left = this.left, e443.object.right = this.right, e443.object.top = this.top, e443.object.bottom = this.bottom, e443.object.near = this.near, e443.object.far = this.far, null !== this.view && (e443.object.view = Object.assign({}, this.view)), e443;
    }
}
mn.prototype.isOrthographicCamera = !0;
const fn = [
    .125,
    .215,
    .35,
    .446,
    .526,
    .582
], gn = new mn, vn = new L;
let yn = null;
const xn = (1 + Math.sqrt(5)) / 2, bn = 1 / xn, _n = [
    new V(1, 1, 1),
    new V(-1, 1, 1),
    new V(1, 1, -1),
    new V(-1, 1, -1),
    new V(0, xn, bn),
    new V(0, xn, -bn),
    new V(bn, 0, xn),
    new V(-bn, 0, xn),
    new V(xn, bn, 0),
    new V(-xn, bn, 0)
];
class wn {
    constructor(t){
        this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(t, e444 = 0, n310 = .1, i199 = 100) {
        yn = this._renderer.getRenderTarget(), this._setSize(256);
        const r149 = this._allocateTargets();
        return r149.depthBuffer = !0, this._sceneToCubeUV(t, n310, i199, r149), e444 > 0 && this._blur(r149, 0, 0, e444), this._applyPMREM(r149), this._cleanup(r149), r149;
    }
    fromEquirectangular(t, e445 = null) {
        return this._fromTexture(t, e445);
    }
    fromCubemap(t, e446 = null) {
        return this._fromTexture(t, e446);
    }
    compileCubemapShader() {
        null === this._cubemapMaterial && (this._cubemapMaterial = En(), this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
        null === this._equirectMaterial && (this._equirectMaterial = Tn(), this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
        this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose();
    }
    _setSize(t) {
        this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax);
    }
    _dispose() {
        null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
        for(let t = 0; t < this._lodPlanes.length; t++)this._lodPlanes[t].dispose();
    }
    _cleanup(t) {
        this._renderer.setRenderTarget(yn), t.scissorTest = !1, Sn(t, 0, 0, t.width, t.height);
    }
    _fromTexture(t, e447) {
        301 === t.mapping || 302 === t.mapping ? this._setSize(0 === t.image.length ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), yn = this._renderer.getRenderTarget();
        const n311 = e447 || this._allocateTargets();
        return this._textureToCubeUV(t, n311), this._applyPMREM(n311), this._cleanup(n311), n311;
    }
    _allocateTargets() {
        const t150 = 3 * Math.max(this._cubeSize, 112), e448 = 4 * this._cubeSize - 32, n312 = {
            magFilter: 1006,
            minFilter: 1006,
            generateMipmaps: !1,
            type: 1016,
            format: 1023,
            encoding: 3e3,
            depthBuffer: !1
        }, i202 = Mn(t150, e448, n312);
        if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== t150) {
            null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Mn(t150, e448, n312);
            const { _lodMax: i200  } = this;
            ({ sizeLods: this._sizeLods , lodPlanes: this._lodPlanes , sigmas: this._sigmas  } = function(t) {
                const e450 = [], n313 = [], i201 = [];
                let r150 = t;
                const s102 = t - 4 + 1 + fn.length;
                for(let a80 = 0; a80 < s102; a80++){
                    const s103 = Math.pow(2, r150);
                    n313.push(s103);
                    let o69 = 1 / s103;
                    a80 > t - 4 ? o69 = fn[a80 - t + 4 - 1] : 0 === a80 && (o69 = 0), i201.push(o69);
                    const l62 = 1 / (s103 - 1), h55 = -l62 / 2, c43 = 1 + l62 / 2, u40 = [
                        h55,
                        h55,
                        c43,
                        h55,
                        c43,
                        c43,
                        h55,
                        h55,
                        c43,
                        c43,
                        h55,
                        c43
                    ], d36 = 6, p32 = 6, m21 = 3, f15 = 2, g13 = 1, v12 = new Float32Array(m21 * p32 * d36), y11 = new Float32Array(f15 * p32 * d36), x11 = new Float32Array(g13 * p32 * d36);
                    for(let t151 = 0; t151 < d36; t151++){
                        const e449 = t151 % 3 * 2 / 3 - 1, n314 = t151 > 2 ? 0 : -1, i203 = [
                            e449,
                            n314,
                            0,
                            e449 + 2 / 3,
                            n314,
                            0,
                            e449 + 2 / 3,
                            n314 + 1,
                            0,
                            e449,
                            n314,
                            0,
                            e449 + 2 / 3,
                            n314 + 1,
                            0,
                            e449,
                            n314 + 1,
                            0
                        ];
                        v12.set(i203, m21 * p32 * t151), y11.set(u40, f15 * p32 * t151);
                        const r151 = [
                            t151,
                            t151,
                            t151,
                            t151,
                            t151,
                            t151
                        ];
                        x11.set(r151, g13 * p32 * t151);
                    }
                    const b10 = new ye;
                    b10.setAttribute("position", new oe(v12, m21)), b10.setAttribute("uv", new oe(y11, f15)), b10.setAttribute("faceIndex", new oe(x11, g13)), e450.push(b10), r150 > 4 && r150--;
                }
                return {
                    lodPlanes: e450,
                    sizeLods: n313,
                    sigmas: i201
                };
            }(i200)), this._blurMaterial = function(t, e451, n315) {
                const i204 = new Float32Array(20), r152 = new V(0, 1, 0);
                return new Ve({
                    name: "SphericalGaussianBlur",
                    defines: {
                        n: 20,
                        CUBEUV_TEXEL_WIDTH: 1 / e451,
                        CUBEUV_TEXEL_HEIGHT: 1 / n315,
                        CUBEUV_MAX_MIP: `${t}.0`
                    },
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        samples: {
                            value: 1
                        },
                        weights: {
                            value: i204
                        },
                        latitudinal: {
                            value: !1
                        },
                        dTheta: {
                            value: 0
                        },
                        mipInt: {
                            value: 0
                        },
                        poleAxis: {
                            value: r152
                        }
                    },
                    vertexShader: An(),
                    fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                });
            }(i200, t150, e448);
        }
        return i202;
    }
    _compileMaterial(t) {
        const e452 = new Fe(this._lodPlanes[0], t);
        this._renderer.compile(e452, gn);
    }
    _sceneToCubeUV(t, e454, n316, i205) {
        const r153 = new We(90, 1, e454, n316), s104 = [
            1,
            -1,
            1,
            1,
            1,
            1
        ], a81 = [
            1,
            1,
            1,
            -1,
            -1,
            -1
        ], o70 = this._renderer, l64 = o70.autoClear, h56 = o70.toneMapping;
        o70.getClearColor(vn), o70.toneMapping = 0, o70.autoClear = !1;
        const c44 = new re({
            name: "PMREM.Background",
            side: 1,
            depthWrite: !1,
            depthTest: !1
        }), u41 = new Fe(new ke, c44);
        let d37 = !1;
        const p33 = t.background;
        p33 ? p33.isColor && (c44.color.copy(p33), t.background = null, d37 = !0) : (c44.color.copy(vn), d37 = !0);
        for(let e453 = 0; e453 < 6; e453++){
            const n317 = e453 % 3;
            0 === n317 ? (r153.up.set(0, s104[e453], 0), r153.lookAt(a81[e453], 0, 0)) : 1 === n317 ? (r153.up.set(0, 0, s104[e453]), r153.lookAt(0, a81[e453], 0)) : (r153.up.set(0, s104[e453], 0), r153.lookAt(0, 0, a81[e453]));
            const l63 = this._cubeSize;
            Sn(i205, n317 * l63, e453 > 2 ? l63 : 0, l63, l63), o70.setRenderTarget(i205), d37 && o70.render(u41, r153), o70.render(t, r153);
        }
        u41.geometry.dispose(), u41.material.dispose(), o70.toneMapping = h56, o70.autoClear = l64, t.background = p33;
    }
    _textureToCubeUV(t, e455) {
        const n318 = this._renderer, i206 = 301 === t.mapping || 302 === t.mapping;
        i206 ? (null === this._cubemapMaterial && (this._cubemapMaterial = En()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Tn());
        const r154 = i206 ? this._cubemapMaterial : this._equirectMaterial, s105 = new Fe(this._lodPlanes[0], r154);
        r154.uniforms.envMap.value = t;
        const a82 = this._cubeSize;
        Sn(e455, 0, 0, 3 * a82, 2 * a82), n318.setRenderTarget(e455), n318.render(s105, gn);
    }
    _applyPMREM(t) {
        const e457 = this._renderer, n320 = e457.autoClear;
        e457.autoClear = !1;
        for(let e456 = 1; e456 < this._lodPlanes.length; e456++){
            const n319 = Math.sqrt(this._sigmas[e456] * this._sigmas[e456] - this._sigmas[e456 - 1] * this._sigmas[e456 - 1]), i207 = _n[(e456 - 1) % _n.length];
            this._blur(t, e456 - 1, e456, n319, i207);
        }
        e457.autoClear = n320;
    }
    _blur(t, e458, n321, i208, r155) {
        const s106 = this._pingPongRenderTarget;
        this._halfBlur(t, s106, e458, n321, i208, "latitudinal", r155), this._halfBlur(s106, t, n321, n321, i208, "longitudinal", r155);
    }
    _halfBlur(t, e460, n322, i209, r156, s107, a83) {
        const o71 = this._renderer, l65 = this._blurMaterial;
        "latitudinal" !== s107 && "longitudinal" !== s107 && console.error("blur direction must be either latitudinal or longitudinal!");
        const h57 = new Fe(this._lodPlanes[i209], l65), c45 = l65.uniforms, u42 = this._sizeLods[n322] - 1, d38 = isFinite(r156) ? Math.PI / (2 * u42) : 2 * Math.PI / 39, p34 = r156 / d38, m22 = isFinite(r156) ? 1 + Math.floor(3 * p34) : 20;
        m22 > 20 && console.warn(`sigmaRadians, ${r156}, is too large and will clip, as it requested ${m22} samples when the maximum is set to 20`);
        const f16 = [];
        let g14 = 0;
        for(let t152 = 0; t152 < 20; ++t152){
            const e459 = t152 / p34, n323 = Math.exp(-e459 * e459 / 2);
            f16.push(n323), 0 === t152 ? g14 += n323 : t152 < m22 && (g14 += 2 * n323);
        }
        for(let t153 = 0; t153 < f16.length; t153++)f16[t153] = f16[t153] / g14;
        c45.envMap.value = t.texture, c45.samples.value = m22, c45.weights.value = f16, c45.latitudinal.value = "latitudinal" === s107, a83 && (c45.poleAxis.value = a83);
        const { _lodMax: v13  } = this;
        c45.dTheta.value = d38, c45.mipInt.value = v13 - n322;
        const y12 = this._sizeLods[i209];
        Sn(e460, 3 * y12 * (i209 > v13 - 4 ? i209 - v13 + 4 : 0), 4 * (this._cubeSize - y12), 3 * y12, 2 * y12), o71.setRenderTarget(e460), o71.render(h57, gn);
    }
}
function Mn(t, e461, n324) {
    const i210 = new k(t, e461, n324);
    return i210.texture.mapping = 306, i210.texture.name = "PMREM.cubeUv", i210.scissorTest = !0, i210;
}
function Sn(t, e462, n325, i211, r157) {
    t.viewport.set(e462, n325, i211, r157), t.scissor.set(e462, n325, i211, r157);
}
function Tn() {
    return new Ve({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: An(),
        fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		",
        blending: 0,
        depthTest: !1,
        depthWrite: !1
    });
}
function En() {
    return new Ve({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: An(),
        fragmentShader: "\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		",
        blending: 0,
        depthTest: !1,
        depthWrite: !1
    });
}
function An() {
    return "\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	";
}
function Rn(t154) {
    let e463 = new WeakMap, n326 = null;
    function i212(t) {
        const n327 = t.target;
        n327.removeEventListener("dispose", i212);
        const r158 = e463.get(n327);
        void 0 !== r158 && (e463.delete(n327), r158.dispose());
    }
    return {
        get: function(r159) {
            if (r159 && r159.isTexture) {
                const s108 = r159.mapping, a84 = 303 === s108 || 304 === s108, o72 = 301 === s108 || 302 === s108;
                if (a84 || o72) {
                    if (r159.isRenderTargetTexture && !0 === r159.needsPMREMUpdate) {
                        r159.needsPMREMUpdate = !1;
                        let i213 = e463.get(r159);
                        return null === n326 && (n326 = new wn(t154)), i213 = a84 ? n326.fromEquirectangular(r159, i213) : n326.fromCubemap(r159, i213), e463.set(r159, i213), i213.texture;
                    }
                    if (e463.has(r159)) return e463.get(r159).texture;
                    {
                        const s109 = r159.image;
                        if (a84 && s109 && s109.height > 0 || o72 && s109 && function(t) {
                            let e464 = 0;
                            const n328 = 6;
                            for(let i214 = 0; i214 < n328; i214++)void 0 !== t[i214] && e464++;
                            return e464 === n328;
                        }(s109)) {
                            null === n326 && (n326 = new wn(t154));
                            const s110 = a84 ? n326.fromEquirectangular(r159) : n326.fromCubemap(r159);
                            return e463.set(r159, s110), r159.addEventListener("dispose", i212), s110.texture;
                        }
                        return null;
                    }
                }
            }
            return r159;
        },
        dispose: function() {
            e463 = new WeakMap, null !== n326 && (n326.dispose(), n326 = null);
        }
    };
}
function Cn(t155) {
    const e465 = {};
    function n329(n330) {
        if (void 0 !== e465[n330]) return e465[n330];
        let i215;
        switch(n330){
            case "WEBGL_depth_texture":
                i215 = t155.getExtension("WEBGL_depth_texture") || t155.getExtension("MOZ_WEBGL_depth_texture") || t155.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                i215 = t155.getExtension("EXT_texture_filter_anisotropic") || t155.getExtension("MOZ_EXT_texture_filter_anisotropic") || t155.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                i215 = t155.getExtension("WEBGL_compressed_texture_s3tc") || t155.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t155.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                i215 = t155.getExtension("WEBGL_compressed_texture_pvrtc") || t155.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                i215 = t155.getExtension(n330);
        }
        return e465[n330] = i215, i215;
    }
    return {
        has: function(t) {
            return null !== n329(t);
        },
        init: function(t) {
            t.isWebGL2 ? n329("EXT_color_buffer_float") : (n329("WEBGL_depth_texture"), n329("OES_texture_float"), n329("OES_texture_half_float"), n329("OES_texture_half_float_linear"), n329("OES_standard_derivatives"), n329("OES_element_index_uint"), n329("OES_vertex_array_object"), n329("ANGLE_instanced_arrays")), n329("OES_texture_float_linear"), n329("EXT_color_buffer_half_float"), n329("WEBGL_multisampled_render_to_texture");
        },
        get: function(t) {
            const e466 = n329(t);
            return null === e466 && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e466;
        }
    };
}
function Ln(t157, e467, n331, i216) {
    const r160 = {}, s111 = new WeakMap;
    function a85(t) {
        const o74 = t.target;
        null !== o74.index && e467.remove(o74.index);
        for(const t156 in o74.attributes)e467.remove(o74.attributes[t156]);
        o74.removeEventListener("dispose", a85), delete r160[o74.id];
        const l66 = s111.get(o74);
        l66 && (e467.remove(l66), s111.delete(o74)), i216.releaseStatesOfGeometry(o74), !0 === o74.isInstancedBufferGeometry && delete o74._maxInstanceCount, n331.memory.geometries--;
    }
    function o73(t) {
        const n332 = [], i217 = t.index, r162 = t.attributes.position;
        let a86 = 0;
        if (null !== i217) {
            const t = i217.array;
            a86 = i217.version;
            for(let e468 = 0, i218 = t.length; e468 < i218; e468 += 3){
                const i219 = t[e468 + 0], r161 = t[e468 + 1], s112 = t[e468 + 2];
                n332.push(i219, r161, r161, s112, s112, i219);
            }
        } else {
            const t = r162.array;
            a86 = r162.version;
            for(let e469 = 0, i220 = t.length / 3 - 1; e469 < i220; e469 += 3){
                const t = e469 + 0, i221 = e469 + 1, r163 = e469 + 2;
                n332.push(t, i221, i221, r163, r163, t);
            }
        }
        const o75 = new (y(n332) ? he : le)(n332, 1);
        o75.version = a86;
        const l67 = s111.get(t);
        l67 && e467.remove(l67), s111.set(t, o75);
    }
    return {
        get: function(t, e470) {
            return !0 === r160[e470.id] || (e470.addEventListener("dispose", a85), r160[e470.id] = !0, n331.memory.geometries++), e470;
        },
        update: function(t) {
            const n333 = t.attributes;
            for(const t158 in n333)e467.update(n333[t158], 34962);
            const i222 = t.morphAttributes;
            for(const t159 in i222){
                const n334 = i222[t159];
                for(let t = 0, i223 = n334.length; t < i223; t++)e467.update(n334[t], 34962);
            }
        },
        getWireframeAttribute: function(t) {
            const e471 = s111.get(t);
            if (e471) {
                const n335 = t.index;
                null !== n335 && e471.version < n335.version && o73(t);
            } else o73(t);
            return s111.get(t);
        }
    };
}
function Pn(t160, e472, n336, i224) {
    const r164 = i224.isWebGL2;
    let s113, a87, o76;
    this.setMode = function(t) {
        s113 = t;
    }, this.setIndex = function(t) {
        a87 = t.type, o76 = t.bytesPerElement;
    }, this.render = function(e473, i225) {
        t160.drawElements(s113, i225, a87, e473 * o76), n336.update(i225, s113, 1);
    }, this.renderInstances = function(i226, l68, h58) {
        if (0 === h58) return;
        let c46, u43;
        if (r164) c46 = t160, u43 = "drawElementsInstanced";
        else if (c46 = e472.get("ANGLE_instanced_arrays"), u43 = "drawElementsInstancedANGLE", null === c46) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        c46[u43](s113, l68, a87, i226 * o76, h58), n336.update(l68, s113, h58);
    };
}
function Dn(t161) {
    const e474 = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    return {
        memory: {
            geometries: 0,
            textures: 0
        },
        render: e474,
        programs: null,
        autoReset: !0,
        reset: function() {
            e474.frame++, e474.calls = 0, e474.triangles = 0, e474.points = 0, e474.lines = 0;
        },
        update: function(t, n337, i227) {
            switch(e474.calls++, n337){
                case 4:
                    e474.triangles += i227 * (t / 3);
                    break;
                case 1:
                    e474.lines += i227 * (t / 2);
                    break;
                case 3:
                    e474.lines += i227 * (t - 1);
                    break;
                case 2:
                    e474.lines += i227 * t;
                    break;
                case 0:
                    e474.points += i227 * t;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", n337);
            }
        }
    };
}
function In(t, e475) {
    return t[0] - e475[0];
}
function On(t, e476) {
    return Math.abs(e476[1]) - Math.abs(t[1]);
}
function Nn(t, e477) {
    let n338 = 1;
    const i228 = e477.isInterleavedBufferAttribute ? e477.data.array : e477.array;
    i228 instanceof Int8Array ? n338 = 127 : i228 instanceof Int16Array ? n338 = 32767 : i228 instanceof Int32Array ? n338 = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i228), t.divideScalar(n338);
}
function Fn(t163, e478, n339) {
    const i229 = {}, r165 = new Float32Array(8), s114 = new WeakMap, a88 = new U, o77 = [];
    for(let t162 = 0; t162 < 8; t162++)o77[t162] = [
        t162,
        0
    ];
    return {
        update: function(l69, h59, c, u45) {
            const d40 = l69.morphTargetInfluences;
            if (!0 === e478.isWebGL2) {
                const i230 = h59.morphAttributes.position || h59.morphAttributes.normal || h59.morphAttributes.color, r166 = void 0 !== i230 ? i230.length : 0;
                let o78 = s114.get(h59);
                if (void 0 === o78 || o78.count !== r166) {
                    void 0 !== o78 && o78.texture.dispose();
                    const t164 = void 0 !== h59.morphAttributes.position, n340 = void 0 !== h59.morphAttributes.normal, i231 = void 0 !== h59.morphAttributes.color, l70 = h59.morphAttributes.position || [], c47 = h59.morphAttributes.normal || [], u44 = h59.morphAttributes.color || [];
                    let d39 = 0;
                    !0 === t164 && (d39 = 1), !0 === n340 && (d39 = 2), !0 === i231 && (d39 = 3);
                    let p35 = h59.attributes.position.count * d39, m23 = 1;
                    p35 > e478.maxTextureSize && (m23 = Math.ceil(p35 / e478.maxTextureSize), p35 = e478.maxTextureSize);
                    const f17 = new Float32Array(p35 * m23 * 4 * r166), v14 = new B(f17, p35, m23, r166);
                    v14.type = 1015, v14.needsUpdate = !0;
                    const y13 = 4 * d39;
                    for(let e479 = 0; e479 < r166; e479++){
                        const r167 = l70[e479], s115 = c47[e479], o79 = u44[e479], h60 = p35 * m23 * 4 * e479;
                        for(let e480 = 0; e480 < r167.count; e480++){
                            const l71 = e480 * y13;
                            !0 === t164 && (a88.fromBufferAttribute(r167, e480), !0 === r167.normalized && Nn(a88, r167), f17[h60 + l71 + 0] = a88.x, f17[h60 + l71 + 1] = a88.y, f17[h60 + l71 + 2] = a88.z, f17[h60 + l71 + 3] = 0), !0 === n340 && (a88.fromBufferAttribute(s115, e480), !0 === s115.normalized && Nn(a88, s115), f17[h60 + l71 + 4] = a88.x, f17[h60 + l71 + 5] = a88.y, f17[h60 + l71 + 6] = a88.z, f17[h60 + l71 + 7] = 0), !0 === i231 && (a88.fromBufferAttribute(o79, e480), !0 === o79.normalized && Nn(a88, o79), f17[h60 + l71 + 8] = a88.x, f17[h60 + l71 + 9] = a88.y, f17[h60 + l71 + 10] = a88.z, f17[h60 + l71 + 11] = 4 === o79.itemSize ? a88.w : 1);
                        }
                    }
                    o78 = {
                        count: r166,
                        texture: v14,
                        size: new g(p35, m23)
                    }, s114.set(h59, o78), h59.addEventListener("dispose", function t() {
                        v14.dispose(), s114.delete(h59), h59.removeEventListener("dispose", t);
                    });
                }
                let l72 = 0;
                for(let t = 0; t < d40.length; t++)l72 += d40[t];
                const c48 = h59.morphTargetsRelative ? 1 : 1 - l72;
                u45.getUniforms().setValue(t163, "morphTargetBaseInfluence", c48), u45.getUniforms().setValue(t163, "morphTargetInfluences", d40), u45.getUniforms().setValue(t163, "morphTargetsTexture", o78.texture, n339), u45.getUniforms().setValue(t163, "morphTargetsTextureSize", o78.size);
            } else {
                const e481 = void 0 === d40 ? 0 : d40.length;
                let n341 = i229[h59.id];
                if (void 0 === n341 || n341.length !== e481) {
                    n341 = [];
                    for(let t = 0; t < e481; t++)n341[t] = [
                        t,
                        0
                    ];
                    i229[h59.id] = n341;
                }
                for(let t = 0; t < e481; t++){
                    const e482 = n341[t];
                    e482[0] = t, e482[1] = d40[t];
                }
                n341.sort(On);
                for(let t165 = 0; t165 < 8; t165++)t165 < e481 && n341[t165][1] ? (o77[t165][0] = n341[t165][0], o77[t165][1] = n341[t165][1]) : (o77[t165][0] = Number.MAX_SAFE_INTEGER, o77[t165][1] = 0);
                o77.sort(In);
                const s116 = h59.morphAttributes.position, a89 = h59.morphAttributes.normal;
                let l73 = 0;
                for(let t166 = 0; t166 < 8; t166++){
                    const e483 = o77[t166], n342 = e483[0], i232 = e483[1];
                    n342 !== Number.MAX_SAFE_INTEGER && i232 ? (s116 && h59.getAttribute("morphTarget" + t166) !== s116[n342] && h59.setAttribute("morphTarget" + t166, s116[n342]), a89 && h59.getAttribute("morphNormal" + t166) !== a89[n342] && h59.setAttribute("morphNormal" + t166, a89[n342]), r165[t166] = i232, l73 += i232) : (s116 && !0 === h59.hasAttribute("morphTarget" + t166) && h59.deleteAttribute("morphTarget" + t166), a89 && !0 === h59.hasAttribute("morphNormal" + t166) && h59.deleteAttribute("morphNormal" + t166), r165[t166] = 0);
                }
                const c49 = h59.morphTargetsRelative ? 1 : 1 - l73;
                u45.getUniforms().setValue(t163, "morphTargetBaseInfluence", c49), u45.getUniforms().setValue(t163, "morphTargetInfluences", r165);
            }
        }
    };
}
function Un(t167, e484, n343, i233) {
    let r168 = new WeakMap;
    function s117(t) {
        const e485 = t.target;
        e485.removeEventListener("dispose", s117), n343.remove(e485.instanceMatrix), null !== e485.instanceColor && n343.remove(e485.instanceColor);
    }
    return {
        update: function(t) {
            const a90 = i233.render.frame, o80 = t.geometry, l74 = e484.get(t, o80);
            return r168.get(l74) !== a90 && (e484.update(l74), r168.set(l74, a90)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s117) && t.addEventListener("dispose", s117), n343.update(t.instanceMatrix, 34962), null !== t.instanceColor && n343.update(t.instanceColor, 34962)), l74;
        },
        dispose: function() {
            r168 = new WeakMap;
        }
    };
}
const kn = new F, Bn = new B, zn = new z, Hn = new qe, Vn = [], Gn = [], Wn = new Float32Array(16), jn = new Float32Array(9), qn = new Float32Array(4);
function Xn(t, e486, n344) {
    const i234 = t[0];
    if (i234 <= 0 || i234 > 0) return t;
    const r169 = e486 * n344;
    let s118 = Vn[r169];
    if (void 0 === s118 && (s118 = new Float32Array(r169), Vn[r169] = s118), 0 !== e486) {
        i234.toArray(s118, 0);
        for(let i235 = 1, r170 = 0; i235 !== e486; ++i235)r170 += n344, t[i235].toArray(s118, r170);
    }
    return s118;
}
function $n(t, e487) {
    if (t.length !== e487.length) return !1;
    for(let n345 = 0, i236 = t.length; n345 < i236; n345++)if (t[n345] !== e487[n345]) return !1;
    return !0;
}
function Yn(t, e488) {
    for(let n346 = 0, i237 = e488.length; n346 < i237; n346++)t[n346] = e488[n346];
}
function Jn(t, e489) {
    let n347 = Gn[e489];
    void 0 === n347 && (n347 = new Int32Array(e489), Gn[e489] = n347);
    for(let i238 = 0; i238 !== e489; ++i238)n347[i238] = t.allocateTextureUnit();
    return n347;
}
function Kn(t, e490) {
    const n348 = this.cache;
    n348[0] !== e490 && (t.uniform1f(this.addr, e490), n348[0] = e490);
}
function Zn(t, e491) {
    const n349 = this.cache;
    if (void 0 !== e491.x) n349[0] === e491.x && n349[1] === e491.y || (t.uniform2f(this.addr, e491.x, e491.y), n349[0] = e491.x, n349[1] = e491.y);
    else {
        if ($n(n349, e491)) return;
        t.uniform2fv(this.addr, e491), Yn(n349, e491);
    }
}
function Qn(t, e492) {
    const n350 = this.cache;
    if (void 0 !== e492.x) n350[0] === e492.x && n350[1] === e492.y && n350[2] === e492.z || (t.uniform3f(this.addr, e492.x, e492.y, e492.z), n350[0] = e492.x, n350[1] = e492.y, n350[2] = e492.z);
    else if (void 0 !== e492.r) n350[0] === e492.r && n350[1] === e492.g && n350[2] === e492.b || (t.uniform3f(this.addr, e492.r, e492.g, e492.b), n350[0] = e492.r, n350[1] = e492.g, n350[2] = e492.b);
    else {
        if ($n(n350, e492)) return;
        t.uniform3fv(this.addr, e492), Yn(n350, e492);
    }
}
function ti(t, e493) {
    const n351 = this.cache;
    if (void 0 !== e493.x) n351[0] === e493.x && n351[1] === e493.y && n351[2] === e493.z && n351[3] === e493.w || (t.uniform4f(this.addr, e493.x, e493.y, e493.z, e493.w), n351[0] = e493.x, n351[1] = e493.y, n351[2] = e493.z, n351[3] = e493.w);
    else {
        if ($n(n351, e493)) return;
        t.uniform4fv(this.addr, e493), Yn(n351, e493);
    }
}
function ei(t, e494) {
    const n352 = this.cache, i239 = e494.elements;
    if (void 0 === i239) {
        if ($n(n352, e494)) return;
        t.uniformMatrix2fv(this.addr, !1, e494), Yn(n352, e494);
    } else {
        if ($n(n352, i239)) return;
        qn.set(i239), t.uniformMatrix2fv(this.addr, !1, qn), Yn(n352, i239);
    }
}
function ni(t, e495) {
    const n353 = this.cache, i240 = e495.elements;
    if (void 0 === i240) {
        if ($n(n353, e495)) return;
        t.uniformMatrix3fv(this.addr, !1, e495), Yn(n353, e495);
    } else {
        if ($n(n353, i240)) return;
        jn.set(i240), t.uniformMatrix3fv(this.addr, !1, jn), Yn(n353, i240);
    }
}
function ii(t, e496) {
    const n354 = this.cache, i241 = e496.elements;
    if (void 0 === i241) {
        if ($n(n354, e496)) return;
        t.uniformMatrix4fv(this.addr, !1, e496), Yn(n354, e496);
    } else {
        if ($n(n354, i241)) return;
        Wn.set(i241), t.uniformMatrix4fv(this.addr, !1, Wn), Yn(n354, i241);
    }
}
function ri(t, e497) {
    const n355 = this.cache;
    n355[0] !== e497 && (t.uniform1i(this.addr, e497), n355[0] = e497);
}
function si(t, e498) {
    const n356 = this.cache;
    $n(n356, e498) || (t.uniform2iv(this.addr, e498), Yn(n356, e498));
}
function ai(t, e499) {
    const n357 = this.cache;
    $n(n357, e499) || (t.uniform3iv(this.addr, e499), Yn(n357, e499));
}
function oi(t, e500) {
    const n358 = this.cache;
    $n(n358, e500) || (t.uniform4iv(this.addr, e500), Yn(n358, e500));
}
function li(t, e501) {
    const n359 = this.cache;
    n359[0] !== e501 && (t.uniform1ui(this.addr, e501), n359[0] = e501);
}
function hi(t, e502) {
    const n360 = this.cache;
    $n(n360, e502) || (t.uniform2uiv(this.addr, e502), Yn(n360, e502));
}
function ci(t, e503) {
    const n361 = this.cache;
    $n(n361, e503) || (t.uniform3uiv(this.addr, e503), Yn(n361, e503));
}
function ui(t, e504) {
    const n362 = this.cache;
    $n(n362, e504) || (t.uniform4uiv(this.addr, e504), Yn(n362, e504));
}
function di(t, e505, n363) {
    const i242 = this.cache, r171 = n363.allocateTextureUnit();
    i242[0] !== r171 && (t.uniform1i(this.addr, r171), i242[0] = r171), n363.setTexture2D(e505 || kn, r171);
}
function pi(t, e506, n364) {
    const i243 = this.cache, r172 = n364.allocateTextureUnit();
    i243[0] !== r172 && (t.uniform1i(this.addr, r172), i243[0] = r172), n364.setTexture3D(e506 || zn, r172);
}
function mi(t, e507, n365) {
    const i244 = this.cache, r173 = n365.allocateTextureUnit();
    i244[0] !== r173 && (t.uniform1i(this.addr, r173), i244[0] = r173), n365.setTextureCube(e507 || Hn, r173);
}
function fi(t, e508, n366) {
    const i245 = this.cache, r174 = n366.allocateTextureUnit();
    i245[0] !== r174 && (t.uniform1i(this.addr, r174), i245[0] = r174), n366.setTexture2DArray(e508 || Bn, r174);
}
function gi(t, e509) {
    t.uniform1fv(this.addr, e509);
}
function vi(t, e510) {
    const n367 = Xn(e510, this.size, 2);
    t.uniform2fv(this.addr, n367);
}
function yi(t, e511) {
    const n368 = Xn(e511, this.size, 3);
    t.uniform3fv(this.addr, n368);
}
function xi(t, e512) {
    const n369 = Xn(e512, this.size, 4);
    t.uniform4fv(this.addr, n369);
}
function bi(t, e513) {
    const n370 = Xn(e513, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n370);
}
function _i(t, e514) {
    const n371 = Xn(e514, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n371);
}
function wi(t, e515) {
    const n372 = Xn(e515, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n372);
}
function Mi(t, e516) {
    t.uniform1iv(this.addr, e516);
}
function Si(t, e517) {
    t.uniform2iv(this.addr, e517);
}
function Ti(t, e518) {
    t.uniform3iv(this.addr, e518);
}
function Ei(t, e519) {
    t.uniform4iv(this.addr, e519);
}
function Ai(t, e520) {
    t.uniform1uiv(this.addr, e520);
}
function Ri(t, e521) {
    t.uniform2uiv(this.addr, e521);
}
function Ci(t, e522) {
    t.uniform3uiv(this.addr, e522);
}
function Li(t, e523) {
    t.uniform4uiv(this.addr, e523);
}
function Pi(t, e524, n373) {
    const i246 = e524.length, r175 = Jn(n373, i246);
    t.uniform1iv(this.addr, r175);
    for(let t168 = 0; t168 !== i246; ++t168)n373.setTexture2D(e524[t168] || kn, r175[t168]);
}
function Di(t, e525, n374) {
    const i247 = e525.length, r176 = Jn(n374, i247);
    t.uniform1iv(this.addr, r176);
    for(let t169 = 0; t169 !== i247; ++t169)n374.setTexture3D(e525[t169] || zn, r176[t169]);
}
function Ii(t, e526, n375) {
    const i248 = e526.length, r177 = Jn(n375, i248);
    t.uniform1iv(this.addr, r177);
    for(let t170 = 0; t170 !== i248; ++t170)n375.setTextureCube(e526[t170] || Hn, r177[t170]);
}
function Oi(t, e527, n376) {
    const i249 = e527.length, r178 = Jn(n376, i249);
    t.uniform1iv(this.addr, r178);
    for(let t171 = 0; t171 !== i249; ++t171)n376.setTexture2DArray(e527[t171] || Bn, r178[t171]);
}
function Ni(t172, e528, n377) {
    this.id = t172, this.addr = n377, this.cache = [], this.setValue = function(t) {
        switch(t){
            case 5126:
                return Kn;
            case 35664:
                return Zn;
            case 35665:
                return Qn;
            case 35666:
                return ti;
            case 35674:
                return ei;
            case 35675:
                return ni;
            case 35676:
                return ii;
            case 5124:
            case 35670:
                return ri;
            case 35667:
            case 35671:
                return si;
            case 35668:
            case 35672:
                return ai;
            case 35669:
            case 35673:
                return oi;
            case 5125:
                return li;
            case 36294:
                return hi;
            case 36295:
                return ci;
            case 36296:
                return ui;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return di;
            case 35679:
            case 36299:
            case 36307:
                return pi;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return mi;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return fi;
        }
    }(e528.type);
}
function Fi(t173, e529, n378) {
    this.id = t173, this.addr = n378, this.cache = [], this.size = e529.size, this.setValue = function(t) {
        switch(t){
            case 5126:
                return gi;
            case 35664:
                return vi;
            case 35665:
                return yi;
            case 35666:
                return xi;
            case 35674:
                return bi;
            case 35675:
                return _i;
            case 35676:
                return wi;
            case 5124:
            case 35670:
                return Mi;
            case 35667:
            case 35671:
                return Si;
            case 35668:
            case 35672:
                return Ti;
            case 35669:
            case 35673:
                return Ei;
            case 5125:
                return Ai;
            case 36294:
                return Ri;
            case 36295:
                return Ci;
            case 36296:
                return Li;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Pi;
            case 35679:
            case 36299:
            case 36307:
                return Di;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Ii;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return Oi;
        }
    }(e529.type);
}
function Ui(t) {
    this.id = t, this.seq = [], this.map = {};
}
Fi.prototype.updateCache = function(t) {
    const e530 = this.cache;
    t instanceof Float32Array && e530.length !== t.length && (this.cache = new Float32Array(t.length)), Yn(e530, t);
}, Ui.prototype.setValue = function(t, e531, n379) {
    const i250 = this.seq;
    for(let r179 = 0, s119 = i250.length; r179 !== s119; ++r179){
        const s120 = i250[r179];
        s120.setValue(t, e531[s120.id], n379);
    }
};
const ki = /(\w+)(\])?(\[|\.)?/g;
function Bi(t, e532) {
    t.seq.push(e532), t.map[e532.id] = e532;
}
function zi(t, e533, n380) {
    const i251 = t.name, r180 = i251.length;
    for(ki.lastIndex = 0;;){
        const s121 = ki.exec(i251), a91 = ki.lastIndex;
        let o81 = s121[1];
        const l75 = "]" === s121[2], h61 = s121[3];
        if (l75 && (o81 |= 0), void 0 === h61 || "[" === h61 && a91 + 2 === r180) {
            Bi(n380, void 0 === h61 ? new Ni(o81, t, e533) : new Fi(o81, t, e533));
            break;
        }
        {
            let t = n380.map[o81];
            void 0 === t && (t = new Ui(o81), Bi(n380, t)), n380 = t;
        }
    }
}
function Hi(t, e534) {
    this.seq = [], this.map = {};
    const n381 = t.getProgramParameter(e534, 35718);
    for(let i252 = 0; i252 < n381; ++i252){
        const n382 = t.getActiveUniform(e534, i252);
        zi(n382, t.getUniformLocation(e534, n382.name), this);
    }
}
function Vi(t, e535, n383) {
    const i253 = t.createShader(e535);
    return t.shaderSource(i253, n383), t.compileShader(i253), i253;
}
Hi.prototype.setValue = function(t, e536, n384, i254) {
    const r181 = this.map[e536];
    void 0 !== r181 && r181.setValue(t, n384, i254);
}, Hi.prototype.setOptional = function(t, e537, n385) {
    const i255 = e537[n385];
    void 0 !== i255 && this.setValue(t, n385, i255);
}, Hi.upload = function(t, e538, n386, i256) {
    for(let r182 = 0, s122 = e538.length; r182 !== s122; ++r182){
        const s123 = e538[r182], a92 = n386[s123.id];
        !1 !== a92.needsUpdate && s123.setValue(t, a92.value, i256);
    }
}, Hi.seqWithValue = function(t, e539) {
    const n387 = [];
    for(let i257 = 0, r183 = t.length; i257 !== r183; ++i257){
        const r184 = t[i257];
        r184.id in e539 && n387.push(r184);
    }
    return n387;
};
let Gi = 0;
function Wi(t175, e540, n388) {
    const i258 = t175.getShaderParameter(e540, 35713), r185 = t175.getShaderInfoLog(e540).trim();
    if (i258 && "" === r185) return "";
    const s124 = parseInt(/ERROR: 0:(\d+)/.exec(r185)[1]);
    return n388.toUpperCase() + "\n\n" + r185 + "\n\n" + function(t, e541) {
        const n389 = t.split("\n"), i259 = [], r186 = Math.max(e541 - 6, 0), s125 = Math.min(e541 + 6, n389.length);
        for(let t174 = r186; t174 < s125; t174++)i259.push(t174 + 1 + ": " + n389[t174]);
        return i259.join("\n");
    }(t175.getShaderSource(e540), s124);
}
function ji(t176, e542) {
    const n390 = function(t) {
        switch(t){
            case 3e3:
                return [
                    "Linear",
                    "( value )"
                ];
            case 3001:
                return [
                    "sRGB",
                    "( value )"
                ];
            default:
                return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), [
                    "Linear",
                    "( value )"
                ];
        }
    }(e542);
    return "vec4 " + t176 + "( vec4 value ) { return LinearTo" + n390[0] + n390[1] + "; }";
}
function qi(t, e543) {
    let n391;
    switch(e543){
        case 1:
            n391 = "Linear";
            break;
        case 2:
            n391 = "Reinhard";
            break;
        case 3:
            n391 = "OptimizedCineon";
            break;
        case 4:
            n391 = "ACESFilmic";
            break;
        case 5:
            n391 = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e543), n391 = "Linear";
    }
    return "vec3 " + t + "( vec3 color ) { return " + n391 + "ToneMapping( color ); }";
}
function Xi(t) {
    return "" !== t;
}
function $i(t, e544) {
    return t.replace(/NUM_DIR_LIGHTS/g, e544.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e544.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e544.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e544.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e544.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e544.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e544.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e544.numPointLightShadows);
}
function Yi(t, e545) {
    return t.replace(/NUM_CLIPPING_PLANES/g, e545.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e545.numClippingPlanes - e545.numClipIntersection);
}
const Ji = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ki(t) {
    return t.replace(Ji, Zi);
}
function Zi(t, e546) {
    const n392 = sn[e546];
    if (void 0 === n392) throw new Error("Can not resolve #include <" + e546 + ">");
    return Ki(n392);
}
const Qi = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, tr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function er(t) {
    return t.replace(tr, ir).replace(Qi, nr);
}
function nr(t, e547, n393, i260) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), ir(t, e547, n393, i260);
}
function ir(t, e548, n394, i261) {
    let r187 = "";
    for(let t177 = parseInt(e548); t177 < parseInt(n394); t177++)r187 += i261.replace(/\[\s*i\s*\]/g, "[ " + t177 + " ]").replace(/UNROLLED_LOOP_INDEX/g, t177);
    return r187;
}
function rr(t) {
    let e549 = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
    return "highp" === t.precision ? e549 += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e549 += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e549 += "\n#define LOW_PRECISION"), e549;
}
function sr(t178, e550, n395, i262) {
    const r188 = t178.getContext(), s126 = n395.defines;
    let a93 = n395.vertexShader, o82 = n395.fragmentShader;
    const l76 = function(t) {
        let e551 = "SHADOWMAP_TYPE_BASIC";
        return 1 === t.shadowMapType ? e551 = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e551 = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e551 = "SHADOWMAP_TYPE_VSM"), e551;
    }(n395), h62 = function(t) {
        let e552 = "ENVMAP_TYPE_CUBE";
        if (t.envMap) switch(t.envMapMode){
            case 301:
            case 302:
                e552 = "ENVMAP_TYPE_CUBE";
                break;
            case 306:
                e552 = "ENVMAP_TYPE_CUBE_UV";
        }
        return e552;
    }(n395), c50 = function(t) {
        let e553 = "ENVMAP_MODE_REFLECTION";
        t.envMap && 302 === t.envMapMode && (e553 = "ENVMAP_MODE_REFRACTION");
        return e553;
    }(n395), u46 = function(t) {
        let e554 = "ENVMAP_BLENDING_NONE";
        if (t.envMap) switch(t.combine){
            case 0:
                e554 = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case 1:
                e554 = "ENVMAP_BLENDING_MIX";
                break;
            case 2:
                e554 = "ENVMAP_BLENDING_ADD";
        }
        return e554;
    }(n395), d41 = function(t) {
        const e555 = t.envMapCubeUVHeight;
        if (null === e555) return null;
        const n396 = Math.log2(e555 / 32 + 1) + 3, i263 = 1 / e555;
        return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, n396), 112)),
            texelHeight: i263,
            maxMip: n396
        };
    }(n395), p36 = n395.isWebGL2 ? "" : function(t) {
        return [
            t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "",
            (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
            t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
            (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
        ].filter(Xi).join("\n");
    }(n395), m24 = function(t) {
        const e556 = [];
        for(const n397 in t){
            const i264 = t[n397];
            !1 !== i264 && e556.push("#define " + n397 + " " + i264);
        }
        return e556.join("\n");
    }(s126), f18 = r188.createProgram();
    let g15, v15, y14 = n395.glslVersion ? "#version " + n395.glslVersion + "\n" : "";
    n395.isRawShaderMaterial ? (g15 = [
        m24
    ].filter(Xi).join("\n"), g15.length > 0 && (g15 += "\n"), v15 = [
        p36,
        m24
    ].filter(Xi).join("\n"), v15.length > 0 && (v15 += "\n")) : (g15 = [
        rr(n395),
        "#define SHADER_NAME " + n395.shaderName,
        m24,
        n395.instancing ? "#define USE_INSTANCING" : "",
        n395.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        n395.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define MAX_BONES " + n395.maxBones,
        n395.useFog && n395.fog ? "#define USE_FOG" : "",
        n395.useFog && n395.fogExp2 ? "#define FOG_EXP2" : "",
        n395.map ? "#define USE_MAP" : "",
        n395.envMap ? "#define USE_ENVMAP" : "",
        n395.envMap ? "#define " + c50 : "",
        n395.lightMap ? "#define USE_LIGHTMAP" : "",
        n395.aoMap ? "#define USE_AOMAP" : "",
        n395.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n395.bumpMap ? "#define USE_BUMPMAP" : "",
        n395.normalMap ? "#define USE_NORMALMAP" : "",
        n395.normalMap && n395.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        n395.normalMap && n395.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        n395.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n395.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n395.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n395.displacementMap && n395.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        n395.specularMap ? "#define USE_SPECULARMAP" : "",
        n395.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        n395.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        n395.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n395.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n395.alphaMap ? "#define USE_ALPHAMAP" : "",
        n395.transmission ? "#define USE_TRANSMISSION" : "",
        n395.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n395.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n395.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        n395.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        n395.vertexTangents ? "#define USE_TANGENT" : "",
        n395.vertexColors ? "#define USE_COLOR" : "",
        n395.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n395.vertexUvs ? "#define USE_UV" : "",
        n395.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        n395.flatShading ? "#define FLAT_SHADED" : "",
        n395.skinning ? "#define USE_SKINNING" : "",
        n395.useVertexTexture ? "#define BONE_TEXTURE" : "",
        n395.morphTargets ? "#define USE_MORPHTARGETS" : "",
        n395.morphNormals && !1 === n395.flatShading ? "#define USE_MORPHNORMALS" : "",
        n395.morphColors && n395.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        n395.morphTargetsCount > 0 && n395.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        n395.morphTargetsCount > 0 && n395.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n395.morphTextureStride : "",
        n395.morphTargetsCount > 0 && n395.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n395.morphTargetsCount : "",
        n395.doubleSided ? "#define DOUBLE_SIDED" : "",
        n395.flipSided ? "#define FLIP_SIDED" : "",
        n395.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n395.shadowMapEnabled ? "#define " + l76 : "",
        n395.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        n395.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n395.logarithmicDepthBuffer && n395.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
    ].filter(Xi).join("\n"), v15 = [
        p36,
        rr(n395),
        "#define SHADER_NAME " + n395.shaderName,
        m24,
        n395.useFog && n395.fog ? "#define USE_FOG" : "",
        n395.useFog && n395.fogExp2 ? "#define FOG_EXP2" : "",
        n395.map ? "#define USE_MAP" : "",
        n395.matcap ? "#define USE_MATCAP" : "",
        n395.envMap ? "#define USE_ENVMAP" : "",
        n395.envMap ? "#define " + h62 : "",
        n395.envMap ? "#define " + c50 : "",
        n395.envMap ? "#define " + u46 : "",
        d41 ? "#define CUBEUV_TEXEL_WIDTH " + d41.texelWidth : "",
        d41 ? "#define CUBEUV_TEXEL_HEIGHT " + d41.texelHeight : "",
        d41 ? "#define CUBEUV_MAX_MIP " + d41.maxMip + ".0" : "",
        n395.lightMap ? "#define USE_LIGHTMAP" : "",
        n395.aoMap ? "#define USE_AOMAP" : "",
        n395.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n395.bumpMap ? "#define USE_BUMPMAP" : "",
        n395.normalMap ? "#define USE_NORMALMAP" : "",
        n395.normalMap && n395.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        n395.normalMap && n395.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        n395.clearcoat ? "#define USE_CLEARCOAT" : "",
        n395.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n395.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n395.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n395.specularMap ? "#define USE_SPECULARMAP" : "",
        n395.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        n395.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        n395.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n395.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n395.alphaMap ? "#define USE_ALPHAMAP" : "",
        n395.alphaTest ? "#define USE_ALPHATEST" : "",
        n395.sheen ? "#define USE_SHEEN" : "",
        n395.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        n395.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        n395.transmission ? "#define USE_TRANSMISSION" : "",
        n395.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n395.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n395.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        n395.vertexTangents ? "#define USE_TANGENT" : "",
        n395.vertexColors || n395.instancingColor ? "#define USE_COLOR" : "",
        n395.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n395.vertexUvs ? "#define USE_UV" : "",
        n395.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        n395.gradientMap ? "#define USE_GRADIENTMAP" : "",
        n395.flatShading ? "#define FLAT_SHADED" : "",
        n395.doubleSided ? "#define DOUBLE_SIDED" : "",
        n395.flipSided ? "#define FLIP_SIDED" : "",
        n395.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n395.shadowMapEnabled ? "#define " + l76 : "",
        n395.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        n395.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        n395.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n395.logarithmicDepthBuffer && n395.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        0 !== n395.toneMapping ? "#define TONE_MAPPING" : "",
        0 !== n395.toneMapping ? sn.tonemapping_pars_fragment : "",
        0 !== n395.toneMapping ? qi("toneMapping", n395.toneMapping) : "",
        n395.dithering ? "#define DITHERING" : "",
        n395.opaque ? "#define OPAQUE" : "",
        sn.encodings_pars_fragment,
        ji("linearToOutputTexel", n395.outputEncoding),
        n395.depthPacking ? "#define DEPTH_PACKING " + n395.depthPacking : "",
        "\n"
    ].filter(Xi).join("\n")), a93 = Ki(a93), a93 = $i(a93, n395), a93 = Yi(a93, n395), o82 = Ki(o82), o82 = $i(o82, n395), o82 = Yi(o82, n395), a93 = er(a93), o82 = er(o82), n395.isWebGL2 && !0 !== n395.isRawShaderMaterial && (y14 = "#version 300 es\n", g15 = [
        "precision mediump sampler2DArray;",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
    ].join("\n") + "\n" + g15, v15 = [
        "#define varying in",
        "300 es" === n395.glslVersion ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        "300 es" === n395.glslVersion ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + v15);
    const x12 = y14 + v15 + o82, b11 = Vi(r188, 35633, y14 + g15 + a93), _8 = Vi(r188, 35632, x12);
    if (r188.attachShader(f18, b11), r188.attachShader(f18, _8), void 0 !== n395.index0AttributeName ? r188.bindAttribLocation(f18, 0, n395.index0AttributeName) : !0 === n395.morphTargets && r188.bindAttribLocation(f18, 0, "position"), r188.linkProgram(f18), t178.debug.checkShaderErrors) {
        const t = r188.getProgramInfoLog(f18).trim(), e558 = r188.getShaderInfoLog(b11).trim(), n399 = r188.getShaderInfoLog(_8).trim();
        let i265 = !0, s127 = !0;
        if (!1 === r188.getProgramParameter(f18, 35714)) {
            i265 = !1;
            const e557 = Wi(r188, b11, "vertex"), n398 = Wi(r188, _8, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + r188.getError() + " - VALIDATE_STATUS " + r188.getProgramParameter(f18, 35715) + "\n\nProgram Info Log: " + t + "\n" + e557 + "\n" + n398);
        } else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e558 && "" !== n399 || (s127 = !1);
        s127 && (this.diagnostics = {
            runnable: i265,
            programLog: t,
            vertexShader: {
                log: e558,
                prefix: g15
            },
            fragmentShader: {
                log: n399,
                prefix: v15
            }
        });
    }
    let w7, M4;
    return r188.deleteShader(b11), r188.deleteShader(_8), this.getUniforms = function() {
        return void 0 === w7 && (w7 = new Hi(r188, f18)), w7;
    }, this.getAttributes = function() {
        return void 0 === M4 && (M4 = function(t, e559) {
            const n400 = {}, i266 = t.getProgramParameter(e559, 35721);
            for(let r189 = 0; r189 < i266; r189++){
                const i267 = t.getActiveAttrib(e559, r189), s128 = i267.name;
                let a94 = 1;
                35674 === i267.type && (a94 = 2), 35675 === i267.type && (a94 = 3), 35676 === i267.type && (a94 = 4), n400[s128] = {
                    type: i267.type,
                    location: t.getAttribLocation(e559, s128),
                    locationSize: a94
                };
            }
            return n400;
        }(r188, f18)), M4;
    }, this.destroy = function() {
        i262.releaseStatesOfProgram(this), r188.deleteProgram(f18), this.program = void 0;
    }, this.name = n395.shaderName, this.id = Gi++, this.cacheKey = e550, this.usedTimes = 1, this.program = f18, this.vertexShader = b11, this.fragmentShader = _8, this;
}
let ar = 0;
class or {
    constructor(){
        this.shaderCache = new Map, this.materialCache = new Map;
    }
    update(t) {
        const e560 = t.vertexShader, n401 = t.fragmentShader, i268 = this._getShaderStage(e560), r190 = this._getShaderStage(n401), s129 = this._getShaderCacheForMaterial(t);
        return !1 === s129.has(i268) && (s129.add(i268), i268.usedTimes++), !1 === s129.has(r190) && (s129.add(r190), r190.usedTimes++), this;
    }
    remove(t) {
        const e561 = this.materialCache.get(t);
        for (const t179 of e561)t179.usedTimes--, 0 === t179.usedTimes && this.shaderCache.delete(t179.code);
        return this.materialCache.delete(t), this;
    }
    getVertexShaderID(t) {
        return this._getShaderStage(t.vertexShader).id;
    }
    getFragmentShaderID(t) {
        return this._getShaderStage(t.fragmentShader).id;
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(t) {
        const e562 = this.materialCache;
        return !1 === e562.has(t) && e562.set(t, new Set), e562.get(t);
    }
    _getShaderStage(t) {
        const e563 = this.shaderCache;
        if (!1 === e563.has(t)) {
            const n402 = new lr(t);
            e563.set(t, n402);
        }
        return e563.get(t);
    }
}
class lr {
    constructor(t){
        this.id = ar++, this.code = t, this.usedTimes = 0;
    }
}
function hr(t180, e564, n403, i269, r191, s130, a95) {
    const o83 = new Lt, l77 = new or, h63 = [], c51 = r191.isWebGL2, u47 = r191.logarithmicDepthBuffer, d42 = r191.floatVertexTextures, p37 = r191.maxVertexUniforms, m25 = r191.vertexTextures;
    let f19 = r191.precision;
    const g16 = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    return {
        getParameters: function(s131, o84, h64, v16, y15) {
            const x13 = v16.fog, b12 = y15.geometry, _9 = s131.isMeshStandardMaterial ? v16.environment : null, w8 = (s131.isMeshStandardMaterial ? n403 : e564).get(s131.envMap || _9), M5 = w8 && 306 === w8.mapping ? w8.image.height : null, S4 = g16[s131.type], T4 = y15.isSkinnedMesh ? function(t) {
                const e565 = t.skeleton.bones;
                if (d42) return 1024;
                {
                    const t = p37, n404 = Math.floor((t - 20) / 4), i270 = Math.min(n404, e565.length);
                    return i270 < e565.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e565.length + " bones. This GPU supports " + i270 + "."), 0) : i270;
                }
            }(y15) : 0;
            null !== s131.precision && (f19 = r191.getMaxPrecision(s131.precision), f19 !== s131.precision && console.warn("THREE.WebGLProgram.getParameters:", s131.precision, "not supported, using", f19, "instead."));
            const E3 = b12.morphAttributes.position || b12.morphAttributes.normal || b12.morphAttributes.color, A3 = void 0 !== E3 ? E3.length : 0;
            let R2, C2, L2, P2, D2 = 0;
            if (void 0 !== b12.morphAttributes.position && (D2 = 1), void 0 !== b12.morphAttributes.normal && (D2 = 2), void 0 !== b12.morphAttributes.color && (D2 = 3), S4) {
                const t = on[S4];
                R2 = t.vertexShader, C2 = t.fragmentShader;
            } else R2 = s131.vertexShader, C2 = s131.fragmentShader, l77.update(s131), L2 = l77.getVertexShaderID(s131), P2 = l77.getFragmentShaderID(s131);
            const I2 = t180.getRenderTarget(), O2 = s131.alphaTest > 0, N2 = s131.clearcoat > 0;
            return {
                isWebGL2: c51,
                shaderID: S4,
                shaderName: s131.type,
                vertexShader: R2,
                fragmentShader: C2,
                defines: s131.defines,
                customVertexShaderID: L2,
                customFragmentShaderID: P2,
                isRawShaderMaterial: !0 === s131.isRawShaderMaterial,
                glslVersion: s131.glslVersion,
                precision: f19,
                instancing: !0 === y15.isInstancedMesh,
                instancingColor: !0 === y15.isInstancedMesh && null !== y15.instanceColor,
                supportsVertexTextures: m25,
                outputEncoding: null === I2 ? t180.outputEncoding : !0 === I2.isXRRenderTarget ? I2.texture.encoding : 3e3,
                map: !!s131.map,
                matcap: !!s131.matcap,
                envMap: !!w8,
                envMapMode: w8 && w8.mapping,
                envMapCubeUVHeight: M5,
                lightMap: !!s131.lightMap,
                aoMap: !!s131.aoMap,
                emissiveMap: !!s131.emissiveMap,
                bumpMap: !!s131.bumpMap,
                normalMap: !!s131.normalMap,
                objectSpaceNormalMap: 1 === s131.normalMapType,
                tangentSpaceNormalMap: 0 === s131.normalMapType,
                decodeVideoTexture: !!s131.map && !0 === s131.map.isVideoTexture && 3001 === s131.map.encoding,
                clearcoat: N2,
                clearcoatMap: N2 && !!s131.clearcoatMap,
                clearcoatRoughnessMap: N2 && !!s131.clearcoatRoughnessMap,
                clearcoatNormalMap: N2 && !!s131.clearcoatNormalMap,
                displacementMap: !!s131.displacementMap,
                roughnessMap: !!s131.roughnessMap,
                metalnessMap: !!s131.metalnessMap,
                specularMap: !!s131.specularMap,
                specularIntensityMap: !!s131.specularIntensityMap,
                specularColorMap: !!s131.specularColorMap,
                opaque: !1 === s131.transparent && 1 === s131.blending,
                alphaMap: !!s131.alphaMap,
                alphaTest: O2,
                gradientMap: !!s131.gradientMap,
                sheen: s131.sheen > 0,
                sheenColorMap: !!s131.sheenColorMap,
                sheenRoughnessMap: !!s131.sheenRoughnessMap,
                transmission: s131.transmission > 0,
                transmissionMap: !!s131.transmissionMap,
                thicknessMap: !!s131.thicknessMap,
                combine: s131.combine,
                vertexTangents: !!s131.normalMap && !!b12.attributes.tangent,
                vertexColors: s131.vertexColors,
                vertexAlphas: !0 === s131.vertexColors && !!b12.attributes.color && 4 === b12.attributes.color.itemSize,
                vertexUvs: !!(s131.map || s131.bumpMap || s131.normalMap || s131.specularMap || s131.alphaMap || s131.emissiveMap || s131.roughnessMap || s131.metalnessMap || s131.clearcoatMap || s131.clearcoatRoughnessMap || s131.clearcoatNormalMap || s131.displacementMap || s131.transmissionMap || s131.thicknessMap || s131.specularIntensityMap || s131.specularColorMap || s131.sheenColorMap || s131.sheenRoughnessMap),
                uvsVertexOnly: !(s131.map || s131.bumpMap || s131.normalMap || s131.specularMap || s131.alphaMap || s131.emissiveMap || s131.roughnessMap || s131.metalnessMap || s131.clearcoatNormalMap || s131.transmission > 0 || s131.transmissionMap || s131.thicknessMap || s131.specularIntensityMap || s131.specularColorMap || s131.sheen > 0 || s131.sheenColorMap || s131.sheenRoughnessMap || !s131.displacementMap),
                fog: !!x13,
                useFog: s131.fog,
                fogExp2: x13 && x13.isFogExp2,
                flatShading: !!s131.flatShading,
                sizeAttenuation: s131.sizeAttenuation,
                logarithmicDepthBuffer: u47,
                skinning: !0 === y15.isSkinnedMesh && T4 > 0,
                maxBones: T4,
                useVertexTexture: d42,
                morphTargets: void 0 !== b12.morphAttributes.position,
                morphNormals: void 0 !== b12.morphAttributes.normal,
                morphColors: void 0 !== b12.morphAttributes.color,
                morphTargetsCount: A3,
                morphTextureStride: D2,
                numDirLights: o84.directional.length,
                numPointLights: o84.point.length,
                numSpotLights: o84.spot.length,
                numRectAreaLights: o84.rectArea.length,
                numHemiLights: o84.hemi.length,
                numDirLightShadows: o84.directionalShadowMap.length,
                numPointLightShadows: o84.pointShadowMap.length,
                numSpotLightShadows: o84.spotShadowMap.length,
                numClippingPlanes: a95.numPlanes,
                numClipIntersection: a95.numIntersection,
                dithering: s131.dithering,
                shadowMapEnabled: t180.shadowMap.enabled && h64.length > 0,
                shadowMapType: t180.shadowMap.type,
                toneMapping: s131.toneMapped ? t180.toneMapping : 0,
                physicallyCorrectLights: t180.physicallyCorrectLights,
                premultipliedAlpha: s131.premultipliedAlpha,
                doubleSided: 2 === s131.side,
                flipSided: 1 === s131.side,
                depthPacking: void 0 !== s131.depthPacking && s131.depthPacking,
                index0AttributeName: s131.index0AttributeName,
                extensionDerivatives: s131.extensions && s131.extensions.derivatives,
                extensionFragDepth: s131.extensions && s131.extensions.fragDepth,
                extensionDrawBuffers: s131.extensions && s131.extensions.drawBuffers,
                extensionShaderTextureLOD: s131.extensions && s131.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: c51 || i269.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: c51 || i269.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: c51 || i269.has("EXT_shader_texture_lod"),
                customProgramCacheKey: s131.customProgramCacheKey()
            };
        },
        getProgramCacheKey: function(e566) {
            const n405 = [];
            if (e566.shaderID ? n405.push(e566.shaderID) : (n405.push(e566.customVertexShaderID), n405.push(e566.customFragmentShaderID)), void 0 !== e566.defines) for(const t181 in e566.defines)n405.push(t181), n405.push(e566.defines[t181]);
            return !1 === e566.isRawShaderMaterial && (!function(t, e567) {
                t.push(e567.precision), t.push(e567.outputEncoding), t.push(e567.envMapMode), t.push(e567.envMapCubeUVHeight), t.push(e567.combine), t.push(e567.vertexUvs), t.push(e567.fogExp2), t.push(e567.sizeAttenuation), t.push(e567.maxBones), t.push(e567.morphTargetsCount), t.push(e567.morphAttributeCount), t.push(e567.numDirLights), t.push(e567.numPointLights), t.push(e567.numSpotLights), t.push(e567.numHemiLights), t.push(e567.numRectAreaLights), t.push(e567.numDirLightShadows), t.push(e567.numPointLightShadows), t.push(e567.numSpotLightShadows), t.push(e567.shadowMapType), t.push(e567.toneMapping), t.push(e567.numClippingPlanes), t.push(e567.numClipIntersection);
            }(n405, e566), function(t, e568) {
                o83.disableAll(), e568.isWebGL2 && o83.enable(0);
                e568.supportsVertexTextures && o83.enable(1);
                e568.instancing && o83.enable(2);
                e568.instancingColor && o83.enable(3);
                e568.map && o83.enable(4);
                e568.matcap && o83.enable(5);
                e568.envMap && o83.enable(6);
                e568.lightMap && o83.enable(7);
                e568.aoMap && o83.enable(8);
                e568.emissiveMap && o83.enable(9);
                e568.bumpMap && o83.enable(10);
                e568.normalMap && o83.enable(11);
                e568.objectSpaceNormalMap && o83.enable(12);
                e568.tangentSpaceNormalMap && o83.enable(13);
                e568.clearcoat && o83.enable(14);
                e568.clearcoatMap && o83.enable(15);
                e568.clearcoatRoughnessMap && o83.enable(16);
                e568.clearcoatNormalMap && o83.enable(17);
                e568.displacementMap && o83.enable(18);
                e568.specularMap && o83.enable(19);
                e568.roughnessMap && o83.enable(20);
                e568.metalnessMap && o83.enable(21);
                e568.gradientMap && o83.enable(22);
                e568.alphaMap && o83.enable(23);
                e568.alphaTest && o83.enable(24);
                e568.vertexColors && o83.enable(25);
                e568.vertexAlphas && o83.enable(26);
                e568.vertexUvs && o83.enable(27);
                e568.vertexTangents && o83.enable(28);
                e568.uvsVertexOnly && o83.enable(29);
                e568.fog && o83.enable(30);
                t.push(o83.mask), o83.disableAll(), e568.useFog && o83.enable(0);
                e568.flatShading && o83.enable(1);
                e568.logarithmicDepthBuffer && o83.enable(2);
                e568.skinning && o83.enable(3);
                e568.useVertexTexture && o83.enable(4);
                e568.morphTargets && o83.enable(5);
                e568.morphNormals && o83.enable(6);
                e568.morphColors && o83.enable(7);
                e568.premultipliedAlpha && o83.enable(8);
                e568.shadowMapEnabled && o83.enable(9);
                e568.physicallyCorrectLights && o83.enable(10);
                e568.doubleSided && o83.enable(11);
                e568.flipSided && o83.enable(12);
                e568.depthPacking && o83.enable(13);
                e568.dithering && o83.enable(14);
                e568.specularIntensityMap && o83.enable(15);
                e568.specularColorMap && o83.enable(16);
                e568.transmission && o83.enable(17);
                e568.transmissionMap && o83.enable(18);
                e568.thicknessMap && o83.enable(19);
                e568.sheen && o83.enable(20);
                e568.sheenColorMap && o83.enable(21);
                e568.sheenRoughnessMap && o83.enable(22);
                e568.decodeVideoTexture && o83.enable(23);
                e568.opaque && o83.enable(24);
                t.push(o83.mask);
            }(n405, e566), n405.push(t180.outputEncoding)), n405.push(e566.customProgramCacheKey), n405.join();
        },
        getUniforms: function(t) {
            const e569 = g16[t.type];
            let n406;
            if (e569) {
                const t = on[e569];
                n406 = He.clone(t.uniforms);
            } else n406 = t.uniforms;
            return n406;
        },
        acquireProgram: function(e572, n407) {
            let i271;
            for(let t = 0, e570 = h63.length; t < e570; t++){
                const e571 = h63[t];
                if (e571.cacheKey === n407) {
                    i271 = e571, ++i271.usedTimes;
                    break;
                }
            }
            return void 0 === i271 && (i271 = new sr(t180, n407, e572, s130), h63.push(i271)), i271;
        },
        releaseProgram: function(t) {
            if (0 == --t.usedTimes) {
                const e573 = h63.indexOf(t);
                h63[e573] = h63[h63.length - 1], h63.pop(), t.destroy();
            }
        },
        releaseShaderCache: function(t) {
            l77.remove(t);
        },
        programs: h63,
        dispose: function() {
            l77.dispose();
        }
    };
}
function cr() {
    let t = new WeakMap;
    return {
        get: function(e574) {
            let n408 = t.get(e574);
            return void 0 === n408 && (n408 = {}, t.set(e574, n408)), n408;
        },
        remove: function(e575) {
            t.delete(e575);
        },
        update: function(e576, n409, i272) {
            t.get(e576)[n409] = i272;
        },
        dispose: function() {
            t = new WeakMap;
        }
    };
}
function ur(t, e577) {
    return t.groupOrder !== e577.groupOrder ? t.groupOrder - e577.groupOrder : t.renderOrder !== e577.renderOrder ? t.renderOrder - e577.renderOrder : t.material.id !== e577.material.id ? t.material.id - e577.material.id : t.z !== e577.z ? t.z - e577.z : t.id - e577.id;
}
function dr(t, e578) {
    return t.groupOrder !== e578.groupOrder ? t.groupOrder - e578.groupOrder : t.renderOrder !== e578.renderOrder ? t.renderOrder - e578.renderOrder : t.z !== e578.z ? e578.z - t.z : t.id - e578.id;
}
function pr() {
    const t182 = [];
    let e579 = 0;
    const n410 = [], i273 = [], r192 = [];
    function s132(n411, i274, r193, s133, a96, o85) {
        let l78 = t182[e579];
        return void 0 === l78 ? (l78 = {
            id: n411.id,
            object: n411,
            geometry: i274,
            material: r193,
            groupOrder: s133,
            renderOrder: n411.renderOrder,
            z: a96,
            group: o85
        }, t182[e579] = l78) : (l78.id = n411.id, l78.object = n411, l78.geometry = i274, l78.material = r193, l78.groupOrder = s133, l78.renderOrder = n411.renderOrder, l78.z = a96, l78.group = o85), e579++, l78;
    }
    return {
        opaque: n410,
        transmissive: i273,
        transparent: r192,
        init: function() {
            e579 = 0, n410.length = 0, i273.length = 0, r192.length = 0;
        },
        push: function(t, e580, a97, o86, l79, h65) {
            const c52 = s132(t, e580, a97, o86, l79, h65);
            a97.transmission > 0 ? i273.push(c52) : !0 === a97.transparent ? r192.push(c52) : n410.push(c52);
        },
        unshift: function(t, e581, a98, o87, l80, h66) {
            const c53 = s132(t, e581, a98, o87, l80, h66);
            a98.transmission > 0 ? i273.unshift(c53) : !0 === a98.transparent ? r192.unshift(c53) : n410.unshift(c53);
        },
        finish: function() {
            for(let n412 = e579, i275 = t182.length; n412 < i275; n412++){
                const e582 = t182[n412];
                if (null === e582.id) break;
                e582.id = null, e582.object = null, e582.geometry = null, e582.material = null, e582.group = null;
            }
        },
        sort: function(t, e583) {
            n410.length > 1 && n410.sort(t || ur), i273.length > 1 && i273.sort(e583 || dr), r192.length > 1 && r192.sort(e583 || dr);
        }
    };
}
function mr() {
    let t = new WeakMap;
    return {
        get: function(e584, n413) {
            let i276;
            return !1 === t.has(e584) ? (i276 = new pr, t.set(e584, [
                i276
            ])) : n413 >= t.get(e584).length ? (i276 = new pr, t.get(e584).push(i276)) : i276 = t.get(e584)[n413], i276;
        },
        dispose: function() {
            t = new WeakMap;
        }
    };
}
function fr() {
    const t = {};
    return {
        get: function(e585) {
            if (void 0 !== t[e585.id]) return t[e585.id];
            let n414;
            switch(e585.type){
                case "DirectionalLight":
                    n414 = {
                        direction: new V,
                        color: new L
                    };
                    break;
                case "SpotLight":
                    n414 = {
                        position: new V,
                        direction: new V,
                        color: new L,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    n414 = {
                        position: new V,
                        color: new L,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    n414 = {
                        direction: new V,
                        skyColor: new L,
                        groundColor: new L
                    };
                    break;
                case "RectAreaLight":
                    n414 = {
                        color: new L,
                        position: new V,
                        halfWidth: new V,
                        halfHeight: new V
                    };
            }
            return t[e585.id] = n414, n414;
        }
    };
}
let gr = 0;
function vr(t, e586) {
    return (e586.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
}
function yr(t184, e587) {
    const n415 = new fr, i277 = function() {
        const t = {};
        return {
            get: function(e588) {
                if (void 0 !== t[e588.id]) return t[e588.id];
                let n416;
                switch(e588.type){
                    case "DirectionalLight":
                    case "SpotLight":
                        n416 = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new g
                        };
                        break;
                    case "PointLight":
                        n416 = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new g,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                }
                return t[e588.id] = n416, n416;
            }
        };
    }(), r194 = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let t183 = 0; t183 < 9; t183++)r194.probe.push(new V);
    const s134 = new V, a99 = new xt, o88 = new xt;
    return {
        setup: function(s135, a100) {
            let o89 = 0, l81 = 0, h67 = 0;
            for(let t = 0; t < 9; t++)r194.probe[t].set(0, 0, 0);
            let c54 = 0, u48 = 0, d43 = 0, p38 = 0, m26 = 0, f20 = 0, g17 = 0, v17 = 0;
            s135.sort(vr);
            const y16 = !0 !== a100 ? Math.PI : 1;
            for(let t185 = 0, e589 = s135.length; t185 < e589; t185++){
                const e590 = s135[t185], a101 = e590.color, x14 = e590.intensity, b13 = e590.distance, _10 = e590.shadow && e590.shadow.map ? e590.shadow.map.texture : null;
                if (e590.isAmbientLight) o89 += a101.r * x14 * y16, l81 += a101.g * x14 * y16, h67 += a101.b * x14 * y16;
                else if (e590.isLightProbe) for(let t = 0; t < 9; t++)r194.probe[t].addScaledVector(e590.sh.coefficients[t], x14);
                else if (e590.isDirectionalLight) {
                    const t = n415.get(e590);
                    if (t.color.copy(e590.color).multiplyScalar(e590.intensity * y16), e590.castShadow) {
                        const t = e590.shadow, n417 = i277.get(e590);
                        n417.shadowBias = t.bias, n417.shadowNormalBias = t.normalBias, n417.shadowRadius = t.radius, n417.shadowMapSize = t.mapSize, r194.directionalShadow[c54] = n417, r194.directionalShadowMap[c54] = _10, r194.directionalShadowMatrix[c54] = e590.shadow.matrix, f20++;
                    }
                    r194.directional[c54] = t, c54++;
                } else if (e590.isSpotLight) {
                    const t = n415.get(e590);
                    if (t.position.setFromMatrixPosition(e590.matrixWorld), t.color.copy(a101).multiplyScalar(x14 * y16), t.distance = b13, t.coneCos = Math.cos(e590.angle), t.penumbraCos = Math.cos(e590.angle * (1 - e590.penumbra)), t.decay = e590.decay, e590.castShadow) {
                        const t = e590.shadow, n418 = i277.get(e590);
                        n418.shadowBias = t.bias, n418.shadowNormalBias = t.normalBias, n418.shadowRadius = t.radius, n418.shadowMapSize = t.mapSize, r194.spotShadow[d43] = n418, r194.spotShadowMap[d43] = _10, r194.spotShadowMatrix[d43] = e590.shadow.matrix, v17++;
                    }
                    r194.spot[d43] = t, d43++;
                } else if (e590.isRectAreaLight) {
                    const t = n415.get(e590);
                    t.color.copy(a101).multiplyScalar(x14), t.halfWidth.set(.5 * e590.width, 0, 0), t.halfHeight.set(0, .5 * e590.height, 0), r194.rectArea[p38] = t, p38++;
                } else if (e590.isPointLight) {
                    const t = n415.get(e590);
                    if (t.color.copy(e590.color).multiplyScalar(e590.intensity * y16), t.distance = e590.distance, t.decay = e590.decay, e590.castShadow) {
                        const t = e590.shadow, n419 = i277.get(e590);
                        n419.shadowBias = t.bias, n419.shadowNormalBias = t.normalBias, n419.shadowRadius = t.radius, n419.shadowMapSize = t.mapSize, n419.shadowCameraNear = t.camera.near, n419.shadowCameraFar = t.camera.far, r194.pointShadow[u48] = n419, r194.pointShadowMap[u48] = _10, r194.pointShadowMatrix[u48] = e590.shadow.matrix, g17++;
                    }
                    r194.point[u48] = t, u48++;
                } else if (e590.isHemisphereLight) {
                    const t = n415.get(e590);
                    t.skyColor.copy(e590.color).multiplyScalar(x14 * y16), t.groundColor.copy(e590.groundColor).multiplyScalar(x14 * y16), r194.hemi[m26] = t, m26++;
                }
            }
            p38 > 0 && (e587.isWebGL2 || !0 === t184.has("OES_texture_float_linear") ? (r194.rectAreaLTC1 = an.LTC_FLOAT_1, r194.rectAreaLTC2 = an.LTC_FLOAT_2) : !0 === t184.has("OES_texture_half_float_linear") ? (r194.rectAreaLTC1 = an.LTC_HALF_1, r194.rectAreaLTC2 = an.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r194.ambient[0] = o89, r194.ambient[1] = l81, r194.ambient[2] = h67;
            const x15 = r194.hash;
            x15.directionalLength === c54 && x15.pointLength === u48 && x15.spotLength === d43 && x15.rectAreaLength === p38 && x15.hemiLength === m26 && x15.numDirectionalShadows === f20 && x15.numPointShadows === g17 && x15.numSpotShadows === v17 || (r194.directional.length = c54, r194.spot.length = d43, r194.rectArea.length = p38, r194.point.length = u48, r194.hemi.length = m26, r194.directionalShadow.length = f20, r194.directionalShadowMap.length = f20, r194.pointShadow.length = g17, r194.pointShadowMap.length = g17, r194.spotShadow.length = v17, r194.spotShadowMap.length = v17, r194.directionalShadowMatrix.length = f20, r194.pointShadowMatrix.length = g17, r194.spotShadowMatrix.length = v17, x15.directionalLength = c54, x15.pointLength = u48, x15.spotLength = d43, x15.rectAreaLength = p38, x15.hemiLength = m26, x15.numDirectionalShadows = f20, x15.numPointShadows = g17, x15.numSpotShadows = v17, r194.version = gr++);
        },
        setupView: function(t, e592) {
            let n420 = 0, i278 = 0, l82 = 0, h68 = 0, c55 = 0;
            const u49 = e592.matrixWorldInverse;
            for(let e591 = 0, d44 = t.length; e591 < d44; e591++){
                const d45 = t[e591];
                if (d45.isDirectionalLight) {
                    const t = r194.directional[n420];
                    t.direction.setFromMatrixPosition(d45.matrixWorld), s134.setFromMatrixPosition(d45.target.matrixWorld), t.direction.sub(s134), t.direction.transformDirection(u49), n420++;
                } else if (d45.isSpotLight) {
                    const t = r194.spot[l82];
                    t.position.setFromMatrixPosition(d45.matrixWorld), t.position.applyMatrix4(u49), t.direction.setFromMatrixPosition(d45.matrixWorld), s134.setFromMatrixPosition(d45.target.matrixWorld), t.direction.sub(s134), t.direction.transformDirection(u49), l82++;
                } else if (d45.isRectAreaLight) {
                    const t = r194.rectArea[h68];
                    t.position.setFromMatrixPosition(d45.matrixWorld), t.position.applyMatrix4(u49), o88.identity(), a99.copy(d45.matrixWorld), a99.premultiply(u49), o88.extractRotation(a99), t.halfWidth.set(.5 * d45.width, 0, 0), t.halfHeight.set(0, .5 * d45.height, 0), t.halfWidth.applyMatrix4(o88), t.halfHeight.applyMatrix4(o88), h68++;
                } else if (d45.isPointLight) {
                    const t = r194.point[i278];
                    t.position.setFromMatrixPosition(d45.matrixWorld), t.position.applyMatrix4(u49), i278++;
                } else if (d45.isHemisphereLight) {
                    const t = r194.hemi[c55];
                    t.direction.setFromMatrixPosition(d45.matrixWorld), t.direction.transformDirection(u49), t.direction.normalize(), c55++;
                }
            }
        },
        state: r194
    };
}
function xr(t186, e593) {
    const n421 = new yr(t186, e593), i279 = [], r195 = [];
    return {
        init: function() {
            i279.length = 0, r195.length = 0;
        },
        state: {
            lightsArray: i279,
            shadowsArray: r195,
            lights: n421
        },
        setupLights: function(t) {
            n421.setup(i279, t);
        },
        setupLightsView: function(t) {
            n421.setupView(i279, t);
        },
        pushLight: function(t) {
            i279.push(t);
        },
        pushShadow: function(t) {
            r195.push(t);
        }
    };
}
function br(t, e594) {
    let n422 = new WeakMap;
    return {
        get: function(i280, r196 = 0) {
            let s136;
            return !1 === n422.has(i280) ? (s136 = new xr(t, e594), n422.set(i280, [
                s136
            ])) : r196 >= n422.get(i280).length ? (s136 = new xr(t, e594), n422.get(i280).push(s136)) : s136 = n422.get(i280)[r196], s136;
        },
        dispose: function() {
            n422 = new WeakMap;
        }
    };
}
class _r extends ie {
    constructor(t){
        super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
    }
}
_r.prototype.isMeshDepthMaterial = !0;
class wr extends ie {
    constructor(t){
        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new V, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
    }
}
wr.prototype.isMeshDistanceMaterial = !0;
function Mr(t187, e595, n423) {
    let i281 = new tn;
    const r197 = new g, s137 = new g, a102 = new U, o90 = new _r({
        depthPacking: 3201
    }), l83 = new wr, h69 = {}, c56 = n423.maxTextureSize, u50 = {
        0: 1,
        1: 0,
        2: 2
    }, d46 = new Ve({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new g
            },
            radius: {
                value: 4
            }
        },
        vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
    }), p39 = d46.clone();
    p39.defines.HORIZONTAL_PASS = 1;
    const m27 = new ye;
    m27.setAttribute("position", new oe(new Float32Array([
        -1,
        -1,
        .5,
        3,
        -1,
        .5,
        -1,
        3,
        .5
    ]), 3));
    const f21 = new Fe(m27, d46), v18 = this;
    function y17(n424, i282) {
        const r198 = e595.update(f21);
        d46.defines.VSM_SAMPLES !== n424.blurSamples && (d46.defines.VSM_SAMPLES = n424.blurSamples, p39.defines.VSM_SAMPLES = n424.blurSamples, d46.needsUpdate = !0, p39.needsUpdate = !0), d46.uniforms.shadow_pass.value = n424.map.texture, d46.uniforms.resolution.value = n424.mapSize, d46.uniforms.radius.value = n424.radius, t187.setRenderTarget(n424.mapPass), t187.clear(), t187.renderBufferDirect(i282, null, r198, d46, f21, null), p39.uniforms.shadow_pass.value = n424.mapPass.texture, p39.uniforms.resolution.value = n424.mapSize, p39.uniforms.radius.value = n424.radius, t187.setRenderTarget(n424.map), t187.clear(), t187.renderBufferDirect(i282, null, r198, p39, f21, null);
    }
    function x16(e596, n425, i283, r200, s138, a103) {
        let c57 = null;
        const d47 = !0 === i283.isPointLight ? e596.customDistanceMaterial : e596.customDepthMaterial;
        if (c57 = void 0 !== d47 ? d47 : !0 === i283.isPointLight ? l83 : o90, t187.localClippingEnabled && !0 === n425.clipShadows && 0 !== n425.clippingPlanes.length || n425.displacementMap && 0 !== n425.displacementScale || n425.alphaMap && n425.alphaTest > 0) {
            const t = c57.uuid, e597 = n425.uuid;
            let i284 = h69[t];
            void 0 === i284 && (i284 = {}, h69[t] = i284);
            let r199 = i284[e597];
            void 0 === r199 && (r199 = c57.clone(), i284[e597] = r199), c57 = r199;
        }
        return c57.visible = n425.visible, c57.wireframe = n425.wireframe, c57.side = 3 === a103 ? null !== n425.shadowSide ? n425.shadowSide : n425.side : null !== n425.shadowSide ? n425.shadowSide : u50[n425.side], c57.alphaMap = n425.alphaMap, c57.alphaTest = n425.alphaTest, c57.clipShadows = n425.clipShadows, c57.clippingPlanes = n425.clippingPlanes, c57.clipIntersection = n425.clipIntersection, c57.displacementMap = n425.displacementMap, c57.displacementScale = n425.displacementScale, c57.displacementBias = n425.displacementBias, c57.wireframeLinewidth = n425.wireframeLinewidth, c57.linewidth = n425.linewidth, !0 === i283.isPointLight && !0 === c57.isMeshDistanceMaterial && (c57.referencePosition.setFromMatrixPosition(i283.matrixWorld), c57.nearDistance = r200, c57.farDistance = s138), c57;
    }
    function b14(n426, r201, s139, a104, o91) {
        if (!1 === n426.visible) return;
        if (n426.layers.test(r201.layers) && (n426.isMesh || n426.isLine || n426.isPoints) && (n426.castShadow || n426.receiveShadow && 3 === o91) && (!n426.frustumCulled || i281.intersectsObject(n426))) {
            n426.modelViewMatrix.multiplyMatrices(s139.matrixWorldInverse, n426.matrixWorld);
            const i285 = e595.update(n426), r202 = n426.material;
            if (Array.isArray(r202)) {
                const e598 = i285.groups;
                for(let l84 = 0, h70 = e598.length; l84 < h70; l84++){
                    const h71 = e598[l84], c58 = r202[h71.materialIndex];
                    if (c58 && c58.visible) {
                        const e599 = x16(n426, c58, a104, s139.near, s139.far, o91);
                        t187.renderBufferDirect(s139, null, i285, e599, n426, h71);
                    }
                }
            } else if (r202.visible) {
                const e600 = x16(n426, r202, a104, s139.near, s139.far, o91);
                t187.renderBufferDirect(s139, null, i285, e600, n426, null);
            }
        }
        const l85 = n426.children;
        for(let t = 0, e601 = l85.length; t < e601; t++)b14(l85[t], r201, s139, a104, o91);
    }
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e602, n427, o92) {
        if (!1 === v18.enabled) return;
        if (!1 === v18.autoUpdate && !1 === v18.needsUpdate) return;
        if (0 === e602.length) return;
        const l87 = t187.getRenderTarget(), h74 = t187.getActiveCubeFace(), u52 = t187.getActiveMipmapLevel(), d48 = t187.state;
        d48.setBlending(0), d48.buffers.color.setClear(1, 1, 1, 1), d48.buffers.depth.setTest(!0), d48.setScissorTest(!1);
        for(let l86 = 0, h72 = e602.length; l86 < h72; l86++){
            const h73 = e602[l86], u51 = h73.shadow;
            if (void 0 === u51) {
                console.warn("THREE.WebGLShadowMap:", h73, "has no shadow.");
                continue;
            }
            if (!1 === u51.autoUpdate && !1 === u51.needsUpdate) continue;
            r197.copy(u51.mapSize);
            const p40 = u51.getFrameExtents();
            if (r197.multiply(p40), s137.copy(u51.mapSize), (r197.x > c56 || r197.y > c56) && (r197.x > c56 && (s137.x = Math.floor(c56 / p40.x), r197.x = s137.x * p40.x, u51.mapSize.x = s137.x), r197.y > c56 && (s137.y = Math.floor(c56 / p40.y), r197.y = s137.y * p40.y, u51.mapSize.y = s137.y)), null !== u51.map || u51.isPointLightShadow || 3 !== this.type || (u51.map = new k(r197.x, r197.y), u51.map.texture.name = h73.name + ".shadowMap", u51.mapPass = new k(r197.x, r197.y), u51.camera.updateProjectionMatrix()), null === u51.map) {
                const t = {
                    minFilter: 1003,
                    magFilter: 1003,
                    format: 1023
                };
                u51.map = new k(r197.x, r197.y, t), u51.map.texture.name = h73.name + ".shadowMap", u51.camera.updateProjectionMatrix();
            }
            t187.setRenderTarget(u51.map), t187.clear();
            const m28 = u51.getViewportCount();
            for(let t = 0; t < m28; t++){
                const e603 = u51.getViewport(t);
                a102.set(s137.x * e603.x, s137.y * e603.y, s137.x * e603.z, s137.y * e603.w), d48.viewport(a102), u51.updateMatrices(h73, t), i281 = u51.getFrustum(), b14(n427, o92, u51.camera, h73, this.type);
            }
            u51.isPointLightShadow || 3 !== this.type || y17(u51, o92), u51.needsUpdate = !1;
        }
        v18.needsUpdate = !1, t187.setRenderTarget(l87, h74, u52);
    };
}
function Sr(t188, e604, n428) {
    const i286 = n428.isWebGL2;
    const r203 = new function() {
        let e605 = !1;
        const n429 = new U;
        let i287 = null;
        const r204 = new U(0, 0, 0, 0);
        return {
            setMask: function(n430) {
                i287 === n430 || e605 || (t188.colorMask(n430, n430, n430, n430), i287 = n430);
            },
            setLocked: function(t) {
                e605 = t;
            },
            setClear: function(e606, i288, s141, a106, o94) {
                !0 === o94 && (e606 *= a106, i288 *= a106, s141 *= a106), n429.set(e606, i288, s141, a106), !1 === r204.equals(n429) && (t188.clearColor(e606, i288, s141, a106), r204.copy(n429));
            },
            reset: function() {
                e605 = !1, i287 = null, r204.set(-1, 0, 0, 0);
            }
        };
    }, s140 = new function() {
        let e607 = !1, n431 = null, i289 = null, r205 = null;
        return {
            setTest: function(t) {
                t ? B1(2929) : z1(2929);
            },
            setMask: function(i290) {
                n431 === i290 || e607 || (t188.depthMask(i290), n431 = i290);
            },
            setFunc: function(e608) {
                if (i289 !== e608) {
                    if (e608) switch(e608){
                        case 0:
                            t188.depthFunc(512);
                            break;
                        case 1:
                            t188.depthFunc(519);
                            break;
                        case 2:
                            t188.depthFunc(513);
                            break;
                        case 3:
                        default:
                            t188.depthFunc(515);
                            break;
                        case 4:
                            t188.depthFunc(514);
                            break;
                        case 5:
                            t188.depthFunc(518);
                            break;
                        case 6:
                            t188.depthFunc(516);
                            break;
                        case 7:
                            t188.depthFunc(517);
                    }
                    else t188.depthFunc(515);
                    i289 = e608;
                }
            },
            setLocked: function(t) {
                e607 = t;
            },
            setClear: function(e609) {
                r205 !== e609 && (t188.clearDepth(e609), r205 = e609);
            },
            reset: function() {
                e607 = !1, n431 = null, i289 = null, r205 = null;
            }
        };
    }, a105 = new function() {
        let e610 = !1, n432 = null, i291 = null, r206 = null, s142 = null, a107 = null, o95 = null, l89 = null, h76 = null;
        return {
            setTest: function(t) {
                e610 || (t ? B1(2960) : z1(2960));
            },
            setMask: function(i292) {
                n432 === i292 || e610 || (t188.stencilMask(i292), n432 = i292);
            },
            setFunc: function(e611, n433, a108) {
                i291 === e611 && r206 === n433 && s142 === a108 || (t188.stencilFunc(e611, n433, a108), i291 = e611, r206 = n433, s142 = a108);
            },
            setOp: function(e612, n434, i293) {
                a107 === e612 && o95 === n434 && l89 === i293 || (t188.stencilOp(e612, n434, i293), a107 = e612, o95 = n434, l89 = i293);
            },
            setLocked: function(t) {
                e610 = t;
            },
            setClear: function(e613) {
                h76 !== e613 && (t188.clearStencil(e613), h76 = e613);
            },
            reset: function() {
                e610 = !1, n432 = null, i291 = null, r206 = null, s142 = null, a107 = null, o95 = null, l89 = null, h76 = null;
            }
        };
    };
    let o93 = {}, l88 = {}, h75 = new WeakMap, c59 = [], u53 = null, d49 = !1, p41 = null, m29 = null, f22 = null, g18 = null, v19 = null, y18 = null, x17 = null, b15 = !1, _11 = null, w9 = null, M6 = null, S5 = null, T5 = null;
    const E4 = t188.getParameter(35661);
    let A4 = !1, R3 = 0;
    const C3 = t188.getParameter(7938);
    -1 !== C3.indexOf("WebGL") ? (R3 = parseFloat(/^WebGL (\d)/.exec(C3)[1]), A4 = R3 >= 1) : -1 !== C3.indexOf("OpenGL ES") && (R3 = parseFloat(/^OpenGL ES (\d)/.exec(C3)[1]), A4 = R3 >= 2);
    let L3 = null, P3 = {};
    const D3 = t188.getParameter(3088), I3 = t188.getParameter(2978), O3 = (new U).fromArray(D3), N3 = (new U).fromArray(I3);
    function F2(e615, n435, i294) {
        const r207 = new Uint8Array(4), s143 = t188.createTexture();
        t188.bindTexture(e615, s143), t188.texParameteri(e615, 10241, 9728), t188.texParameteri(e615, 10240, 9728);
        for(let e614 = 0; e614 < i294; e614++)t188.texImage2D(n435 + e614, 0, 6408, 1, 1, 0, 6408, 5121, r207);
        return s143;
    }
    const k1 = {};
    function B1(e616) {
        !0 !== o93[e616] && (t188.enable(e616), o93[e616] = !0);
    }
    function z1(e617) {
        !1 !== o93[e617] && (t188.disable(e617), o93[e617] = !1);
    }
    k1[3553] = F2(3553, 3553, 1), k1[34067] = F2(34067, 34069, 6), r203.setClear(0, 0, 0, 1), s140.setClear(1), a105.setClear(0), B1(2929), s140.setFunc(3), W1(!1), j1(1), B1(2884), G1(0);
    const H1 = {
        100: 32774,
        101: 32778,
        102: 32779
    };
    if (i286) H1[103] = 32775, H1[104] = 32776;
    else {
        const t = e604.get("EXT_blend_minmax");
        null !== t && (H1[103] = t.MIN_EXT, H1[104] = t.MAX_EXT);
    }
    const V1 = {
        200: 0,
        201: 1,
        202: 768,
        204: 770,
        210: 776,
        208: 774,
        206: 772,
        203: 769,
        205: 771,
        209: 775,
        207: 773
    };
    function G1(e618, n436, i295, r208, s144, a109, o96, l90) {
        if (0 !== e618) {
            if (!1 === d49 && (B1(3042), d49 = !0), 5 === e618) s144 = s144 || n436, a109 = a109 || i295, o96 = o96 || r208, n436 === m29 && s144 === v19 || (t188.blendEquationSeparate(H1[n436], H1[s144]), m29 = n436, v19 = s144), i295 === f22 && r208 === g18 && a109 === y18 && o96 === x17 || (t188.blendFuncSeparate(V1[i295], V1[r208], V1[a109], V1[o96]), f22 = i295, g18 = r208, y18 = a109, x17 = o96), p41 = e618, b15 = null;
            else if (e618 !== p41 || l90 !== b15) {
                if (100 === m29 && 100 === v19 || (t188.blendEquation(32774), m29 = 100, v19 = 100), l90) switch(e618){
                    case 1:
                        t188.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case 2:
                        t188.blendFunc(1, 1);
                        break;
                    case 3:
                        t188.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case 4:
                        t188.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", e618);
                }
                else switch(e618){
                    case 1:
                        t188.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case 2:
                        t188.blendFunc(770, 1);
                        break;
                    case 3:
                        t188.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case 4:
                        t188.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", e618);
                }
                f22 = null, g18 = null, y18 = null, x17 = null, p41 = e618, b15 = l90;
            }
        } else !0 === d49 && (z1(3042), d49 = !1);
    }
    function W1(e619) {
        _11 !== e619 && (e619 ? t188.frontFace(2304) : t188.frontFace(2305), _11 = e619);
    }
    function j1(e620) {
        0 !== e620 ? (B1(2884), e620 !== w9 && (1 === e620 ? t188.cullFace(1029) : 2 === e620 ? t188.cullFace(1028) : t188.cullFace(1032))) : z1(2884), w9 = e620;
    }
    function q1(e621, n437, i296) {
        e621 ? (B1(32823), S5 === n437 && T5 === i296 || (t188.polygonOffset(n437, i296), S5 = n437, T5 = i296)) : z1(32823);
    }
    function X1(e622) {
        void 0 === e622 && (e622 = 33984 + E4 - 1), L3 !== e622 && (t188.activeTexture(e622), L3 = e622);
    }
    return {
        buffers: {
            color: r203,
            depth: s140,
            stencil: a105
        },
        enable: B1,
        disable: z1,
        bindFramebuffer: function(e623, n438) {
            return l88[e623] !== n438 && (t188.bindFramebuffer(e623, n438), l88[e623] = n438, i286 && (36009 === e623 && (l88[36160] = n438), 36160 === e623 && (l88[36009] = n438)), !0);
        },
        drawBuffers: function(i297, r209) {
            let s145 = c59, a110 = !1;
            if (i297) {
                if (s145 = h75.get(r209), void 0 === s145 && (s145 = [], h75.set(r209, s145)), i297.isWebGLMultipleRenderTargets) {
                    const t = i297.texture;
                    if (s145.length !== t.length || 36064 !== s145[0]) {
                        for(let e624 = 0, n439 = t.length; e624 < n439; e624++)s145[e624] = 36064 + e624;
                        s145.length = t.length, a110 = !0;
                    }
                } else 36064 !== s145[0] && (s145[0] = 36064, a110 = !0);
            } else 1029 !== s145[0] && (s145[0] = 1029, a110 = !0);
            a110 && (n428.isWebGL2 ? t188.drawBuffers(s145) : e604.get("WEBGL_draw_buffers").drawBuffersWEBGL(s145));
        },
        useProgram: function(e625) {
            return u53 !== e625 && (t188.useProgram(e625), u53 = e625, !0);
        },
        setBlending: G1,
        setMaterial: function(t, e626) {
            2 === t.side ? z1(2884) : B1(2884);
            let n440 = 1 === t.side;
            e626 && (n440 = !n440), W1(n440), 1 === t.blending && !1 === t.transparent ? G1(0) : G1(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s140.setFunc(t.depthFunc), s140.setTest(t.depthTest), s140.setMask(t.depthWrite), r203.setMask(t.colorWrite);
            const i298 = t.stencilWrite;
            a105.setTest(i298), i298 && (a105.setMask(t.stencilWriteMask), a105.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a105.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), q1(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? B1(32926) : z1(32926);
        },
        setFlipSided: W1,
        setCullFace: j1,
        setLineWidth: function(e627) {
            e627 !== M6 && (A4 && t188.lineWidth(e627), M6 = e627);
        },
        setPolygonOffset: q1,
        setScissorTest: function(t) {
            t ? B1(3089) : z1(3089);
        },
        activeTexture: X1,
        bindTexture: function(e628, n441) {
            null === L3 && X1();
            let i299 = P3[L3];
            void 0 === i299 && (i299 = {
                type: void 0,
                texture: void 0
            }, P3[L3] = i299), i299.type === e628 && i299.texture === n441 || (t188.bindTexture(e628, n441 || k1[e628]), i299.type = e628, i299.texture = n441);
        },
        unbindTexture: function() {
            const e629 = P3[L3];
            void 0 !== e629 && void 0 !== e629.type && (t188.bindTexture(e629.type, null), e629.type = void 0, e629.texture = void 0);
        },
        compressedTexImage2D: function() {
            try {
                t188.compressedTexImage2D.apply(t188, arguments);
            } catch (t) {
                console.error("THREE.WebGLState:", t);
            }
        },
        texImage2D: function() {
            try {
                t188.texImage2D.apply(t188, arguments);
            } catch (t) {
                console.error("THREE.WebGLState:", t);
            }
        },
        texImage3D: function() {
            try {
                t188.texImage3D.apply(t188, arguments);
            } catch (t) {
                console.error("THREE.WebGLState:", t);
            }
        },
        texStorage2D: function() {
            try {
                t188.texStorage2D.apply(t188, arguments);
            } catch (t) {
                console.error("THREE.WebGLState:", t);
            }
        },
        texStorage3D: function() {
            try {
                t188.texStorage3D.apply(t188, arguments);
            } catch (t) {
                console.error("THREE.WebGLState:", t);
            }
        },
        texSubImage2D: function() {
            try {
                t188.texSubImage2D.apply(t188, arguments);
            } catch (t) {
                console.error("THREE.WebGLState:", t);
            }
        },
        texSubImage3D: function() {
            try {
                t188.texSubImage3D.apply(t188, arguments);
            } catch (t) {
                console.error("THREE.WebGLState:", t);
            }
        },
        compressedTexSubImage2D: function() {
            try {
                t188.compressedTexSubImage2D.apply(t188, arguments);
            } catch (t) {
                console.error("THREE.WebGLState:", t);
            }
        },
        scissor: function(e630) {
            !1 === O3.equals(e630) && (t188.scissor(e630.x, e630.y, e630.z, e630.w), O3.copy(e630));
        },
        viewport: function(e631) {
            !1 === N3.equals(e631) && (t188.viewport(e631.x, e631.y, e631.z, e631.w), N3.copy(e631));
        },
        reset: function() {
            t188.disable(3042), t188.disable(2884), t188.disable(2929), t188.disable(32823), t188.disable(3089), t188.disable(2960), t188.disable(32926), t188.blendEquation(32774), t188.blendFunc(1, 0), t188.blendFuncSeparate(1, 0, 1, 0), t188.colorMask(!0, !0, !0, !0), t188.clearColor(0, 0, 0, 0), t188.depthMask(!0), t188.depthFunc(513), t188.clearDepth(1), t188.stencilMask(4294967295), t188.stencilFunc(519, 0, 4294967295), t188.stencilOp(7680, 7680, 7680), t188.clearStencil(0), t188.cullFace(1029), t188.frontFace(2305), t188.polygonOffset(0, 0), t188.activeTexture(33984), t188.bindFramebuffer(36160, null), !0 === i286 && (t188.bindFramebuffer(36009, null), t188.bindFramebuffer(36008, null)), t188.useProgram(null), t188.lineWidth(1), t188.scissor(0, 0, t188.canvas.width, t188.canvas.height), t188.viewport(0, 0, t188.canvas.width, t188.canvas.height), o93 = {}, L3 = null, P3 = {}, l88 = {}, h75 = new WeakMap, c59 = [], u53 = null, d49 = !1, p41 = null, m29 = null, f22 = null, g18 = null, v19 = null, y18 = null, x17 = null, b15 = !1, _11 = null, w9 = null, M6 = null, S5 = null, T5 = null, O3.set(0, 0, t188.canvas.width, t188.canvas.height), N3.set(0, 0, t188.canvas.width, t188.canvas.height), r203.reset(), s140.reset(), a105.reset();
        }
    };
}
function Tr(t190, e632, n442, i300, r210, s146, a111) {
    const o97 = r210.isWebGL2, l91 = r210.maxTextures, h77 = r210.maxCubemapSize, c60 = r210.maxTextureSize, u54 = r210.maxSamples, p42 = e632.has("WEBGL_multisampled_render_to_texture") ? e632.get("WEBGL_multisampled_render_to_texture") : null, f23 = /OculusBrowser/g.test(navigator.userAgent), g19 = new WeakMap;
    let v20;
    const y19 = new WeakMap;
    let b16 = !1;
    try {
        b16 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (t189) {}
    function _12(t, e633) {
        return b16 ? new OffscreenCanvas(t, e633) : x("canvas");
    }
    function w10(t, e634, n443, i301) {
        let r211 = 1;
        if ((t.width > i301 || t.height > i301) && (r211 = i301 / Math.max(t.width, t.height)), r211 < 1 || !0 === e634) {
            if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                const i302 = e634 ? m : Math.floor, s147 = i302(r211 * t.width), a112 = i302(r211 * t.height);
                void 0 === v20 && (v20 = _12(s147, a112));
                const o98 = n443 ? _12(s147, a112) : v20;
                o98.width = s147, o98.height = a112;
                return o98.getContext("2d").drawImage(t, 0, 0, s147, a112), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s147 + "x" + a112 + ")."), o98;
            }
            return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t;
        }
        return t;
    }
    function M7(t) {
        return d(t.width) && d(t.height);
    }
    function S6(t, e635) {
        return t.generateMipmaps && e635 && 1003 !== t.minFilter && 1006 !== t.minFilter;
    }
    function T6(e636) {
        t190.generateMipmap(e636);
    }
    function E5(n444, i303, r212, s148, a113 = !1) {
        if (!1 === o97) return i303;
        if (null !== n444) {
            if (void 0 !== t190[n444]) return t190[n444];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n444 + "'");
        }
        let l92 = i303;
        return 6403 === i303 && (5126 === r212 && (l92 = 33326), 5131 === r212 && (l92 = 33325), 5121 === r212 && (l92 = 33321)), 33319 === i303 && (5126 === r212 && (l92 = 33328), 5131 === r212 && (l92 = 33327), 5121 === r212 && (l92 = 33323)), 6408 === i303 && (5126 === r212 && (l92 = 34836), 5131 === r212 && (l92 = 34842), 5121 === r212 && (l92 = 3001 === s148 && !1 === a113 ? 35907 : 32856), 32819 === r212 && (l92 = 32854), 32820 === r212 && (l92 = 32855)), 33325 !== l92 && 33326 !== l92 && 33327 !== l92 && 33328 !== l92 && 34842 !== l92 && 34836 !== l92 || e632.get("EXT_color_buffer_float"), l92;
    }
    function A5(t, e637, n445) {
        return !0 === S6(t, n445) || t.isFramebufferTexture && 1003 !== t.minFilter && 1006 !== t.minFilter ? Math.log2(Math.max(e637.width, e637.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? e637.mipmaps.length : 1;
    }
    function R4(t) {
        return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729;
    }
    function C4(t191) {
        const e638 = t191.target;
        e638.removeEventListener("dispose", C4), function(t) {
            const e639 = i300.get(t);
            if (void 0 === e639.__webglInit) return;
            const n446 = t.source, r213 = y19.get(n446);
            if (r213) {
                const i304 = r213[e639.__cacheKey];
                i304.usedTimes--, 0 === i304.usedTimes && P4(t), 0 === Object.keys(r213).length && y19.delete(n446);
            }
            i300.remove(t);
        }(e638), e638.isVideoTexture && g19.delete(e638);
    }
    function L4(e640) {
        const n447 = e640.target;
        n447.removeEventListener("dispose", L4), function(e643) {
            const n448 = e643.texture, r215 = i300.get(e643), s149 = i300.get(n448);
            void 0 !== s149.__webglTexture && (t190.deleteTexture(s149.__webglTexture), a111.memory.textures--);
            e643.depthTexture && e643.depthTexture.dispose();
            if (e643.isWebGLCubeRenderTarget) for(let e641 = 0; e641 < 6; e641++)t190.deleteFramebuffer(r215.__webglFramebuffer[e641]), r215.__webglDepthbuffer && t190.deleteRenderbuffer(r215.__webglDepthbuffer[e641]);
            else t190.deleteFramebuffer(r215.__webglFramebuffer), r215.__webglDepthbuffer && t190.deleteRenderbuffer(r215.__webglDepthbuffer), r215.__webglMultisampledFramebuffer && t190.deleteFramebuffer(r215.__webglMultisampledFramebuffer), r215.__webglColorRenderbuffer && t190.deleteRenderbuffer(r215.__webglColorRenderbuffer), r215.__webglDepthRenderbuffer && t190.deleteRenderbuffer(r215.__webglDepthRenderbuffer);
            if (e643.isWebGLMultipleRenderTargets) for(let e642 = 0, r214 = n448.length; e642 < r214; e642++){
                const r216 = i300.get(n448[e642]);
                r216.__webglTexture && (t190.deleteTexture(r216.__webglTexture), a111.memory.textures--), i300.remove(n448[e642]);
            }
            i300.remove(n448), i300.remove(e643);
        }(n447);
    }
    function P4(e644) {
        const n449 = i300.get(e644);
        t190.deleteTexture(n449.__webglTexture);
        const r217 = e644.source;
        delete y19.get(r217)[n449.__cacheKey], a111.memory.textures--;
    }
    let I4 = 0;
    function O4(t192, e645) {
        const r218 = i300.get(t192);
        if (t192.isVideoTexture && function(t) {
            const e646 = a111.render.frame;
            g19.get(t) !== e646 && (g19.set(t, e646), t.update());
        }(t192), !1 === t192.isRenderTargetTexture && t192.version > 0 && r218.__version !== t192.version) {
            const n450 = t192.image;
            if (null === n450) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else {
                if (!1 !== n450.complete) return void B2(r218, t192, e645);
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            }
        }
        n442.activeTexture(33984 + e645), n442.bindTexture(3553, r218.__webglTexture);
    }
    const N4 = {
        1e3: 10497,
        1001: 33071,
        1002: 33648
    }, F3 = {
        1003: 9728,
        1004: 9984,
        1005: 9986,
        1006: 9729,
        1007: 9985,
        1008: 9987
    };
    function U1(n451, s150, a114) {
        if (a114 ? (t190.texParameteri(n451, 10242, N4[s150.wrapS]), t190.texParameteri(n451, 10243, N4[s150.wrapT]), 32879 !== n451 && 35866 !== n451 || t190.texParameteri(n451, 32882, N4[s150.wrapR]), t190.texParameteri(n451, 10240, F3[s150.magFilter]), t190.texParameteri(n451, 10241, F3[s150.minFilter])) : (t190.texParameteri(n451, 10242, 33071), t190.texParameteri(n451, 10243, 33071), 32879 !== n451 && 35866 !== n451 || t190.texParameteri(n451, 32882, 33071), 1001 === s150.wrapS && 1001 === s150.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t190.texParameteri(n451, 10240, R4(s150.magFilter)), t190.texParameteri(n451, 10241, R4(s150.minFilter)), 1003 !== s150.minFilter && 1006 !== s150.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e632.has("EXT_texture_filter_anisotropic")) {
            const a115 = e632.get("EXT_texture_filter_anisotropic");
            if (1015 === s150.type && !1 === e632.has("OES_texture_float_linear")) return;
            if (!1 === o97 && 1016 === s150.type && !1 === e632.has("OES_texture_half_float_linear")) return;
            (s150.anisotropy > 1 || i300.get(s150).__currentAnisotropy) && (t190.texParameterf(n451, a115.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s150.anisotropy, r210.getMaxAnisotropy())), i300.get(s150).__currentAnisotropy = s150.anisotropy);
        }
    }
    function k2(e647, n452) {
        let i305 = !1;
        void 0 === e647.__webglInit && (e647.__webglInit = !0, n452.addEventListener("dispose", C4));
        const r219 = n452.source;
        let s151 = y19.get(r219);
        void 0 === s151 && (s151 = {}, y19.set(r219, s151));
        const o99 = function(t) {
            const e648 = [];
            return e648.push(t.wrapS), e648.push(t.wrapT), e648.push(t.magFilter), e648.push(t.minFilter), e648.push(t.anisotropy), e648.push(t.internalFormat), e648.push(t.format), e648.push(t.type), e648.push(t.generateMipmaps), e648.push(t.premultiplyAlpha), e648.push(t.flipY), e648.push(t.unpackAlignment), e648.push(t.encoding), e648.join();
        }(n452);
        if (o99 !== e647.__cacheKey) {
            void 0 === s151[o99] && (s151[o99] = {
                texture: t190.createTexture(),
                usedTimes: 0
            }, a111.memory.textures++, i305 = !0), s151[o99].usedTimes++;
            const r220 = s151[e647.__cacheKey];
            void 0 !== r220 && (s151[e647.__cacheKey].usedTimes--, 0 === r220.usedTimes && P4(n452)), e647.__cacheKey = o99, e647.__webglTexture = s151[o99].texture;
        }
        return i305;
    }
    function B2(e649, i306, r221) {
        let a116 = 3553;
        i306.isDataArrayTexture && (a116 = 35866), i306.isData3DTexture && (a116 = 32879);
        const l93 = k2(e649, i306), h78 = i306.source;
        if (n442.activeTexture(33984 + r221), n442.bindTexture(a116, e649.__webglTexture), h78.version !== h78.__currentVersion || !0 === l93) {
            t190.pixelStorei(37440, i306.flipY), t190.pixelStorei(37441, i306.premultiplyAlpha), t190.pixelStorei(3317, i306.unpackAlignment), t190.pixelStorei(37443, 0);
            const r222 = function(t) {
                return !o97 && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter);
            }(i306) && !1 === M7(i306.image);
            let l94 = w10(i306.image, r222, !1, c60);
            l94 = j2(i306, l94);
            const u55 = M7(l94) || o97, d50 = s146.convert(i306.format, i306.encoding);
            let p43, m30 = s146.convert(i306.type), f24 = E5(i306.internalFormat, d50, m30, i306.encoding, i306.isVideoTexture);
            U1(a116, i306, u55);
            const g20 = i306.mipmaps, v21 = o97 && !0 !== i306.isVideoTexture, y20 = void 0 === e649.__version, x18 = A5(i306, l94, u55);
            if (i306.isDepthTexture) f24 = 6402, o97 ? f24 = 1015 === i306.type ? 36012 : 1014 === i306.type ? 33190 : 1020 === i306.type ? 35056 : 33189 : 1015 === i306.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === i306.format && 6402 === f24 && 1012 !== i306.type && 1014 !== i306.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i306.type = 1012, m30 = s146.convert(i306.type)), 1027 === i306.format && 6402 === f24 && (f24 = 34041, 1020 !== i306.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i306.type = 1020, m30 = s146.convert(i306.type))), v21 && y20 ? n442.texStorage2D(3553, 1, f24, l94.width, l94.height) : n442.texImage2D(3553, 0, f24, l94.width, l94.height, 0, d50, m30, null);
            else if (i306.isDataTexture) {
                if (g20.length > 0 && u55) {
                    v21 && y20 && n442.texStorage2D(3553, x18, f24, g20[0].width, g20[0].height);
                    for(let t = 0, e650 = g20.length; t < e650; t++)p43 = g20[t], v21 ? n442.texSubImage2D(3553, t, 0, 0, p43.width, p43.height, d50, m30, p43.data) : n442.texImage2D(3553, t, f24, p43.width, p43.height, 0, d50, m30, p43.data);
                    i306.generateMipmaps = !1;
                } else v21 ? (y20 && n442.texStorage2D(3553, x18, f24, l94.width, l94.height), n442.texSubImage2D(3553, 0, 0, 0, l94.width, l94.height, d50, m30, l94.data)) : n442.texImage2D(3553, 0, f24, l94.width, l94.height, 0, d50, m30, l94.data);
            } else if (i306.isCompressedTexture) {
                v21 && y20 && n442.texStorage2D(3553, x18, f24, g20[0].width, g20[0].height);
                for(let t = 0, e651 = g20.length; t < e651; t++)p43 = g20[t], 1023 !== i306.format ? null !== d50 ? v21 ? n442.compressedTexSubImage2D(3553, t, 0, 0, p43.width, p43.height, d50, p43.data) : n442.compressedTexImage2D(3553, t, f24, p43.width, p43.height, 0, p43.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v21 ? n442.texSubImage2D(3553, t, 0, 0, p43.width, p43.height, d50, m30, p43.data) : n442.texImage2D(3553, t, f24, p43.width, p43.height, 0, d50, m30, p43.data);
            } else if (i306.isDataArrayTexture) v21 ? (y20 && n442.texStorage3D(35866, x18, f24, l94.width, l94.height, l94.depth), n442.texSubImage3D(35866, 0, 0, 0, 0, l94.width, l94.height, l94.depth, d50, m30, l94.data)) : n442.texImage3D(35866, 0, f24, l94.width, l94.height, l94.depth, 0, d50, m30, l94.data);
            else if (i306.isData3DTexture) v21 ? (y20 && n442.texStorage3D(32879, x18, f24, l94.width, l94.height, l94.depth), n442.texSubImage3D(32879, 0, 0, 0, 0, l94.width, l94.height, l94.depth, d50, m30, l94.data)) : n442.texImage3D(32879, 0, f24, l94.width, l94.height, l94.depth, 0, d50, m30, l94.data);
            else if (i306.isFramebufferTexture) v21 && y20 ? n442.texStorage2D(3553, x18, f24, l94.width, l94.height) : n442.texImage2D(3553, 0, f24, l94.width, l94.height, 0, d50, m30, null);
            else if (g20.length > 0 && u55) {
                v21 && y20 && n442.texStorage2D(3553, x18, f24, g20[0].width, g20[0].height);
                for(let t = 0, e652 = g20.length; t < e652; t++)p43 = g20[t], v21 ? n442.texSubImage2D(3553, t, 0, 0, d50, m30, p43) : n442.texImage2D(3553, t, f24, d50, m30, p43);
                i306.generateMipmaps = !1;
            } else v21 ? (y20 && n442.texStorage2D(3553, x18, f24, l94.width, l94.height), n442.texSubImage2D(3553, 0, 0, 0, d50, m30, l94)) : n442.texImage2D(3553, 0, f24, d50, m30, l94);
            S6(i306, u55) && T6(a116), h78.__currentVersion = h78.version, i306.onUpdate && i306.onUpdate(i306);
        }
        e649.__version = i306.version;
    }
    function z2(e653, r223, a117, o100, l95) {
        const h79 = s146.convert(a117.format, a117.encoding), c61 = s146.convert(a117.type), u56 = E5(a117.internalFormat, h79, c61, a117.encoding);
        i300.get(r223).__hasExternalTextures || (32879 === l95 || 35866 === l95 ? n442.texImage3D(l95, 0, u56, r223.width, r223.height, r223.depth, 0, h79, c61, null) : n442.texImage2D(l95, 0, u56, r223.width, r223.height, 0, h79, c61, null)), n442.bindFramebuffer(36160, e653), W2(r223) ? p42.framebufferTexture2DMultisampleEXT(36160, o100, l95, i300.get(a117).__webglTexture, 0, G2(r223)) : t190.framebufferTexture2D(36160, o100, l95, i300.get(a117).__webglTexture, 0), n442.bindFramebuffer(36160, null);
    }
    function H2(e654, n453, i307) {
        if (t190.bindRenderbuffer(36161, e654), n453.depthBuffer && !n453.stencilBuffer) {
            let r224 = 33189;
            if (i307 || W2(n453)) {
                const e655 = n453.depthTexture;
                e655 && e655.isDepthTexture && (1015 === e655.type ? r224 = 36012 : 1014 === e655.type && (r224 = 33190));
                const i308 = G2(n453);
                W2(n453) ? p42.renderbufferStorageMultisampleEXT(36161, i308, r224, n453.width, n453.height) : t190.renderbufferStorageMultisample(36161, i308, r224, n453.width, n453.height);
            } else t190.renderbufferStorage(36161, r224, n453.width, n453.height);
            t190.framebufferRenderbuffer(36160, 36096, 36161, e654);
        } else if (n453.depthBuffer && n453.stencilBuffer) {
            const r225 = G2(n453);
            i307 && !1 === W2(n453) ? t190.renderbufferStorageMultisample(36161, r225, 35056, n453.width, n453.height) : W2(n453) ? p42.renderbufferStorageMultisampleEXT(36161, r225, 35056, n453.width, n453.height) : t190.renderbufferStorage(36161, 34041, n453.width, n453.height), t190.framebufferRenderbuffer(36160, 33306, 36161, e654);
        } else {
            const e656 = !0 === n453.isWebGLMultipleRenderTargets ? n453.texture[0] : n453.texture, r226 = s146.convert(e656.format, e656.encoding), a118 = s146.convert(e656.type), o101 = E5(e656.internalFormat, r226, a118, e656.encoding), l96 = G2(n453);
            i307 && !1 === W2(n453) ? t190.renderbufferStorageMultisample(36161, l96, o101, n453.width, n453.height) : W2(n453) ? p42.renderbufferStorageMultisampleEXT(36161, l96, o101, n453.width, n453.height) : t190.renderbufferStorage(36161, o101, n453.width, n453.height);
        }
        t190.bindRenderbuffer(36161, null);
    }
    function V2(e657) {
        const r227 = i300.get(e657), s152 = !0 === e657.isWebGLCubeRenderTarget;
        if (e657.depthTexture && !r227.__autoAllocateDepthBuffer) {
            if (s152) throw new Error("target.depthTexture not supported in Cube render targets");
            !function(e658, r228) {
                if (r228 && r228.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                if (n442.bindFramebuffer(36160, e658), !r228.depthTexture || !r228.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                i300.get(r228.depthTexture).__webglTexture && r228.depthTexture.image.width === r228.width && r228.depthTexture.image.height === r228.height || (r228.depthTexture.image.width = r228.width, r228.depthTexture.image.height = r228.height, r228.depthTexture.needsUpdate = !0), O4(r228.depthTexture, 0);
                const s153 = i300.get(r228.depthTexture).__webglTexture, a119 = G2(r228);
                if (1026 === r228.depthTexture.format) W2(r228) ? p42.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s153, 0, a119) : t190.framebufferTexture2D(36160, 36096, 3553, s153, 0);
                else {
                    if (1027 !== r228.depthTexture.format) throw new Error("Unknown depthTexture format");
                    W2(r228) ? p42.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s153, 0, a119) : t190.framebufferTexture2D(36160, 33306, 3553, s153, 0);
                }
            }(r227.__webglFramebuffer, e657);
        } else if (s152) {
            r227.__webglDepthbuffer = [];
            for(let i309 = 0; i309 < 6; i309++)n442.bindFramebuffer(36160, r227.__webglFramebuffer[i309]), r227.__webglDepthbuffer[i309] = t190.createRenderbuffer(), H2(r227.__webglDepthbuffer[i309], e657, !1);
        } else n442.bindFramebuffer(36160, r227.__webglFramebuffer), r227.__webglDepthbuffer = t190.createRenderbuffer(), H2(r227.__webglDepthbuffer, e657, !1);
        n442.bindFramebuffer(36160, null);
    }
    function G2(t) {
        return Math.min(u54, t.samples);
    }
    function W2(t) {
        const n454 = i300.get(t);
        return o97 && t.samples > 0 && !0 === e632.has("WEBGL_multisampled_render_to_texture") && !1 !== n454.__useRenderToTexture;
    }
    function j2(t, n455) {
        const i310 = t.encoding, r229 = t.format, s154 = t.type;
        return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || 1035 === t.format || 3e3 !== i310 && (3001 === i310 ? !1 === o97 ? !0 === e632.has("EXT_sRGB") && 1023 === r229 ? (t.format = 1035, t.minFilter = 1006, t.generateMipmaps = !1) : n455 = D.sRGBToLinear(n455) : 1023 === r229 && 1009 === s154 || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i310)), n455;
    }
    this.allocateTextureUnit = function() {
        const t = I4;
        return t >= l91 && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l91), I4 += 1, t;
    }, this.resetTextureUnits = function() {
        I4 = 0;
    }, this.setTexture2D = O4, this.setTexture2DArray = function(t, e659) {
        const r230 = i300.get(t);
        t.version > 0 && r230.__version !== t.version ? B2(r230, t, e659) : (n442.activeTexture(33984 + e659), n442.bindTexture(35866, r230.__webglTexture));
    }, this.setTexture3D = function(t, e660) {
        const r231 = i300.get(t);
        t.version > 0 && r231.__version !== t.version ? B2(r231, t, e660) : (n442.activeTexture(33984 + e660), n442.bindTexture(32879, r231.__webglTexture));
    }, this.setTextureCube = function(e661, r232) {
        const a120 = i300.get(e661);
        e661.version > 0 && a120.__version !== e661.version ? function(e662, i311, r233) {
            if (6 !== i311.image.length) return;
            const a121 = k2(e662, i311), l97 = i311.source;
            if (n442.activeTexture(33984 + r233), n442.bindTexture(34067, e662.__webglTexture), l97.version !== l97.__currentVersion || !0 === a121) {
                t190.pixelStorei(37440, i311.flipY), t190.pixelStorei(37441, i311.premultiplyAlpha), t190.pixelStorei(3317, i311.unpackAlignment), t190.pixelStorei(37443, 0);
                const r234 = i311.isCompressedTexture || i311.image[0].isCompressedTexture, a122 = i311.image[0] && i311.image[0].isDataTexture, c62 = [];
                for(let t = 0; t < 6; t++)c62[t] = r234 || a122 ? a122 ? i311.image[t].image : i311.image[t] : w10(i311.image[t], !1, !0, h77), c62[t] = j2(i311, c62[t]);
                const u57 = c62[0], d51 = M7(u57) || o97, p44 = s146.convert(i311.format, i311.encoding), m31 = s146.convert(i311.type), f25 = E5(i311.internalFormat, p44, m31, i311.encoding), g21 = o97 && !0 !== i311.isVideoTexture, v22 = void 0 === e662.__version;
                let y21, x19 = A5(i311, u57, d51);
                if (U1(34067, i311, d51), r234) {
                    g21 && v22 && n442.texStorage2D(34067, x19, f25, u57.width, u57.height);
                    for(let t = 0; t < 6; t++){
                        y21 = c62[t].mipmaps;
                        for(let e663 = 0; e663 < y21.length; e663++){
                            const r235 = y21[e663];
                            1023 !== i311.format ? null !== p44 ? g21 ? n442.compressedTexSubImage2D(34069 + t, e663, 0, 0, r235.width, r235.height, p44, r235.data) : n442.compressedTexImage2D(34069 + t, e663, f25, r235.width, r235.height, 0, r235.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g21 ? n442.texSubImage2D(34069 + t, e663, 0, 0, r235.width, r235.height, p44, m31, r235.data) : n442.texImage2D(34069 + t, e663, f25, r235.width, r235.height, 0, p44, m31, r235.data);
                        }
                    }
                } else {
                    y21 = i311.mipmaps, g21 && v22 && (y21.length > 0 && x19++, n442.texStorage2D(34067, x19, f25, c62[0].width, c62[0].height));
                    for(let t = 0; t < 6; t++)if (a122) {
                        g21 ? n442.texSubImage2D(34069 + t, 0, 0, 0, c62[t].width, c62[t].height, p44, m31, c62[t].data) : n442.texImage2D(34069 + t, 0, f25, c62[t].width, c62[t].height, 0, p44, m31, c62[t].data);
                        for(let e664 = 0; e664 < y21.length; e664++){
                            const i312 = y21[e664].image[t].image;
                            g21 ? n442.texSubImage2D(34069 + t, e664 + 1, 0, 0, i312.width, i312.height, p44, m31, i312.data) : n442.texImage2D(34069 + t, e664 + 1, f25, i312.width, i312.height, 0, p44, m31, i312.data);
                        }
                    } else {
                        g21 ? n442.texSubImage2D(34069 + t, 0, 0, 0, p44, m31, c62[t]) : n442.texImage2D(34069 + t, 0, f25, p44, m31, c62[t]);
                        for(let e665 = 0; e665 < y21.length; e665++){
                            const i313 = y21[e665];
                            g21 ? n442.texSubImage2D(34069 + t, e665 + 1, 0, 0, p44, m31, i313.image[t]) : n442.texImage2D(34069 + t, e665 + 1, f25, p44, m31, i313.image[t]);
                        }
                    }
                }
                S6(i311, d51) && T6(34067), l97.__currentVersion = l97.version, i311.onUpdate && i311.onUpdate(i311);
            }
            e662.__version = i311.version;
        }(a120, e661, r232) : (n442.activeTexture(33984 + r232), n442.bindTexture(34067, a120.__webglTexture));
    }, this.rebindTextures = function(t, e666, n456) {
        const r236 = i300.get(t);
        void 0 !== e666 && z2(r236.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n456 && V2(t);
    }, this.setupRenderTarget = function(e667) {
        const l98 = e667.texture, h80 = i300.get(e667), c63 = i300.get(l98);
        e667.addEventListener("dispose", L4), !0 !== e667.isWebGLMultipleRenderTargets && (void 0 === c63.__webglTexture && (c63.__webglTexture = t190.createTexture()), c63.__version = l98.version, a111.memory.textures++);
        const u58 = !0 === e667.isWebGLCubeRenderTarget, d52 = !0 === e667.isWebGLMultipleRenderTargets, p45 = M7(e667) || o97;
        if (u58) {
            h80.__webglFramebuffer = [];
            for(let e668 = 0; e668 < 6; e668++)h80.__webglFramebuffer[e668] = t190.createFramebuffer();
        } else if (h80.__webglFramebuffer = t190.createFramebuffer(), d52) {
            if (r210.drawBuffers) {
                const n457 = e667.texture;
                for(let e669 = 0, r237 = n457.length; e669 < r237; e669++){
                    const r238 = i300.get(n457[e669]);
                    void 0 === r238.__webglTexture && (r238.__webglTexture = t190.createTexture(), a111.memory.textures++);
                }
            } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        } else if (o97 && e667.samples > 0 && !1 === W2(e667)) {
            h80.__webglMultisampledFramebuffer = t190.createFramebuffer(), h80.__webglColorRenderbuffer = t190.createRenderbuffer(), t190.bindRenderbuffer(36161, h80.__webglColorRenderbuffer);
            const i314 = s146.convert(l98.format, l98.encoding), r239 = s146.convert(l98.type), a123 = E5(l98.internalFormat, i314, r239, l98.encoding), o102 = G2(e667);
            t190.renderbufferStorageMultisample(36161, o102, a123, e667.width, e667.height), n442.bindFramebuffer(36160, h80.__webglMultisampledFramebuffer), t190.framebufferRenderbuffer(36160, 36064, 36161, h80.__webglColorRenderbuffer), t190.bindRenderbuffer(36161, null), e667.depthBuffer && (h80.__webglDepthRenderbuffer = t190.createRenderbuffer(), H2(h80.__webglDepthRenderbuffer, e667, !0)), n442.bindFramebuffer(36160, null);
        }
        if (u58) {
            n442.bindTexture(34067, c63.__webglTexture), U1(34067, l98, p45);
            for(let t = 0; t < 6; t++)z2(h80.__webglFramebuffer[t], e667, l98, 36064, 34069 + t);
            S6(l98, p45) && T6(34067), n442.unbindTexture();
        } else if (d52) {
            const t = e667.texture;
            for(let r240 = 0, s155 = t.length; r240 < s155; r240++){
                const s156 = t[r240], a124 = i300.get(s156);
                n442.bindTexture(3553, a124.__webglTexture), U1(3553, s156, p45), z2(h80.__webglFramebuffer, e667, s156, 36064 + r240, 3553), S6(s156, p45) && T6(3553);
            }
            n442.unbindTexture();
        } else {
            let t = 3553;
            (e667.isWebGL3DRenderTarget || e667.isWebGLArrayRenderTarget) && (o97 ? t = e667.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n442.bindTexture(t, c63.__webglTexture), U1(t, l98, p45), z2(h80.__webglFramebuffer, e667, l98, 36064, t), S6(l98, p45) && T6(t), n442.unbindTexture();
        }
        e667.depthBuffer && V2(e667);
    }, this.updateRenderTargetMipmap = function(t) {
        const e670 = M7(t) || o97, r241 = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [
            t.texture
        ];
        for(let s157 = 0, a125 = r241.length; s157 < a125; s157++){
            const a126 = r241[s157];
            if (S6(a126, e670)) {
                const e671 = t.isWebGLCubeRenderTarget ? 34067 : 3553, r242 = i300.get(a126).__webglTexture;
                n442.bindTexture(e671, r242), T6(e671), n442.unbindTexture();
            }
        }
    }, this.updateMultisampleRenderTarget = function(e672) {
        if (o97 && e672.samples > 0 && !1 === W2(e672)) {
            const r243 = e672.width, s158 = e672.height;
            let a127 = 16384;
            const o103 = [
                36064
            ], l99 = e672.stencilBuffer ? 33306 : 36096;
            e672.depthBuffer && o103.push(l99);
            const h81 = i300.get(e672), c64 = void 0 !== h81.__ignoreDepthValues && h81.__ignoreDepthValues;
            !1 === c64 && (e672.depthBuffer && (a127 |= 256), e672.stencilBuffer && (a127 |= 1024)), n442.bindFramebuffer(36008, h81.__webglMultisampledFramebuffer), n442.bindFramebuffer(36009, h81.__webglFramebuffer), !0 === c64 && (t190.invalidateFramebuffer(36008, [
                l99
            ]), t190.invalidateFramebuffer(36009, [
                l99
            ])), t190.blitFramebuffer(0, 0, r243, s158, 0, 0, r243, s158, a127, 9728), f23 && t190.invalidateFramebuffer(36008, o103), n442.bindFramebuffer(36008, null), n442.bindFramebuffer(36009, h81.__webglMultisampledFramebuffer);
        }
    }, this.setupDepthRenderbuffer = V2, this.setupFrameBufferTexture = z2, this.useMultisampledRTT = W2;
}
function Er(t193, e673, n458) {
    const i315 = n458.isWebGL2;
    return {
        convert: function(t, n459 = null) {
            let r244;
            if (1009 === t) return 5121;
            if (1017 === t) return 32819;
            if (1018 === t) return 32820;
            if (1010 === t) return 5120;
            if (1011 === t) return 5122;
            if (1012 === t) return 5123;
            if (1013 === t) return 5124;
            if (1014 === t) return 5125;
            if (1015 === t) return 5126;
            if (1016 === t) return i315 ? 5131 : (r244 = e673.get("OES_texture_half_float"), null !== r244 ? r244.HALF_FLOAT_OES : null);
            if (1021 === t) return 6406;
            if (1023 === t) return 6408;
            if (1024 === t) return 6409;
            if (1025 === t) return 6410;
            if (1026 === t) return 6402;
            if (1027 === t) return 34041;
            if (1028 === t) return 6403;
            if (1022 === t) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
            if (1035 === t) return r244 = e673.get("EXT_sRGB"), null !== r244 ? r244.SRGB_ALPHA_EXT : null;
            if (1029 === t) return 36244;
            if (1030 === t) return 33319;
            if (1031 === t) return 33320;
            if (1033 === t) return 36249;
            if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                if (3001 === n459) {
                    if (r244 = e673.get("WEBGL_compressed_texture_s3tc_srgb"), null === r244) return null;
                    if (33776 === t) return r244.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (33777 === t) return r244.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (33778 === t) return r244.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (33779 === t) return r244.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                } else {
                    if (r244 = e673.get("WEBGL_compressed_texture_s3tc"), null === r244) return null;
                    if (33776 === t) return r244.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === t) return r244.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === t) return r244.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === t) return r244.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
            }
            if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                if (r244 = e673.get("WEBGL_compressed_texture_pvrtc"), null === r244) return null;
                if (35840 === t) return r244.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (35841 === t) return r244.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (35842 === t) return r244.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (35843 === t) return r244.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (36196 === t) return r244 = e673.get("WEBGL_compressed_texture_etc1"), null !== r244 ? r244.COMPRESSED_RGB_ETC1_WEBGL : null;
            if (37492 === t || 37496 === t) {
                if (r244 = e673.get("WEBGL_compressed_texture_etc"), null === r244) return null;
                if (37492 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ETC2 : r244.COMPRESSED_RGB8_ETC2;
                if (37496 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r244.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) {
                if (r244 = e673.get("WEBGL_compressed_texture_astc"), null === r244) return null;
                if (37808 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r244.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (37809 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r244.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (37810 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r244.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (37811 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r244.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (37812 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r244.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (37813 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r244.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (37814 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r244.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (37815 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r244.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (37816 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r244.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (37817 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r244.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (37818 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r244.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (37819 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r244.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (37820 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r244.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (37821 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r244.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (36492 === t) {
                if (r244 = e673.get("EXT_texture_compression_bptc"), null === r244) return null;
                if (36492 === t) return 3001 === n459 ? r244.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r244.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            }
            return 1020 === t ? i315 ? 34042 : (r244 = e673.get("WEBGL_depth_texture"), null !== r244 ? r244.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
        }
    };
}
class Ar extends We {
    constructor(t = []){
        super(), this.cameras = t;
    }
}
Ar.prototype.isArrayCamera = !0;
class Rr extends Wt {
    constructor(){
        super(), this.type = "Group";
    }
}
Rr.prototype.isGroup = !0;
const Cr = {
    type: "move"
};
class Lr {
    constructor(){
        this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
        return null === this._hand && (this._hand = new Rr, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand;
    }
    getTargetRaySpace() {
        return null === this._targetRay && (this._targetRay = new Rr, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new V, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new V), this._targetRay;
    }
    getGripSpace() {
        return null === this._grip && (this._grip = new Rr, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new V, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new V), this._grip;
    }
    dispatchEvent(t) {
        return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this;
    }
    disconnect(t) {
        return this.dispatchEvent({
            type: "disconnected",
            data: t
        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this;
    }
    update(t, e674, n460) {
        let i316 = null, r247 = null, s159 = null;
        const a128 = this._targetRay, o105 = this._grip, l100 = this._hand;
        if (t && "visible-blurred" !== e674.session.visibilityState) {
            if (null !== a128 && (i316 = e674.getPose(t.targetRaySpace, n460), null !== i316 && (a128.matrix.fromArray(i316.transform.matrix), a128.matrix.decompose(a128.position, a128.rotation, a128.scale), i316.linearVelocity ? (a128.hasLinearVelocity = !0, a128.linearVelocity.copy(i316.linearVelocity)) : a128.hasLinearVelocity = !1, i316.angularVelocity ? (a128.hasAngularVelocity = !0, a128.angularVelocity.copy(i316.angularVelocity)) : a128.hasAngularVelocity = !1, this.dispatchEvent(Cr))), l100 && t.hand) {
                s159 = !0;
                for (const i318 of t.hand.values()){
                    const t = e674.getJointPose(i318, n460);
                    if (void 0 === l100.joints[i318.jointName]) {
                        const t = new Rr;
                        t.matrixAutoUpdate = !1, t.visible = !1, l100.joints[i318.jointName] = t, l100.add(t);
                    }
                    const r245 = l100.joints[i318.jointName];
                    null !== t && (r245.matrix.fromArray(t.transform.matrix), r245.matrix.decompose(r245.position, r245.rotation, r245.scale), r245.jointRadius = t.radius), r245.visible = null !== t;
                }
                const i317 = l100.joints["index-finger-tip"], r246 = l100.joints["thumb-tip"], a129 = i317.position.distanceTo(r246.position), o104 = .02, h82 = .005;
                l100.inputState.pinching && a129 > o104 + h82 ? (l100.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this
                })) : !l100.inputState.pinching && a129 <= o104 - h82 && (l100.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this
                }));
            } else null !== o105 && t.gripSpace && (r247 = e674.getPose(t.gripSpace, n460), null !== r247 && (o105.matrix.fromArray(r247.transform.matrix), o105.matrix.decompose(o105.position, o105.rotation, o105.scale), r247.linearVelocity ? (o105.hasLinearVelocity = !0, o105.linearVelocity.copy(r247.linearVelocity)) : o105.hasLinearVelocity = !1, r247.angularVelocity ? (o105.hasAngularVelocity = !0, o105.angularVelocity.copy(r247.angularVelocity)) : o105.hasAngularVelocity = !1));
        }
        return null !== a128 && (a128.visible = null !== i316), null !== o105 && (o105.visible = null !== r247), null !== l100 && (l100.visible = null !== s159), this;
    }
}
class Pr extends F {
    constructor(t, e675, n461, i319, r248, s160, a130, o106, l101, h83){
        if (1026 !== (h83 = void 0 !== h83 ? h83 : 1026) && 1027 !== h83) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n461 && 1026 === h83 && (n461 = 1012), void 0 === n461 && 1027 === h83 && (n461 = 1020), super(null, i319, r248, s160, a130, o106, h83, n461, l101), this.image = {
            width: t,
            height: e675
        }, this.magFilter = void 0 !== a130 ? a130 : 1003, this.minFilter = void 0 !== o106 ? o106 : 1003, this.flipY = !1, this.generateMipmaps = !1;
    }
}
Pr.prototype.isDepthTexture = !0;
class Dr extends i {
    constructor(t194, e676){
        super();
        const n462 = this;
        let i320 = null, r249 = 1, s161 = null, a131 = "local-floor", o107 = null, l102 = null, h84 = null, c65 = null, u59 = null;
        const d53 = e676.getContextAttributes();
        let p46 = null, m32 = null;
        const f26 = [], g22 = new Map, v23 = new We;
        v23.layers.enable(1), v23.viewport = new U;
        const y22 = new We;
        y22.layers.enable(2), y22.viewport = new U;
        const x20 = [
            v23,
            y22
        ], b17 = new Ar;
        b17.layers.enable(1), b17.layers.enable(2);
        let _13 = null, w11 = null;
        function M8(t) {
            const e677 = g22.get(t.inputSource);
            e677 && e677.dispatchEvent({
                type: t.type,
                data: t.inputSource
            });
        }
        function S7() {
            g22.forEach(function(t, e678) {
                t.disconnect(e678);
            }), g22.clear(), _13 = null, w11 = null, t194.setRenderTarget(p46), c65 = null, h84 = null, l102 = null, i320 = null, m32 = null, L5.stop(), n462.isPresenting = !1, n462.dispatchEvent({
                type: "sessionend"
            });
        }
        function T7(t) {
            const e681 = i320.inputSources;
            for(let t195 = 0; t195 < f26.length; t195++)g22.set(e681[t195], f26[t195]);
            for(let e679 = 0; e679 < t.removed.length; e679++){
                const n463 = t.removed[e679], i321 = g22.get(n463);
                i321 && (i321.dispatchEvent({
                    type: "disconnected",
                    data: n463
                }), g22.delete(n463));
            }
            for(let e680 = 0; e680 < t.added.length; e680++){
                const n464 = t.added[e680], i322 = g22.get(n464);
                i322 && i322.dispatchEvent({
                    type: "connected",
                    data: n464
                });
            }
        }
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
            let e682 = f26[t];
            return void 0 === e682 && (e682 = new Lr, f26[t] = e682), e682.getTargetRaySpace();
        }, this.getControllerGrip = function(t) {
            let e683 = f26[t];
            return void 0 === e683 && (e683 = new Lr, f26[t] = e683), e683.getGripSpace();
        }, this.getHand = function(t) {
            let e684 = f26[t];
            return void 0 === e684 && (e684 = new Lr, f26[t] = e684), e684.getHandSpace();
        }, this.setFramebufferScaleFactor = function(t) {
            r249 = t, !0 === n462.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }, this.setReferenceSpaceType = function(t) {
            a131 = t, !0 === n462.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }, this.getReferenceSpace = function() {
            return s161;
        }, this.getBaseLayer = function() {
            return null !== h84 ? h84 : c65;
        }, this.getBinding = function() {
            return l102;
        }, this.getFrame = function() {
            return u59;
        }, this.getSession = function() {
            return i320;
        }, this.setSession = async function(o108) {
            if (i320 = o108, null !== i320) {
                if (p46 = t194.getRenderTarget(), i320.addEventListener("select", M8), i320.addEventListener("selectstart", M8), i320.addEventListener("selectend", M8), i320.addEventListener("squeeze", M8), i320.addEventListener("squeezestart", M8), i320.addEventListener("squeezeend", M8), i320.addEventListener("end", S7), i320.addEventListener("inputsourceschange", T7), !0 !== d53.xrCompatible && await e676.makeXRCompatible(), void 0 === i320.renderState.layers || !1 === t194.capabilities.isWebGL2) {
                    const n465 = {
                        antialias: void 0 !== i320.renderState.layers || d53.antialias,
                        alpha: d53.alpha,
                        depth: d53.depth,
                        stencil: d53.stencil,
                        framebufferScaleFactor: r249
                    };
                    c65 = new XRWebGLLayer(i320, e676, n465), i320.updateRenderState({
                        baseLayer: c65
                    }), m32 = new k(c65.framebufferWidth, c65.framebufferHeight, {
                        format: 1023,
                        type: 1009,
                        encoding: t194.outputEncoding
                    });
                } else {
                    let n466 = null, s162 = null, a132 = null;
                    d53.depth && (a132 = d53.stencil ? 35056 : 33190, n466 = d53.stencil ? 1027 : 1026, s162 = d53.stencil ? 1020 : 1012);
                    const o109 = {
                        colorFormat: 3001 === t194.outputEncoding ? 35907 : 32856,
                        depthFormat: a132,
                        scaleFactor: r249
                    };
                    l102 = new XRWebGLBinding(i320, e676), h84 = l102.createProjectionLayer(o109), i320.updateRenderState({
                        layers: [
                            h84
                        ]
                    }), m32 = new k(h84.textureWidth, h84.textureHeight, {
                        format: 1023,
                        type: 1009,
                        depthTexture: new Pr(h84.textureWidth, h84.textureHeight, s162, void 0, void 0, void 0, void 0, void 0, void 0, n466),
                        stencilBuffer: d53.stencil,
                        encoding: t194.outputEncoding,
                        samples: d53.antialias ? 4 : 0
                    });
                    t194.properties.get(m32).__ignoreDepthValues = h84.ignoreDepthValues;
                }
                m32.isXRRenderTarget = !0, this.setFoveation(1), s161 = await i320.requestReferenceSpace(a131), L5.setContext(i320), L5.start(), n462.isPresenting = !0, n462.dispatchEvent({
                    type: "sessionstart"
                });
            }
        };
        const E6 = new V, A6 = new V;
        function R5(t, e685) {
            null === e685 ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e685.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert();
        }
        this.updateCamera = function(t198) {
            if (null === i320) return;
            b17.near = y22.near = v23.near = t198.near, b17.far = y22.far = v23.far = t198.far, _13 === b17.near && w11 === b17.far || (i320.updateRenderState({
                depthNear: b17.near,
                depthFar: b17.far
            }), _13 = b17.near, w11 = b17.far);
            const e687 = t198.parent, n467 = b17.cameras;
            R5(b17, e687);
            for(let t196 = 0; t196 < n467.length; t196++)R5(n467[t196], e687);
            b17.matrixWorld.decompose(b17.position, b17.quaternion, b17.scale), t198.position.copy(b17.position), t198.quaternion.copy(b17.quaternion), t198.scale.copy(b17.scale), t198.matrix.copy(b17.matrix), t198.matrixWorld.copy(b17.matrixWorld);
            const r250 = t198.children;
            for(let t197 = 0, e686 = r250.length; t197 < e686; t197++)r250[t197].updateMatrixWorld(!0);
            2 === n467.length ? function(t, e688, n468) {
                E6.setFromMatrixPosition(e688.matrixWorld), A6.setFromMatrixPosition(n468.matrixWorld);
                const i323 = E6.distanceTo(A6), r251 = e688.projectionMatrix.elements, s163 = n468.projectionMatrix.elements, a133 = r251[14] / (r251[10] - 1), o110 = r251[14] / (r251[10] + 1), l103 = (r251[9] + 1) / r251[5], h85 = (r251[9] - 1) / r251[5], c66 = (r251[8] - 1) / r251[0], u60 = (s163[8] + 1) / s163[0], d54 = a133 * c66, p47 = a133 * u60, m33 = i323 / (-c66 + u60), f27 = m33 * -c66;
                e688.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f27), t.translateZ(m33), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                const g23 = a133 + m33, v24 = o110 + m33, y23 = d54 - f27, x21 = p47 + (i323 - f27), b18 = l103 * o110 / v24 * g23, _14 = h85 * o110 / v24 * g23;
                t.projectionMatrix.makePerspective(y23, x21, b18, _14, g23, v24);
            }(b17, v23, y22) : b17.projectionMatrix.copy(v23.projectionMatrix);
        }, this.getCamera = function() {
            return b17;
        }, this.getFoveation = function() {
            return null !== h84 ? h84.fixedFoveation : null !== c65 ? c65.fixedFoveation : void 0;
        }, this.setFoveation = function(t) {
            null !== h84 && (h84.fixedFoveation = t), null !== c65 && void 0 !== c65.fixedFoveation && (c65.fixedFoveation = t);
        };
        let C5 = null;
        const L5 = new en;
        L5.setAnimationLoop(function(e692, n469) {
            if (o107 = n469.getViewerPose(s161), u59 = n469, null !== o107) {
                const e689 = o107.views;
                null !== c65 && (t194.setRenderTargetFramebuffer(m32, c65.framebuffer), t194.setRenderTarget(m32));
                let n470 = !1;
                e689.length !== b17.cameras.length && (b17.cameras.length = 0, n470 = !0);
                for(let i324 = 0; i324 < e689.length; i324++){
                    const r252 = e689[i324];
                    let s164 = null;
                    if (null !== c65) s164 = c65.getViewport(r252);
                    else {
                        const e690 = l102.getViewSubImage(h84, r252);
                        s164 = e690.viewport, 0 === i324 && (t194.setRenderTargetTextures(m32, e690.colorTexture, h84.ignoreDepthValues ? void 0 : e690.depthStencilTexture), t194.setRenderTarget(m32));
                    }
                    const a134 = x20[i324];
                    a134.matrix.fromArray(r252.transform.matrix), a134.projectionMatrix.fromArray(r252.projectionMatrix), a134.viewport.set(s164.x, s164.y, s164.width, s164.height), 0 === i324 && b17.matrix.copy(a134.matrix), !0 === n470 && b17.cameras.push(a134);
                }
            }
            const r253 = i320.inputSources;
            for(let t = 0; t < f26.length; t++){
                const e691 = f26[t], i325 = r253[t];
                e691.update(i325, n469, s161);
            }
            C5 && C5(e692, n469), u59 = null;
        }), this.setAnimationLoop = function(t) {
            C5 = t;
        }, this.dispose = function() {};
    }
}
function Ir(t199, e693) {
    function n471(n472, i326) {
        n472.opacity.value = i326.opacity, i326.color && n472.diffuse.value.copy(i326.color), i326.emissive && n472.emissive.value.copy(i326.emissive).multiplyScalar(i326.emissiveIntensity), i326.map && (n472.map.value = i326.map), i326.alphaMap && (n472.alphaMap.value = i326.alphaMap), i326.bumpMap && (n472.bumpMap.value = i326.bumpMap, n472.bumpScale.value = i326.bumpScale, 1 === i326.side && (n472.bumpScale.value *= -1)), i326.displacementMap && (n472.displacementMap.value = i326.displacementMap, n472.displacementScale.value = i326.displacementScale, n472.displacementBias.value = i326.displacementBias), i326.emissiveMap && (n472.emissiveMap.value = i326.emissiveMap), i326.normalMap && (n472.normalMap.value = i326.normalMap, n472.normalScale.value.copy(i326.normalScale), 1 === i326.side && n472.normalScale.value.negate()), i326.specularMap && (n472.specularMap.value = i326.specularMap), i326.alphaTest > 0 && (n472.alphaTest.value = i326.alphaTest);
        const r254 = e693.get(i326).envMap;
        if (r254 && (n472.envMap.value = r254, n472.flipEnvMap.value = r254.isCubeTexture && !1 === r254.isRenderTargetTexture ? -1 : 1, n472.reflectivity.value = i326.reflectivity, n472.ior.value = i326.ior, n472.refractionRatio.value = i326.refractionRatio), i326.lightMap) {
            n472.lightMap.value = i326.lightMap;
            const e694 = !0 !== t199.physicallyCorrectLights ? Math.PI : 1;
            n472.lightMapIntensity.value = i326.lightMapIntensity * e694;
        }
        let s165, a135;
        i326.aoMap && (n472.aoMap.value = i326.aoMap, n472.aoMapIntensity.value = i326.aoMapIntensity), i326.map ? s165 = i326.map : i326.specularMap ? s165 = i326.specularMap : i326.displacementMap ? s165 = i326.displacementMap : i326.normalMap ? s165 = i326.normalMap : i326.bumpMap ? s165 = i326.bumpMap : i326.roughnessMap ? s165 = i326.roughnessMap : i326.metalnessMap ? s165 = i326.metalnessMap : i326.alphaMap ? s165 = i326.alphaMap : i326.emissiveMap ? s165 = i326.emissiveMap : i326.clearcoatMap ? s165 = i326.clearcoatMap : i326.clearcoatNormalMap ? s165 = i326.clearcoatNormalMap : i326.clearcoatRoughnessMap ? s165 = i326.clearcoatRoughnessMap : i326.specularIntensityMap ? s165 = i326.specularIntensityMap : i326.specularColorMap ? s165 = i326.specularColorMap : i326.transmissionMap ? s165 = i326.transmissionMap : i326.thicknessMap ? s165 = i326.thicknessMap : i326.sheenColorMap ? s165 = i326.sheenColorMap : i326.sheenRoughnessMap && (s165 = i326.sheenRoughnessMap), void 0 !== s165 && (s165.isWebGLRenderTarget && (s165 = s165.texture), !0 === s165.matrixAutoUpdate && s165.updateMatrix(), n472.uvTransform.value.copy(s165.matrix)), i326.aoMap ? a135 = i326.aoMap : i326.lightMap && (a135 = i326.lightMap), void 0 !== a135 && (a135.isWebGLRenderTarget && (a135 = a135.texture), !0 === a135.matrixAutoUpdate && a135.updateMatrix(), n472.uv2Transform.value.copy(a135.matrix));
    }
    return {
        refreshFogUniforms: function(t, e695) {
            t.fogColor.value.copy(e695.color), e695.isFog ? (t.fogNear.value = e695.near, t.fogFar.value = e695.far) : e695.isFogExp2 && (t.fogDensity.value = e695.density);
        },
        refreshMaterialUniforms: function(t200, i327, r255, s166, a136) {
            i327.isMeshBasicMaterial || i327.isMeshLambertMaterial ? n471(t200, i327) : i327.isMeshToonMaterial ? (n471(t200, i327), function(t, e696) {
                e696.gradientMap && (t.gradientMap.value = e696.gradientMap);
            }(t200, i327)) : i327.isMeshPhongMaterial ? (n471(t200, i327), function(t, e697) {
                t.specular.value.copy(e697.specular), t.shininess.value = Math.max(e697.shininess, 1e-4);
            }(t200, i327)) : i327.isMeshStandardMaterial ? (n471(t200, i327), function(t, n473) {
                t.roughness.value = n473.roughness, t.metalness.value = n473.metalness, n473.roughnessMap && (t.roughnessMap.value = n473.roughnessMap);
                n473.metalnessMap && (t.metalnessMap.value = n473.metalnessMap);
                e693.get(n473).envMap && (t.envMapIntensity.value = n473.envMapIntensity);
            }(t200, i327), i327.isMeshPhysicalMaterial && function(t, e698, n474) {
                t.ior.value = e698.ior, e698.sheen > 0 && (t.sheenColor.value.copy(e698.sheenColor).multiplyScalar(e698.sheen), t.sheenRoughness.value = e698.sheenRoughness, e698.sheenColorMap && (t.sheenColorMap.value = e698.sheenColorMap), e698.sheenRoughnessMap && (t.sheenRoughnessMap.value = e698.sheenRoughnessMap));
                e698.clearcoat > 0 && (t.clearcoat.value = e698.clearcoat, t.clearcoatRoughness.value = e698.clearcoatRoughness, e698.clearcoatMap && (t.clearcoatMap.value = e698.clearcoatMap), e698.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e698.clearcoatRoughnessMap), e698.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e698.clearcoatNormalScale), t.clearcoatNormalMap.value = e698.clearcoatNormalMap, 1 === e698.side && t.clearcoatNormalScale.value.negate()));
                e698.transmission > 0 && (t.transmission.value = e698.transmission, t.transmissionSamplerMap.value = n474.texture, t.transmissionSamplerSize.value.set(n474.width, n474.height), e698.transmissionMap && (t.transmissionMap.value = e698.transmissionMap), t.thickness.value = e698.thickness, e698.thicknessMap && (t.thicknessMap.value = e698.thicknessMap), t.attenuationDistance.value = e698.attenuationDistance, t.attenuationColor.value.copy(e698.attenuationColor));
                t.specularIntensity.value = e698.specularIntensity, t.specularColor.value.copy(e698.specularColor), e698.specularIntensityMap && (t.specularIntensityMap.value = e698.specularIntensityMap);
                e698.specularColorMap && (t.specularColorMap.value = e698.specularColorMap);
            }(t200, i327, a136)) : i327.isMeshMatcapMaterial ? (n471(t200, i327), function(t, e699) {
                e699.matcap && (t.matcap.value = e699.matcap);
            }(t200, i327)) : i327.isMeshDepthMaterial ? n471(t200, i327) : i327.isMeshDistanceMaterial ? (n471(t200, i327), function(t, e700) {
                t.referencePosition.value.copy(e700.referencePosition), t.nearDistance.value = e700.nearDistance, t.farDistance.value = e700.farDistance;
            }(t200, i327)) : i327.isMeshNormalMaterial ? n471(t200, i327) : i327.isLineBasicMaterial ? (function(t, e701) {
                t.diffuse.value.copy(e701.color), t.opacity.value = e701.opacity;
            }(t200, i327), i327.isLineDashedMaterial && function(t, e702) {
                t.dashSize.value = e702.dashSize, t.totalSize.value = e702.dashSize + e702.gapSize, t.scale.value = e702.scale;
            }(t200, i327)) : i327.isPointsMaterial ? function(t, e703, n475, i328) {
                t.diffuse.value.copy(e703.color), t.opacity.value = e703.opacity, t.size.value = e703.size * n475, t.scale.value = .5 * i328, e703.map && (t.map.value = e703.map);
                e703.alphaMap && (t.alphaMap.value = e703.alphaMap);
                e703.alphaTest > 0 && (t.alphaTest.value = e703.alphaTest);
                let r256;
                e703.map ? r256 = e703.map : e703.alphaMap && (r256 = e703.alphaMap);
                void 0 !== r256 && (!0 === r256.matrixAutoUpdate && r256.updateMatrix(), t.uvTransform.value.copy(r256.matrix));
            }(t200, i327, r255, s166) : i327.isSpriteMaterial ? function(t, e704) {
                t.diffuse.value.copy(e704.color), t.opacity.value = e704.opacity, t.rotation.value = e704.rotation, e704.map && (t.map.value = e704.map);
                e704.alphaMap && (t.alphaMap.value = e704.alphaMap);
                e704.alphaTest > 0 && (t.alphaTest.value = e704.alphaTest);
                let n476;
                e704.map ? n476 = e704.map : e704.alphaMap && (n476 = e704.alphaMap);
                void 0 !== n476 && (!0 === n476.matrixAutoUpdate && n476.updateMatrix(), t.uvTransform.value.copy(n476.matrix));
            }(t200, i327) : i327.isShadowMaterial ? (t200.color.value.copy(i327.color), t200.opacity.value = i327.opacity) : i327.isShaderMaterial && (i327.uniformsNeedUpdate = !1);
        }
    };
}
function Or(t201 = {}) {
    const e705 = void 0 !== t201.canvas ? t201.canvas : function() {
        const t = x("canvas");
        return t.style.display = "block", t;
    }(), n477 = void 0 !== t201.context ? t201.context : null, i329 = void 0 === t201.depth || t201.depth, r257 = void 0 === t201.stencil || t201.stencil, s167 = void 0 !== t201.antialias && t201.antialias, a137 = void 0 === t201.premultipliedAlpha || t201.premultipliedAlpha, o111 = void 0 !== t201.preserveDrawingBuffer && t201.preserveDrawingBuffer, l104 = void 0 !== t201.powerPreference ? t201.powerPreference : "default", h86 = void 0 !== t201.failIfMajorPerformanceCaveat && t201.failIfMajorPerformanceCaveat;
    let c67;
    c67 = void 0 !== t201.context ? n477.getContextAttributes().alpha : void 0 !== t201.alpha && t201.alpha;
    let u61 = null, d55 = null;
    const p48 = [], f28 = [];
    this.domElement = e705, this.debug = {
        checkShaderErrors: !0
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = 3e3, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
    const v25 = this;
    let y24 = !1, b19 = 0, _15 = 0, w12 = null, M9 = -1, S8 = null;
    const T8 = new U, E7 = new U;
    let A7 = null, R6 = e705.width, C6 = e705.height, L6 = 1, P5 = null, D4 = null;
    const I5 = new U(0, 0, R6, C6), O5 = new U(0, 0, R6, C6);
    let N5 = !1;
    const F4 = new tn;
    let B3 = !1, z3 = !1, H3 = null;
    const G3 = new xt, W3 = new g, j3 = new V, q2 = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function X2() {
        return null === w12 ? L6 : 1;
    }
    let $1, Y1, J1, K1, Z1, Q1, tt1, et1, nt1, it1, rt1, st1, at1, ot1, lt1, ht1, ct1, ut1, dt1, pt1, mt1, ft1, gt1, vt1 = n477;
    function yt1(t, n478) {
        for(let i330 = 0; i330 < t.length; i330++){
            const r258 = t[i330], s168 = e705.getContext(r258, n478);
            if (null !== s168) return s168;
        }
        return null;
    }
    try {
        const t = {
            alpha: !0,
            depth: i329,
            stencil: r257,
            antialias: s167,
            premultipliedAlpha: a137,
            preserveDrawingBuffer: o111,
            powerPreference: l104,
            failIfMajorPerformanceCaveat: h86
        };
        if ("setAttribute" in e705 && e705.setAttribute("data-engine", "three.js r139"), e705.addEventListener("webglcontextlost", wt1, !1), e705.addEventListener("webglcontextrestored", Mt1, !1), null === vt1) {
            const e706 = [
                "webgl2",
                "webgl",
                "experimental-webgl"
            ];
            if (!0 === v25.isWebGL1Renderer && e706.shift(), vt1 = yt1(e706, t), null === vt1) throw yt1(e706) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
        }
        void 0 === vt1.getShaderPrecisionFormat && (vt1.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            };
        });
    } catch (t202) {
        throw console.error("THREE.WebGLRenderer: " + t202.message), t202;
    }
    function bt1() {
        $1 = new Cn(vt1), Y1 = new un(vt1, $1, t201), $1.init(Y1), ft1 = new Er(vt1, $1, Y1), J1 = new Sr(vt1, $1, Y1), K1 = new Dn(vt1), Z1 = new cr, Q1 = new Tr(vt1, $1, J1, Z1, Y1, ft1, K1), tt1 = new pn(v25), et1 = new Rn(v25), nt1 = new nn(vt1, Y1), gt1 = new hn(vt1, $1, nt1, Y1), it1 = new Ln(vt1, nt1, K1, gt1), rt1 = new Un(vt1, it1, nt1, K1), dt1 = new Fn(vt1, Y1, Q1), ht1 = new dn(Z1), st1 = new hr(v25, tt1, et1, $1, Y1, gt1, ht1), at1 = new Ir(v25, Z1), ot1 = new mr, lt1 = new br($1, Y1), ut1 = new ln(v25, tt1, J1, rt1, c67, a137), ct1 = new Mr(v25, rt1, Y1), pt1 = new cn(vt1, $1, K1, Y1), mt1 = new Pn(vt1, $1, K1, Y1), K1.programs = st1.programs, v25.capabilities = Y1, v25.extensions = $1, v25.properties = Z1, v25.renderLists = ot1, v25.shadowMap = ct1, v25.state = J1, v25.info = K1;
    }
    bt1();
    const _t1 = new Dr(v25, vt1);
    function wt1(t) {
        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y24 = !0;
    }
    function Mt1() {
        console.log("THREE.WebGLRenderer: Context Restored."), y24 = !1;
        const t = K1.autoReset, e707 = ct1.enabled, n479 = ct1.autoUpdate, i331 = ct1.needsUpdate, r259 = ct1.type;
        bt1(), K1.autoReset = t, ct1.enabled = e707, ct1.autoUpdate = n479, ct1.needsUpdate = i331, ct1.type = r259;
    }
    function St1(t203) {
        const e708 = t203.target;
        e708.removeEventListener("dispose", St1), function(t204) {
            (function(t205) {
                const e709 = Z1.get(t205).programs;
                void 0 !== e709 && (e709.forEach(function(t) {
                    st1.releaseProgram(t);
                }), t205.isShaderMaterial && st1.releaseShaderCache(t205));
            })(t204), Z1.remove(t204);
        }(e708);
    }
    this.xr = _t1, this.getContext = function() {
        return vt1;
    }, this.getContextAttributes = function() {
        return vt1.getContextAttributes();
    }, this.forceContextLoss = function() {
        const t = $1.get("WEBGL_lose_context");
        t && t.loseContext();
    }, this.forceContextRestore = function() {
        const t = $1.get("WEBGL_lose_context");
        t && t.restoreContext();
    }, this.getPixelRatio = function() {
        return L6;
    }, this.setPixelRatio = function(t) {
        void 0 !== t && (L6 = t, this.setSize(R6, C6, !1));
    }, this.getSize = function(t) {
        return t.set(R6, C6);
    }, this.setSize = function(t, n480, i332) {
        _t1.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (R6 = t, C6 = n480, e705.width = Math.floor(t * L6), e705.height = Math.floor(n480 * L6), !1 !== i332 && (e705.style.width = t + "px", e705.style.height = n480 + "px"), this.setViewport(0, 0, t, n480));
    }, this.getDrawingBufferSize = function(t) {
        return t.set(R6 * L6, C6 * L6).floor();
    }, this.setDrawingBufferSize = function(t, n481, i333) {
        R6 = t, C6 = n481, L6 = i333, e705.width = Math.floor(t * i333), e705.height = Math.floor(n481 * i333), this.setViewport(0, 0, t, n481);
    }, this.getCurrentViewport = function(t) {
        return t.copy(T8);
    }, this.getViewport = function(t) {
        return t.copy(I5);
    }, this.setViewport = function(t, e710, n482, i334) {
        t.isVector4 ? I5.set(t.x, t.y, t.z, t.w) : I5.set(t, e710, n482, i334), J1.viewport(T8.copy(I5).multiplyScalar(L6).floor());
    }, this.getScissor = function(t) {
        return t.copy(O5);
    }, this.setScissor = function(t, e711, n483, i335) {
        t.isVector4 ? O5.set(t.x, t.y, t.z, t.w) : O5.set(t, e711, n483, i335), J1.scissor(E7.copy(O5).multiplyScalar(L6).floor());
    }, this.getScissorTest = function() {
        return N5;
    }, this.setScissorTest = function(t) {
        J1.setScissorTest(N5 = t);
    }, this.setOpaqueSort = function(t) {
        P5 = t;
    }, this.setTransparentSort = function(t) {
        D4 = t;
    }, this.getClearColor = function(t) {
        return t.copy(ut1.getClearColor());
    }, this.setClearColor = function() {
        ut1.setClearColor.apply(ut1, arguments);
    }, this.getClearAlpha = function() {
        return ut1.getClearAlpha();
    }, this.setClearAlpha = function() {
        ut1.setClearAlpha.apply(ut1, arguments);
    }, this.clear = function(t = !0, e712 = !0, n484 = !0) {
        let i336 = 0;
        t && (i336 |= 16384), e712 && (i336 |= 256), n484 && (i336 |= 1024), vt1.clear(i336);
    }, this.clearColor = function() {
        this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
        this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
        this.clear(!1, !1, !0);
    }, this.dispose = function() {
        e705.removeEventListener("webglcontextlost", wt1, !1), e705.removeEventListener("webglcontextrestored", Mt1, !1), ot1.dispose(), lt1.dispose(), Z1.dispose(), tt1.dispose(), et1.dispose(), rt1.dispose(), gt1.dispose(), st1.dispose(), _t1.dispose(), _t1.removeEventListener("sessionstart", Et1), _t1.removeEventListener("sessionend", At1), H3 && (H3.dispose(), H3 = null), Rt1.stop();
    }, this.renderBufferDirect = function(t206, e713, n485, i337, r260, s169) {
        null === e713 && (e713 = q2);
        const a138 = r260.isMesh && r260.matrixWorld.determinant() < 0, o112 = function(t, e714, n486, i338, r261) {
            !0 !== e714.isScene && (e714 = q2);
            Q1.resetTextureUnits();
            const s170 = e714.fog, a139 = i338.isMeshStandardMaterial ? e714.environment : null, o113 = null === w12 ? v25.outputEncoding : !0 === w12.isXRRenderTarget ? w12.texture.encoding : 3e3, l106 = (i338.isMeshStandardMaterial ? et1 : tt1).get(i338.envMap || a139), h88 = !0 === i338.vertexColors && !!n486.attributes.color && 4 === n486.attributes.color.itemSize, c69 = !!i338.normalMap && !!n486.attributes.tangent, u63 = !!n486.morphAttributes.position, p50 = !!n486.morphAttributes.normal, m35 = !!n486.morphAttributes.color, f30 = i338.toneMapped ? v25.toneMapping : 0, g25 = n486.morphAttributes.position || n486.morphAttributes.normal || n486.morphAttributes.color, y26 = void 0 !== g25 ? g25.length : 0, x23 = Z1.get(i338), b21 = d55.state.lights;
            if (!0 === B3 && (!0 === z3 || t !== S8)) {
                const e715 = t === S8 && i338.id === M9;
                ht1.setState(i338, t, e715);
            }
            let _17 = !1;
            i338.version === x23.__version ? x23.needsLights && x23.lightsStateVersion !== b21.state.version || x23.outputEncoding !== o113 || r261.isInstancedMesh && !1 === x23.instancing ? _17 = !0 : r261.isInstancedMesh || !0 !== x23.instancing ? r261.isSkinnedMesh && !1 === x23.skinning ? _17 = !0 : r261.isSkinnedMesh || !0 !== x23.skinning ? x23.envMap !== l106 || i338.fog && x23.fog !== s170 ? _17 = !0 : void 0 === x23.numClippingPlanes || x23.numClippingPlanes === ht1.numPlanes && x23.numIntersection === ht1.numIntersection ? (x23.vertexAlphas !== h88 || x23.vertexTangents !== c69 || x23.morphTargets !== u63 || x23.morphNormals !== p50 || x23.morphColors !== m35 || x23.toneMapping !== f30 || !0 === Y1.isWebGL2 && x23.morphTargetsCount !== y26) && (_17 = !0) : _17 = !0 : _17 = !0 : _17 = !0 : (_17 = !0, x23.__version = i338.version);
            let T10 = x23.currentProgram;
            !0 === _17 && (T10 = It1(i338, e714, r261));
            let E8 = !1, A8 = !1, R7 = !1;
            const P6 = T10.getUniforms(), D5 = x23.uniforms;
            J1.useProgram(T10.program) && (E8 = !0, A8 = !0, R7 = !0);
            i338.id !== M9 && (M9 = i338.id, A8 = !0);
            if (E8 || S8 !== t) {
                if (P6.setValue(vt1, "projectionMatrix", t.projectionMatrix), Y1.logarithmicDepthBuffer && P6.setValue(vt1, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), S8 !== t && (S8 = t, A8 = !0, R7 = !0), i338.isShaderMaterial || i338.isMeshPhongMaterial || i338.isMeshToonMaterial || i338.isMeshStandardMaterial || i338.envMap) {
                    const e716 = P6.map.cameraPosition;
                    void 0 !== e716 && e716.setValue(vt1, j3.setFromMatrixPosition(t.matrixWorld));
                }
                (i338.isMeshPhongMaterial || i338.isMeshToonMaterial || i338.isMeshLambertMaterial || i338.isMeshBasicMaterial || i338.isMeshStandardMaterial || i338.isShaderMaterial) && P6.setValue(vt1, "isOrthographic", !0 === t.isOrthographicCamera), (i338.isMeshPhongMaterial || i338.isMeshToonMaterial || i338.isMeshLambertMaterial || i338.isMeshBasicMaterial || i338.isMeshStandardMaterial || i338.isShaderMaterial || i338.isShadowMaterial || r261.isSkinnedMesh) && P6.setValue(vt1, "viewMatrix", t.matrixWorldInverse);
            }
            if (r261.isSkinnedMesh) {
                P6.setOptional(vt1, r261, "bindMatrix"), P6.setOptional(vt1, r261, "bindMatrixInverse");
                const t = r261.skeleton;
                t && (Y1.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), P6.setValue(vt1, "boneTexture", t.boneTexture, Q1), P6.setValue(vt1, "boneTextureSize", t.boneTextureSize)) : P6.setOptional(vt1, t, "boneMatrices"));
            }
            const I6 = n486.morphAttributes;
            (void 0 !== I6.position || void 0 !== I6.normal || void 0 !== I6.color && !0 === Y1.isWebGL2) && dt1.update(r261, n486, i338, T10);
            (A8 || x23.receiveShadow !== r261.receiveShadow) && (x23.receiveShadow = r261.receiveShadow, P6.setValue(vt1, "receiveShadow", r261.receiveShadow));
            A8 && (P6.setValue(vt1, "toneMappingExposure", v25.toneMappingExposure), x23.needsLights && (N6 = R7, (O6 = D5).ambientLightColor.needsUpdate = N6, O6.lightProbe.needsUpdate = N6, O6.directionalLights.needsUpdate = N6, O6.directionalLightShadows.needsUpdate = N6, O6.pointLights.needsUpdate = N6, O6.pointLightShadows.needsUpdate = N6, O6.spotLights.needsUpdate = N6, O6.spotLightShadows.needsUpdate = N6, O6.rectAreaLights.needsUpdate = N6, O6.hemisphereLights.needsUpdate = N6), s170 && i338.fog && at1.refreshFogUniforms(D5, s170), at1.refreshMaterialUniforms(D5, i338, L6, C6, H3), Hi.upload(vt1, x23.uniformsList, D5, Q1));
            var O6, N6;
            i338.isShaderMaterial && !0 === i338.uniformsNeedUpdate && (Hi.upload(vt1, x23.uniformsList, D5, Q1), i338.uniformsNeedUpdate = !1);
            i338.isSpriteMaterial && P6.setValue(vt1, "center", r261.center);
            return P6.setValue(vt1, "modelViewMatrix", r261.modelViewMatrix), P6.setValue(vt1, "normalMatrix", r261.normalMatrix), P6.setValue(vt1, "modelMatrix", r261.matrixWorld), T10;
        }(t206, e713, n485, i337, r260);
        J1.setMaterial(i337, a138);
        let l105 = n485.index;
        const h87 = n485.attributes.position;
        if (null === l105) {
            if (void 0 === h87 || 0 === h87.count) return;
        } else if (0 === l105.count) return;
        let c68, u62 = 1;
        !0 === i337.wireframe && (l105 = it1.getWireframeAttribute(n485), u62 = 2), gt1.setup(r260, i337, o112, n485, l105);
        let p49 = pt1;
        null !== l105 && (c68 = nt1.get(l105), p49 = mt1, p49.setIndex(c68));
        const m34 = null !== l105 ? l105.count : h87.count, f29 = n485.drawRange.start * u62, g24 = n485.drawRange.count * u62, y25 = null !== s169 ? s169.start * u62 : 0, x22 = null !== s169 ? s169.count * u62 : 1 / 0, b20 = Math.max(f29, y25), _16 = Math.min(m34, f29 + g24, y25 + x22) - 1, T9 = Math.max(0, _16 - b20 + 1);
        if (0 !== T9) {
            if (r260.isMesh) !0 === i337.wireframe ? (J1.setLineWidth(i337.wireframeLinewidth * X2()), p49.setMode(1)) : p49.setMode(4);
            else if (r260.isLine) {
                let t = i337.linewidth;
                void 0 === t && (t = 1), J1.setLineWidth(t * X2()), r260.isLineSegments ? p49.setMode(1) : r260.isLineLoop ? p49.setMode(2) : p49.setMode(3);
            } else r260.isPoints ? p49.setMode(0) : r260.isSprite && p49.setMode(4);
            if (r260.isInstancedMesh) p49.renderInstances(b20, T9, r260.count);
            else if (n485.isInstancedBufferGeometry) {
                const t = Math.min(n485.instanceCount, n485._maxInstanceCount);
                p49.renderInstances(b20, T9, t);
            } else p49.render(b20, T9);
        }
    }, this.compile = function(t207, e717) {
        d55 = lt1.get(t207), d55.init(), f28.push(d55), t207.traverseVisible(function(t) {
            t.isLight && t.layers.test(e717.layers) && (d55.pushLight(t), t.castShadow && d55.pushShadow(t));
        }), d55.setupLights(v25.physicallyCorrectLights), t207.traverse(function(e718) {
            const n487 = e718.material;
            if (n487) {
                if (Array.isArray(n487)) for(let i339 = 0; i339 < n487.length; i339++)It1(n487[i339], t207, e718);
                else It1(n487, t207, e718);
            }
        }), f28.pop(), d55 = null;
    };
    let Tt1 = null;
    function Et1() {
        Rt1.stop();
    }
    function At1() {
        Rt1.start();
    }
    const Rt1 = new en;
    function Ct1(t, e719, n488, i340) {
        if (!1 === t.visible) return;
        if (t.layers.test(e719.layers)) {
            if (t.isGroup) n488 = t.renderOrder;
            else if (t.isLOD) !0 === t.autoUpdate && t.update(e719);
            else if (t.isLight) d55.pushLight(t), t.castShadow && d55.pushShadow(t);
            else if (t.isSprite) {
                if (!t.frustumCulled || F4.intersectsSprite(t)) {
                    i340 && j3.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G3);
                    const e720 = rt1.update(t), r262 = t.material;
                    r262.visible && u61.push(t, e720, r262, n488, j3.z, null);
                }
            } else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== K1.render.frame && (t.skeleton.update(), t.skeleton.frame = K1.render.frame), !t.frustumCulled || F4.intersectsObject(t))) {
                i340 && j3.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G3);
                const e721 = rt1.update(t), r263 = t.material;
                if (Array.isArray(r263)) {
                    const i341 = e721.groups;
                    for(let s171 = 0, a140 = i341.length; s171 < a140; s171++){
                        const a141 = i341[s171], o114 = r263[a141.materialIndex];
                        o114 && o114.visible && u61.push(t, e721, o114, n488, j3.z, a141);
                    }
                } else r263.visible && u61.push(t, e721, r263, n488, j3.z, null);
            }
        }
        const r264 = t.children;
        for(let t208 = 0, s172 = r264.length; t208 < s172; t208++)Ct1(r264[t208], e719, n488, i340);
    }
    function Lt1(t209, e722, n489, i342) {
        const r265 = t209.opaque, a142 = t209.transmissive, o115 = t209.transparent;
        d55.setupLightsView(n489), a142.length > 0 && function(t, e723, n490) {
            const i343 = Y1.isWebGL2;
            null === H3 && (H3 = new k(1, 1, {
                generateMipmaps: !0,
                type: null !== ft1.convert(1016) ? 1016 : 1009,
                minFilter: 1008,
                samples: i343 && !0 === s167 ? 4 : 0
            }));
            v25.getDrawingBufferSize(W3), i343 ? H3.setSize(W3.x, W3.y) : H3.setSize(m(W3.x), m(W3.y));
            const r266 = v25.getRenderTarget();
            v25.setRenderTarget(H3), v25.clear();
            const a143 = v25.toneMapping;
            v25.toneMapping = 0, Pt1(t, e723, n490), v25.toneMapping = a143, Q1.updateMultisampleRenderTarget(H3), Q1.updateRenderTargetMipmap(H3), v25.setRenderTarget(r266);
        }(r265, e722, n489), i342 && J1.viewport(T8.copy(i342)), r265.length > 0 && Pt1(r265, e722, n489), a142.length > 0 && Pt1(a142, e722, n489), o115.length > 0 && Pt1(o115, e722, n489), J1.buffers.depth.setTest(!0), J1.buffers.depth.setMask(!0), J1.buffers.color.setMask(!0), J1.setPolygonOffset(!1);
    }
    function Pt1(t, e724, n491) {
        const i344 = !0 === e724.isScene ? e724.overrideMaterial : null;
        for(let r267 = 0, s173 = t.length; r267 < s173; r267++){
            const s174 = t[r267], a144 = s174.object, o116 = s174.geometry, l107 = null === i344 ? s174.material : i344, h89 = s174.group;
            a144.layers.test(n491.layers) && Dt1(a144, e724, n491, o116, l107, h89);
        }
    }
    function Dt1(t, e725, n492, i345, r268, s175) {
        t.onBeforeRender(v25, e725, n492, i345, r268, s175), t.modelViewMatrix.multiplyMatrices(n492.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), r268.onBeforeRender(v25, e725, n492, i345, t, s175), !0 === r268.transparent && 2 === r268.side ? (r268.side = 1, r268.needsUpdate = !0, v25.renderBufferDirect(n492, e725, i345, r268, t, s175), r268.side = 0, r268.needsUpdate = !0, v25.renderBufferDirect(n492, e725, i345, r268, t, s175), r268.side = 2) : v25.renderBufferDirect(n492, e725, i345, r268, t, s175), t.onAfterRender(v25, e725, n492, i345, r268, s175);
    }
    function It1(t210, e726, n493) {
        !0 !== e726.isScene && (e726 = q2);
        const i346 = Z1.get(t210), r269 = d55.state.lights, s176 = d55.state.shadowsArray, a145 = r269.state.version, o117 = st1.getParameters(t210, r269.state, s176, e726, n493), l108 = st1.getProgramCacheKey(o117);
        let h90 = i346.programs;
        i346.environment = t210.isMeshStandardMaterial ? e726.environment : null, i346.fog = e726.fog, i346.envMap = (t210.isMeshStandardMaterial ? et1 : tt1).get(t210.envMap || i346.environment), void 0 === h90 && (t210.addEventListener("dispose", St1), h90 = new Map, i346.programs = h90);
        let c70 = h90.get(l108);
        if (void 0 !== c70) {
            if (i346.currentProgram === c70 && i346.lightsStateVersion === a145) return Ot1(t210, o117), c70;
        } else o117.uniforms = st1.getUniforms(t210), t210.onBuild(n493, o117, v25), t210.onBeforeCompile(o117, v25), c70 = st1.acquireProgram(o117, l108), h90.set(l108, c70), i346.uniforms = o117.uniforms;
        const u64 = i346.uniforms;
        (t210.isShaderMaterial || t210.isRawShaderMaterial) && !0 !== t210.clipping || (u64.clippingPlanes = ht1.uniform), Ot1(t210, o117), i346.needsLights = function(t) {
            return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights;
        }(t210), i346.lightsStateVersion = a145, i346.needsLights && (u64.ambientLightColor.value = r269.state.ambient, u64.lightProbe.value = r269.state.probe, u64.directionalLights.value = r269.state.directional, u64.directionalLightShadows.value = r269.state.directionalShadow, u64.spotLights.value = r269.state.spot, u64.spotLightShadows.value = r269.state.spotShadow, u64.rectAreaLights.value = r269.state.rectArea, u64.ltc_1.value = r269.state.rectAreaLTC1, u64.ltc_2.value = r269.state.rectAreaLTC2, u64.pointLights.value = r269.state.point, u64.pointLightShadows.value = r269.state.pointShadow, u64.hemisphereLights.value = r269.state.hemi, u64.directionalShadowMap.value = r269.state.directionalShadowMap, u64.directionalShadowMatrix.value = r269.state.directionalShadowMatrix, u64.spotShadowMap.value = r269.state.spotShadowMap, u64.spotShadowMatrix.value = r269.state.spotShadowMatrix, u64.pointShadowMap.value = r269.state.pointShadowMap, u64.pointShadowMatrix.value = r269.state.pointShadowMatrix);
        const p51 = c70.getUniforms(), m36 = Hi.seqWithValue(p51.seq, u64);
        return i346.currentProgram = c70, i346.uniformsList = m36, c70;
    }
    function Ot1(t, e727) {
        const n494 = Z1.get(t);
        n494.outputEncoding = e727.outputEncoding, n494.instancing = e727.instancing, n494.skinning = e727.skinning, n494.morphTargets = e727.morphTargets, n494.morphNormals = e727.morphNormals, n494.morphColors = e727.morphColors, n494.morphTargetsCount = e727.morphTargetsCount, n494.numClippingPlanes = e727.numClippingPlanes, n494.numIntersection = e727.numClipIntersection, n494.vertexAlphas = e727.vertexAlphas, n494.vertexTangents = e727.vertexTangents, n494.toneMapping = e727.toneMapping;
    }
    Rt1.setAnimationLoop(function(t) {
        Tt1 && Tt1(t);
    }), "undefined" != typeof self && Rt1.setContext(self), this.setAnimationLoop = function(t) {
        Tt1 = t, _t1.setAnimationLoop(t), null === t ? Rt1.stop() : Rt1.start();
    }, _t1.addEventListener("sessionstart", Et1), _t1.addEventListener("sessionend", At1), this.render = function(t, e728) {
        if (void 0 !== e728 && !0 !== e728.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        if (!0 === y24) return;
        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e728.parent && e728.updateMatrixWorld(), !0 === _t1.enabled && !0 === _t1.isPresenting && (!0 === _t1.cameraAutoUpdate && _t1.updateCamera(e728), e728 = _t1.getCamera()), !0 === t.isScene && t.onBeforeRender(v25, t, e728, w12), d55 = lt1.get(t, f28.length), d55.init(), f28.push(d55), G3.multiplyMatrices(e728.projectionMatrix, e728.matrixWorldInverse), F4.setFromProjectionMatrix(G3), z3 = this.localClippingEnabled, B3 = ht1.init(this.clippingPlanes, z3, e728), u61 = ot1.get(t, p48.length), u61.init(), p48.push(u61), Ct1(t, e728, 0, v25.sortObjects), u61.finish(), !0 === v25.sortObjects && u61.sort(P5, D4), !0 === B3 && ht1.beginShadows();
        const n495 = d55.state.shadowsArray;
        if (ct1.render(n495, t, e728), !0 === B3 && ht1.endShadows(), !0 === this.info.autoReset && this.info.reset(), ut1.render(u61, t), d55.setupLights(v25.physicallyCorrectLights), e728.isArrayCamera) {
            const n496 = e728.cameras;
            for(let e729 = 0, i347 = n496.length; e729 < i347; e729++){
                const i348 = n496[e729];
                Lt1(u61, t, i348, i348.viewport);
            }
        } else Lt1(u61, t, e728);
        null !== w12 && (Q1.updateMultisampleRenderTarget(w12), Q1.updateRenderTargetMipmap(w12)), !0 === t.isScene && t.onAfterRender(v25, t, e728), gt1.resetDefaultState(), M9 = -1, S8 = null, f28.pop(), d55 = f28.length > 0 ? f28[f28.length - 1] : null, p48.pop(), u61 = p48.length > 0 ? p48[p48.length - 1] : null;
    }, this.getActiveCubeFace = function() {
        return b19;
    }, this.getActiveMipmapLevel = function() {
        return _15;
    }, this.getRenderTarget = function() {
        return w12;
    }, this.setRenderTargetTextures = function(t, e730, n497) {
        Z1.get(t.texture).__webglTexture = e730, Z1.get(t.depthTexture).__webglTexture = n497;
        const i349 = Z1.get(t);
        i349.__hasExternalTextures = !0, i349.__hasExternalTextures && (i349.__autoAllocateDepthBuffer = void 0 === n497, i349.__autoAllocateDepthBuffer || !0 === $1.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i349.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(t, e731) {
        const n498 = Z1.get(t);
        n498.__webglFramebuffer = e731, n498.__useDefaultFramebuffer = void 0 === e731;
    }, this.setRenderTarget = function(t, e732 = 0, n499 = 0) {
        w12 = t, b19 = e732, _15 = n499;
        let i350 = !0;
        if (t) {
            const e733 = Z1.get(t);
            void 0 !== e733.__useDefaultFramebuffer ? (J1.bindFramebuffer(36160, null), i350 = !1) : void 0 === e733.__webglFramebuffer ? Q1.setupRenderTarget(t) : e733.__hasExternalTextures && Q1.rebindTextures(t, Z1.get(t.texture).__webglTexture, Z1.get(t.depthTexture).__webglTexture);
        }
        let r270 = null, s177 = !1, a146 = !1;
        if (t) {
            const n500 = t.texture;
            (n500.isData3DTexture || n500.isDataArrayTexture) && (a146 = !0);
            const i351 = Z1.get(t).__webglFramebuffer;
            t.isWebGLCubeRenderTarget ? (r270 = i351[e732], s177 = !0) : r270 = Y1.isWebGL2 && t.samples > 0 && !1 === Q1.useMultisampledRTT(t) ? Z1.get(t).__webglMultisampledFramebuffer : i351, T8.copy(t.viewport), E7.copy(t.scissor), A7 = t.scissorTest;
        } else T8.copy(I5).multiplyScalar(L6).floor(), E7.copy(O5).multiplyScalar(L6).floor(), A7 = N5;
        if (J1.bindFramebuffer(36160, r270) && Y1.drawBuffers && i350 && J1.drawBuffers(t, r270), J1.viewport(T8), J1.scissor(E7), J1.setScissorTest(A7), s177) {
            const i352 = Z1.get(t.texture);
            vt1.framebufferTexture2D(36160, 36064, 34069 + e732, i352.__webglTexture, n499);
        } else if (a146) {
            const i353 = Z1.get(t.texture), r271 = e732 || 0;
            vt1.framebufferTextureLayer(36160, 36064, i353.__webglTexture, n499 || 0, r271);
        }
        M9 = -1;
    }, this.readRenderTargetPixels = function(t, e734, n501, i354, r272, s178, a147) {
        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let o118 = Z1.get(t).__webglFramebuffer;
        if (t.isWebGLCubeRenderTarget && void 0 !== a147 && (o118 = o118[a147]), o118) {
            J1.bindFramebuffer(36160, o118);
            try {
                const a148 = t.texture, o119 = a148.format, l109 = a148.type;
                if (1023 !== o119 && ft1.convert(o119) !== vt1.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                const h91 = 1016 === l109 && ($1.has("EXT_color_buffer_half_float") || Y1.isWebGL2 && $1.has("EXT_color_buffer_float"));
                if (!(1009 === l109 || ft1.convert(l109) === vt1.getParameter(35738) || 1015 === l109 && (Y1.isWebGL2 || $1.has("OES_texture_float") || $1.has("WEBGL_color_buffer_float")) || h91)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                e734 >= 0 && e734 <= t.width - i354 && n501 >= 0 && n501 <= t.height - r272 && vt1.readPixels(e734, n501, i354, r272, ft1.convert(o119), ft1.convert(l109), s178);
            } finally{
                const t = null !== w12 ? Z1.get(w12).__webglFramebuffer : null;
                J1.bindFramebuffer(36160, t);
            }
        }
    }, this.copyFramebufferToTexture = function(t, e735, n502 = 0) {
        if (!0 !== e735.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
        const i355 = Math.pow(2, -n502), r273 = Math.floor(e735.image.width * i355), s179 = Math.floor(e735.image.height * i355);
        Q1.setTexture2D(e735, 0), vt1.copyTexSubImage2D(3553, n502, 0, 0, t.x, t.y, r273, s179), J1.unbindTexture();
    }, this.copyTextureToTexture = function(t, e736, n503, i356 = 0) {
        const r274 = e736.image.width, s180 = e736.image.height, a149 = ft1.convert(n503.format), o120 = ft1.convert(n503.type);
        Q1.setTexture2D(n503, 0), vt1.pixelStorei(37440, n503.flipY), vt1.pixelStorei(37441, n503.premultiplyAlpha), vt1.pixelStorei(3317, n503.unpackAlignment), e736.isDataTexture ? vt1.texSubImage2D(3553, i356, t.x, t.y, r274, s180, a149, o120, e736.image.data) : e736.isCompressedTexture ? vt1.compressedTexSubImage2D(3553, i356, t.x, t.y, e736.mipmaps[0].width, e736.mipmaps[0].height, a149, e736.mipmaps[0].data) : vt1.texSubImage2D(3553, i356, t.x, t.y, a149, o120, e736.image), 0 === i356 && n503.generateMipmaps && vt1.generateMipmap(3553), J1.unbindTexture();
    }, this.copyTextureToTexture3D = function(t, e737, n504, i357, r275 = 0) {
        if (v25.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        const s181 = t.max.x - t.min.x + 1, a150 = t.max.y - t.min.y + 1, o121 = t.max.z - t.min.z + 1, l110 = ft1.convert(i357.format), h92 = ft1.convert(i357.type);
        let c71;
        if (i357.isData3DTexture) Q1.setTexture3D(i357, 0), c71 = 32879;
        else {
            if (!i357.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            Q1.setTexture2DArray(i357, 0), c71 = 35866;
        }
        vt1.pixelStorei(37440, i357.flipY), vt1.pixelStorei(37441, i357.premultiplyAlpha), vt1.pixelStorei(3317, i357.unpackAlignment);
        const u65 = vt1.getParameter(3314), d56 = vt1.getParameter(32878), p52 = vt1.getParameter(3316), m37 = vt1.getParameter(3315), f31 = vt1.getParameter(32877), g26 = n504.isCompressedTexture ? n504.mipmaps[0] : n504.image;
        vt1.pixelStorei(3314, g26.width), vt1.pixelStorei(32878, g26.height), vt1.pixelStorei(3316, t.min.x), vt1.pixelStorei(3315, t.min.y), vt1.pixelStorei(32877, t.min.z), n504.isDataTexture || n504.isData3DTexture ? vt1.texSubImage3D(c71, r275, e737.x, e737.y, e737.z, s181, a150, o121, l110, h92, g26.data) : n504.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), vt1.compressedTexSubImage3D(c71, r275, e737.x, e737.y, e737.z, s181, a150, o121, l110, g26.data)) : vt1.texSubImage3D(c71, r275, e737.x, e737.y, e737.z, s181, a150, o121, l110, h92, g26), vt1.pixelStorei(3314, u65), vt1.pixelStorei(32878, d56), vt1.pixelStorei(3316, p52), vt1.pixelStorei(3315, m37), vt1.pixelStorei(32877, f31), 0 === r275 && i357.generateMipmaps && vt1.generateMipmap(c71), J1.unbindTexture();
    }, this.initTexture = function(t) {
        Q1.setTexture2D(t, 0), J1.unbindTexture();
    }, this.resetState = function() {
        b19 = 0, _15 = 0, w12 = null, J1.reset(), gt1.reset();
    }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
    }));
}
Or.prototype.isWebGLRenderer = !0;
(class extends Or {
}).prototype.isWebGL1Renderer = !0;
class Nr extends Wt {
    constructor(){
        super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }));
    }
    copy(t, e738) {
        return super.copy(t, e738), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
    }
    toJSON(t) {
        const e739 = super.toJSON(t);
        return null !== this.fog && (e739.object.fog = this.fog.toJSON()), e739;
    }
}
Nr.prototype.isScene = !0;
class Fr {
    constructor(t, e740){
        this.array = t, this.stride = e740, this.count = void 0 !== t ? t.length / e740 : 0, this.usage = 35044, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0, this.uuid = l();
    }
    onUploadCallback() {}
    set needsUpdate(t) {
        !0 === t && this.version++;
    }
    setUsage(t) {
        return this.usage = t, this;
    }
    copy(t) {
        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
    }
    copyAt(t, e741, n505) {
        t *= this.stride, n505 *= e741.stride;
        for(let i358 = 0, r276 = this.stride; i358 < r276; i358++)this.array[t + i358] = e741.array[n505 + i358];
        return this;
    }
    set(t, e742 = 0) {
        return this.array.set(t, e742), this;
    }
    clone(t) {
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = l()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const e743 = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n506 = new this.constructor(e743, this.stride);
        return n506.setUsage(this.usage), n506;
    }
    onUpload(t) {
        return this.onUploadCallback = t, this;
    }
    toJSON(t) {
        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = l()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
}
Fr.prototype.isInterleavedBuffer = !0;
const Ur = new V;
class kr {
    constructor(t, e744, n507, i359 = !1){
        this.name = "", this.data = t, this.itemSize = e744, this.offset = n507, this.normalized = !0 === i359;
    }
    get count() {
        return this.data.count;
    }
    get array() {
        return this.data.array;
    }
    set needsUpdate(t) {
        this.data.needsUpdate = t;
    }
    applyMatrix4(t) {
        for(let e745 = 0, n508 = this.data.count; e745 < n508; e745++)Ur.fromBufferAttribute(this, e745), Ur.applyMatrix4(t), this.setXYZ(e745, Ur.x, Ur.y, Ur.z);
        return this;
    }
    applyNormalMatrix(t) {
        for(let e746 = 0, n509 = this.count; e746 < n509; e746++)Ur.fromBufferAttribute(this, e746), Ur.applyNormalMatrix(t), this.setXYZ(e746, Ur.x, Ur.y, Ur.z);
        return this;
    }
    transformDirection(t) {
        for(let e747 = 0, n510 = this.count; e747 < n510; e747++)Ur.fromBufferAttribute(this, e747), Ur.transformDirection(t), this.setXYZ(e747, Ur.x, Ur.y, Ur.z);
        return this;
    }
    setX(t, e748) {
        return this.data.array[t * this.data.stride + this.offset] = e748, this;
    }
    setY(t, e749) {
        return this.data.array[t * this.data.stride + this.offset + 1] = e749, this;
    }
    setZ(t, e750) {
        return this.data.array[t * this.data.stride + this.offset + 2] = e750, this;
    }
    setW(t, e751) {
        return this.data.array[t * this.data.stride + this.offset + 3] = e751, this;
    }
    getX(t) {
        return this.data.array[t * this.data.stride + this.offset];
    }
    getY(t) {
        return this.data.array[t * this.data.stride + this.offset + 1];
    }
    getZ(t) {
        return this.data.array[t * this.data.stride + this.offset + 2];
    }
    getW(t) {
        return this.data.array[t * this.data.stride + this.offset + 3];
    }
    setXY(t, e752, n511) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e752, this.data.array[t + 1] = n511, this;
    }
    setXYZ(t, e753, n512, i360) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e753, this.data.array[t + 1] = n512, this.data.array[t + 2] = i360, this;
    }
    setXYZW(t, e754, n513, i361, r277) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e754, this.data.array[t + 1] = n513, this.data.array[t + 2] = i361, this.data.array[t + 3] = r277, this;
    }
    clone(t) {
        if (void 0 === t) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
            const t = [];
            for(let e755 = 0; e755 < this.count; e755++){
                const n514 = e755 * this.data.stride + this.offset;
                for(let e756 = 0; e756 < this.itemSize; e756++)t.push(this.data.array[n514 + e756]);
            }
            return new oe(new this.array.constructor(t), this.itemSize, this.normalized);
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new kr(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(t) {
        if (void 0 === t) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
            const t = [];
            for(let e757 = 0; e757 < this.count; e757++){
                const n515 = e757 * this.data.stride + this.offset;
                for(let e758 = 0; e758 < this.itemSize; e758++)t.push(this.data.array[n515 + e758]);
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            };
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        };
    }
}
kr.prototype.isInterleavedBufferAttribute = !0;
class Br extends ie {
    constructor(t){
        super(), this.type = "SpriteMaterial", this.color = new L(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
    }
}
let zr;
Br.prototype.isSpriteMaterial = !0;
const Hr = new V, Vr = new V, Gr = new V, Wr = new g, jr = new g, qr = new xt, Xr = new V, $r = new V, Yr = new V, Jr = new g, Kr = new g, Zr = new g;
function Qr(t, e759, n516, i362, r278, s182) {
    Wr.subVectors(t, n516).addScalar(.5).multiply(i362), void 0 !== r278 ? (jr.x = s182 * Wr.x - r278 * Wr.y, jr.y = r278 * Wr.x + s182 * Wr.y) : jr.copy(Wr), t.copy(e759), t.x += jr.x, t.y += jr.y, t.applyMatrix4(qr);
}
(class extends Wt {
    constructor(t){
        if (super(), this.type = "Sprite", void 0 === zr) {
            zr = new ye;
            const t = new Float32Array([
                -0.5,
                -0.5,
                0,
                0,
                0,
                .5,
                -0.5,
                0,
                1,
                0,
                .5,
                .5,
                0,
                1,
                1,
                -0.5,
                .5,
                0,
                0,
                1
            ]), e760 = new Fr(t, 5);
            zr.setIndex([
                0,
                1,
                2,
                0,
                2,
                3
            ]), zr.setAttribute("position", new kr(e760, 3, 0, !1)), zr.setAttribute("uv", new kr(e760, 2, 3, !1));
        }
        this.geometry = zr, this.material = void 0 !== t ? t : new Br, this.center = new g(.5, .5);
    }
    raycast(t, e761) {
        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Vr.setFromMatrixScale(this.matrixWorld), qr.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Gr.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Vr.multiplyScalar(-Gr.z);
        const n517 = this.material.rotation;
        let i363, r279;
        0 !== n517 && (r279 = Math.cos(n517), i363 = Math.sin(n517));
        const s183 = this.center;
        Qr(Xr.set(-0.5, -0.5, 0), Gr, s183, Vr, i363, r279), Qr($r.set(.5, -0.5, 0), Gr, s183, Vr, i363, r279), Qr(Yr.set(.5, .5, 0), Gr, s183, Vr, i363, r279), Jr.set(0, 0), Kr.set(1, 0), Zr.set(1, 1);
        let a151 = t.ray.intersectTriangle(Xr, $r, Yr, !1, Hr);
        if (null === a151 && (Qr($r.set(-0.5, .5, 0), Gr, s183, Vr, i363, r279), Kr.set(0, 1), a151 = t.ray.intersectTriangle(Xr, Yr, $r, !1, Hr), null === a151)) return;
        const o122 = t.ray.origin.distanceTo(Hr);
        o122 < t.near || o122 > t.far || e761.push({
            distance: o122,
            point: Hr.clone(),
            uv: ee.getUV(Hr, Xr, $r, Yr, Jr, Kr, Zr, new g),
            face: null,
            object: this
        });
    }
    copy(t) {
        return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this;
    }
}).prototype.isSprite = !0;
const ts = new V, es = new U, ns = new U, is = new V, rs = new xt;
class ss extends Fe {
    constructor(t, e762){
        super(t, e762), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new xt, this.bindMatrixInverse = new xt;
    }
    copy(t) {
        return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
    }
    bind(t, e763) {
        this.skeleton = t, void 0 === e763 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e763 = this.matrixWorld), this.bindMatrix.copy(e763), this.bindMatrixInverse.copy(e763).invert();
    }
    pose() {
        this.skeleton.pose();
    }
    normalizeSkinWeights() {
        const t = new U, e764 = this.geometry.attributes.skinWeight;
        for(let n518 = 0, i364 = e764.count; n518 < i364; n518++){
            t.fromBufferAttribute(e764, n518);
            const i365 = 1 / t.manhattanLength();
            i365 !== 1 / 0 ? t.multiplyScalar(i365) : t.set(1, 0, 0, 0), e764.setXYZW(n518, t.x, t.y, t.z, t.w);
        }
    }
    updateMatrixWorld(t) {
        super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(t, e765) {
        const n519 = this.skeleton, i366 = this.geometry;
        es.fromBufferAttribute(i366.attributes.skinIndex, t), ns.fromBufferAttribute(i366.attributes.skinWeight, t), ts.copy(e765).applyMatrix4(this.bindMatrix), e765.set(0, 0, 0);
        for(let t211 = 0; t211 < 4; t211++){
            const i367 = ns.getComponent(t211);
            if (0 !== i367) {
                const r280 = es.getComponent(t211);
                rs.multiplyMatrices(n519.bones[r280].matrixWorld, n519.boneInverses[r280]), e765.addScaledVector(is.copy(ts).applyMatrix4(rs), i367);
            }
        }
        return e765.applyMatrix4(this.bindMatrixInverse);
    }
}
ss.prototype.isSkinnedMesh = !0;
class as extends Wt {
    constructor(){
        super(), this.type = "Bone";
    }
}
as.prototype.isBone = !0;
class os extends F {
    constructor(t = null, e766 = 1, n520 = 1, i368, r281, s184, a152, o123, l111 = 1003, h93 = 1003, c72, u66){
        super(null, s184, a152, o123, l111, h93, i368, r281, c72, u66), this.image = {
            data: t,
            width: e766,
            height: n520
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
    }
}
os.prototype.isDataTexture = !0;
const ls = new xt, hs = new xt;
class cs {
    constructor(t = [], e767 = []){
        this.uuid = l(), this.bones = t.slice(0), this.boneInverses = e767, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
    }
    init() {
        const t = this.bones, e768 = this.boneInverses;
        if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e768.length) this.calculateInverses();
        else if (t.length !== e768.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for(let t = 0, e769 = this.bones.length; t < e769; t++)this.boneInverses.push(new xt);
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for(let t = 0, e770 = this.bones.length; t < e770; t++){
            const e771 = new xt;
            this.bones[t] && e771.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e771);
        }
    }
    pose() {
        for(let t = 0, e773 = this.bones.length; t < e773; t++){
            const e774 = this.bones[t];
            e774 && e774.matrixWorld.copy(this.boneInverses[t]).invert();
        }
        for(let t212 = 0, e772 = this.bones.length; t212 < e772; t212++){
            const e775 = this.bones[t212];
            e775 && (e775.parent && e775.parent.isBone ? (e775.matrix.copy(e775.parent.matrixWorld).invert(), e775.matrix.multiply(e775.matrixWorld)) : e775.matrix.copy(e775.matrixWorld), e775.matrix.decompose(e775.position, e775.quaternion, e775.scale));
        }
    }
    update() {
        const t = this.bones, e776 = this.boneInverses, n521 = this.boneMatrices, i370 = this.boneTexture;
        for(let i369 = 0, r282 = t.length; i369 < r282; i369++){
            const r283 = t[i369] ? t[i369].matrixWorld : hs;
            ls.multiplyMatrices(r283, e776[i369]), ls.toArray(n521, 16 * i369);
        }
        null !== i370 && (i370.needsUpdate = !0);
    }
    clone() {
        return new cs(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
        let t = Math.sqrt(4 * this.bones.length);
        t = p(t), t = Math.max(t, 4);
        const e777 = new Float32Array(t * t * 4);
        e777.set(this.boneMatrices);
        const n522 = new os(e777, t, t, 1023, 1015);
        return n522.needsUpdate = !0, this.boneMatrices = e777, this.boneTexture = n522, this.boneTextureSize = t, this;
    }
    getBoneByName(t) {
        for(let e778 = 0, n523 = this.bones.length; e778 < n523; e778++){
            const n524 = this.bones[e778];
            if (n524.name === t) return n524;
        }
    }
    dispose() {
        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(t, e779) {
        this.uuid = t.uuid;
        for(let n525 = 0, i371 = t.bones.length; n525 < i371; n525++){
            const i372 = t.bones[n525];
            let r284 = e779[i372];
            void 0 === r284 && (console.warn("THREE.Skeleton: No bone found with UUID:", i372), r284 = new as), this.bones.push(r284), this.boneInverses.push((new xt).fromArray(t.boneInverses[n525]));
        }
        return this.init(), this;
    }
    toJSON() {
        const t = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        t.uuid = this.uuid;
        const e780 = this.bones, n526 = this.boneInverses;
        for(let i373 = 0, r285 = e780.length; i373 < r285; i373++){
            const r286 = e780[i373];
            t.bones.push(r286.uuid);
            const s185 = n526[i373];
            t.boneInverses.push(s185.toArray());
        }
        return t;
    }
}
class us extends oe {
    constructor(t, e781, n527, i374 = 1){
        "number" == typeof n527 && (i374 = n527, n527 = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e781, n527), this.meshPerAttribute = i374;
    }
    copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
    toJSON() {
        const t = super.toJSON();
        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t;
    }
}
us.prototype.isInstancedBufferAttribute = !0;
const ds = new xt, ps = new xt, ms = [], fs = new Fe;
(class extends Fe {
    constructor(t, e782, n528){
        super(t, e782), this.instanceMatrix = new us(new Float32Array(16 * n528), 16), this.instanceColor = null, this.count = n528, this.frustumCulled = !1;
    }
    copy(t) {
        return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this;
    }
    getColorAt(t, e783) {
        e783.fromArray(this.instanceColor.array, 3 * t);
    }
    getMatrixAt(t, e784) {
        e784.fromArray(this.instanceMatrix.array, 16 * t);
    }
    raycast(t, e785) {
        const n530 = this.matrixWorld, i375 = this.count;
        if (fs.geometry = this.geometry, fs.material = this.material, void 0 !== fs.material) for(let r287 = 0; r287 < i375; r287++){
            this.getMatrixAt(r287, ds), ps.multiplyMatrices(n530, ds), fs.matrixWorld = ps, fs.raycast(t, ms);
            for(let t213 = 0, n529 = ms.length; t213 < n529; t213++){
                const n531 = ms[t213];
                n531.instanceId = r287, n531.object = this, e785.push(n531);
            }
            ms.length = 0;
        }
    }
    setColorAt(t, e786) {
        null === this.instanceColor && (this.instanceColor = new us(new Float32Array(3 * this.instanceMatrix.count), 3)), e786.toArray(this.instanceColor.array, 3 * t);
    }
    setMatrixAt(t, e787) {
        e787.toArray(this.instanceMatrix.array, 16 * t);
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        });
    }
}).prototype.isInstancedMesh = !0;
class gs extends ie {
    constructor(t){
        super(), this.type = "LineBasicMaterial", this.color = new L(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this;
    }
}
gs.prototype.isLineBasicMaterial = !0;
const vs = new V, ys = new V, xs = new xt, bs = new yt, _s = new ct;
class ws extends Wt {
    constructor(t = new ye, e788 = new gs){
        super(), this.type = "Line", this.geometry = t, this.material = e788, this.updateMorphTargets();
    }
    copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this;
    }
    computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
            if (null === t.index) {
                const e789 = t.attributes.position, n532 = [
                    0
                ];
                for(let t214 = 1, i376 = e789.count; t214 < i376; t214++)vs.fromBufferAttribute(e789, t214 - 1), ys.fromBufferAttribute(e789, t214), n532[t214] = n532[t214 - 1], n532[t214] += vs.distanceTo(ys);
                t.setAttribute("lineDistance", new ce(n532, 1));
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        } else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this;
    }
    raycast(t, e790) {
        const n533 = this.geometry, i377 = this.matrixWorld, r288 = t.params.Line.threshold, s186 = n533.drawRange;
        if (null === n533.boundingSphere && n533.computeBoundingSphere(), _s.copy(n533.boundingSphere), _s.applyMatrix4(i377), _s.radius += r288, !1 === t.ray.intersectsSphere(_s)) return;
        xs.copy(i377).invert(), bs.copy(t.ray).applyMatrix4(xs);
        const a153 = r288 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o124 = a153 * a153, l112 = new V, h94 = new V, c73 = new V, u67 = new V, d57 = this.isLineSegments ? 2 : 1;
        if (n533.isBufferGeometry) {
            const i379 = n533.index, r289 = n533.attributes.position;
            if (null !== i379) for(let n535 = Math.max(0, s186.start), a154 = Math.min(i379.count, s186.start + s186.count) - 1; n535 < a154; n535 += d57){
                const s187 = i379.getX(n535), a155 = i379.getX(n535 + 1);
                l112.fromBufferAttribute(r289, s187), h94.fromBufferAttribute(r289, a155);
                if (bs.distanceSqToSegment(l112, h94, u67, c73) > o124) continue;
                u67.applyMatrix4(this.matrixWorld);
                const d58 = t.ray.origin.distanceTo(u67);
                d58 < t.near || d58 > t.far || e790.push({
                    distance: d58,
                    point: c73.clone().applyMatrix4(this.matrixWorld),
                    index: n535,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
            else for(let n534 = Math.max(0, s186.start), i378 = Math.min(r289.count, s186.start + s186.count) - 1; n534 < i378; n534 += d57){
                l112.fromBufferAttribute(r289, n534), h94.fromBufferAttribute(r289, n534 + 1);
                if (bs.distanceSqToSegment(l112, h94, u67, c73) > o124) continue;
                u67.applyMatrix4(this.matrixWorld);
                const i380 = t.ray.origin.distanceTo(u67);
                i380 < t.near || i380 > t.far || e790.push({
                    distance: i380,
                    point: c73.clone().applyMatrix4(this.matrixWorld),
                    index: n534,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        } else n533.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
            const e791 = t.morphAttributes, n536 = Object.keys(e791);
            if (n536.length > 0) {
                const t = e791[n536[0]];
                if (void 0 !== t) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let e792 = 0, n537 = t.length; e792 < n537; e792++){
                        const n538 = t[e792].name || String(e792);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n538] = e792;
                    }
                }
            }
        } else {
            const e793 = t.morphTargets;
            void 0 !== e793 && e793.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
    }
}
ws.prototype.isLine = !0;
const Ms = new V, Ss = new V;
class Ts extends ws {
    constructor(t, e794){
        super(t, e794), this.type = "LineSegments";
    }
    computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
            if (null === t.index) {
                const e795 = t.attributes.position, n539 = [];
                for(let t216 = 0, i381 = e795.count; t216 < i381; t216 += 2)Ms.fromBufferAttribute(e795, t216), Ss.fromBufferAttribute(e795, t216 + 1), n539[t216] = 0 === t216 ? 0 : n539[t216 - 1], n539[t216 + 1] = n539[t216] + Ms.distanceTo(Ss);
                t.setAttribute("lineDistance", new ce(n539, 1));
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        } else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this;
    }
}
Ts.prototype.isLineSegments = !0;
class Es extends ws {
    constructor(t, e796){
        super(t, e796), this.type = "LineLoop";
    }
}
Es.prototype.isLineLoop = !0;
class As extends ie {
    constructor(t){
        super(), this.type = "PointsMaterial", this.color = new L(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this;
    }
}
As.prototype.isPointsMaterial = !0;
const Rs = new xt, Cs = new yt, Ls = new ct, Ps = new V;
class Ds extends Wt {
    constructor(t = new ye, e797 = new As){
        super(), this.type = "Points", this.geometry = t, this.material = e797, this.updateMorphTargets();
    }
    copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this;
    }
    raycast(t, e798) {
        const n540 = this.geometry, i382 = this.matrixWorld, r290 = t.params.Points.threshold, s188 = n540.drawRange;
        if (null === n540.boundingSphere && n540.computeBoundingSphere(), Ls.copy(n540.boundingSphere), Ls.applyMatrix4(i382), Ls.radius += r290, !1 === t.ray.intersectsSphere(Ls)) return;
        Rs.copy(i382).invert(), Cs.copy(t.ray).applyMatrix4(Rs);
        const a156 = r290 / ((this.scale.x + this.scale.y + this.scale.z) / 3), o125 = a156 * a156;
        if (n540.isBufferGeometry) {
            const r292 = n540.index, a157 = n540.attributes.position;
            if (null !== r292) for(let n542 = Math.max(0, s188.start), l113 = Math.min(r292.count, s188.start + s188.count); n542 < l113; n542++){
                const s189 = r292.getX(n542);
                Ps.fromBufferAttribute(a157, s189), Is(Ps, s189, o125, i382, t, e798, this);
            }
            else for(let n541 = Math.max(0, s188.start), r291 = Math.min(a157.count, s188.start + s188.count); n541 < r291; n541++)Ps.fromBufferAttribute(a157, n541), Is(Ps, n541, o125, i382, t, e798, this);
        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
            const e799 = t.morphAttributes, n543 = Object.keys(e799);
            if (n543.length > 0) {
                const t = e799[n543[0]];
                if (void 0 !== t) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for(let e800 = 0, n544 = t.length; e800 < n544; e800++){
                        const n545 = t[e800].name || String(e800);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n545] = e800;
                    }
                }
            }
        } else {
            const e801 = t.morphTargets;
            void 0 !== e801 && e801.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
    }
}
function Is(t, e802, n546, i383, r293, s190, a158) {
    const o126 = Cs.distanceSqToPoint(t);
    if (o126 < n546) {
        const n547 = new V;
        Cs.closestPointToPoint(t, n547), n547.applyMatrix4(i383);
        const l114 = r293.ray.origin.distanceTo(n547);
        if (l114 < r293.near || l114 > r293.far) return;
        s190.push({
            distance: l114,
            distanceToRay: Math.sqrt(o126),
            point: n547,
            index: e802,
            face: null,
            object: a158
        });
    }
}
Ds.prototype.isPoints = !0;
(class extends F {
    constructor(t, e803, n548, i384, r294, s191, a159, o127, l115){
        super(t, e803, n548, i384, r294, s191, a159, o127, l115), this.minFilter = void 0 !== s191 ? s191 : 1006, this.magFilter = void 0 !== r294 ? r294 : 1006, this.generateMipmaps = !1;
        const h95 = this;
        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e804() {
            h95.needsUpdate = !0, t.requestVideoFrameCallback(e804);
        });
    }
    clone() {
        return new this.constructor(this.image).copy(this);
    }
    update() {
        const t = this.image;
        !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
    }
}).prototype.isVideoTexture = !0;
(class extends F {
    constructor(t, e805, n549){
        super({
            width: t,
            height: e805
        }), this.format = n549, this.magFilter = 1003, this.minFilter = 1003, this.generateMipmaps = !1, this.needsUpdate = !0;
    }
}).prototype.isFramebufferTexture = !0;
class Os extends F {
    constructor(t, e806, n550, i385, r295, s192, a160, o128, l116, h96, c74, u68){
        super(null, s192, a160, o128, l116, h96, i385, r295, c74, u68), this.image = {
            width: e806,
            height: n550
        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1;
    }
}
Os.prototype.isCompressedTexture = !0;
(class extends F {
    constructor(t, e807, n551, i386, r296, s193, a161, o129, l117){
        super(t, e807, n551, i386, r296, s193, a161, o129, l117), this.needsUpdate = !0;
    }
}).prototype.isCanvasTexture = !0;
class Ns {
    constructor(){
        this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(t, e808) {
        const n552 = this.getUtoTmapping(t);
        return this.getPoint(n552, e808);
    }
    getPoints(t = 5) {
        const e809 = [];
        for(let n553 = 0; n553 <= t; n553++)e809.push(this.getPoint(n553 / t));
        return e809;
    }
    getSpacedPoints(t = 5) {
        const e810 = [];
        for(let n554 = 0; n554 <= t; n554++)e810.push(this.getPointAt(n554 / t));
        return e810;
    }
    getLength() {
        const t = this.getLengths();
        return t[t.length - 1];
    }
    getLengths(t = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const e811 = [];
        let n555, i387 = this.getPoint(0), r297 = 0;
        e811.push(0);
        for(let s194 = 1; s194 <= t; s194++)n555 = this.getPoint(s194 / t), r297 += n555.distanceTo(i387), e811.push(r297), i387 = n555;
        return this.cacheArcLengths = e811, e811;
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths();
    }
    getUtoTmapping(t, e812) {
        const n556 = this.getLengths();
        let i388 = 0;
        const r298 = n556.length;
        let s195;
        s195 = e812 || t * n556[r298 - 1];
        let a162, o130 = 0, l118 = r298 - 1;
        for(; o130 <= l118;)if (i388 = Math.floor(o130 + (l118 - o130) / 2), a162 = n556[i388] - s195, a162 < 0) o130 = i388 + 1;
        else {
            if (!(a162 > 0)) {
                l118 = i388;
                break;
            }
            l118 = i388 - 1;
        }
        if (i388 = l118, n556[i388] === s195) return i388 / (r298 - 1);
        const h97 = n556[i388];
        return (i388 + (s195 - h97) / (n556[i388 + 1] - h97)) / (r298 - 1);
    }
    getTangent(t, e813) {
        const n557 = 1e-4;
        let i389 = t - n557, r299 = t + n557;
        i389 < 0 && (i389 = 0), r299 > 1 && (r299 = 1);
        const s196 = this.getPoint(i389), a163 = this.getPoint(r299), o131 = e813 || (s196.isVector2 ? new g : new V);
        return o131.copy(a163).sub(s196).normalize(), o131;
    }
    getTangentAt(t, e814) {
        const n558 = this.getUtoTmapping(t);
        return this.getTangent(n558, e814);
    }
    computeFrenetFrames(t, e817) {
        const n560 = new V, i390 = [], r300 = [], s197 = [], a164 = new V, o132 = new xt;
        for(let e815 = 0; e815 <= t; e815++){
            const n559 = e815 / t;
            i390[e815] = this.getTangentAt(n559, new V);
        }
        r300[0] = new V, s197[0] = new V;
        let l119 = Number.MAX_VALUE;
        const c75 = Math.abs(i390[0].x), u69 = Math.abs(i390[0].y), d59 = Math.abs(i390[0].z);
        c75 <= l119 && (l119 = c75, n560.set(1, 0, 0)), u69 <= l119 && (l119 = u69, n560.set(0, 1, 0)), d59 <= l119 && n560.set(0, 0, 1), a164.crossVectors(i390[0], n560).normalize(), r300[0].crossVectors(i390[0], a164), s197[0].crossVectors(i390[0], r300[0]);
        for(let e816 = 1; e816 <= t; e816++){
            if (r300[e816] = r300[e816 - 1].clone(), s197[e816] = s197[e816 - 1].clone(), a164.crossVectors(i390[e816 - 1], i390[e816]), a164.length() > Number.EPSILON) {
                a164.normalize();
                const t = Math.acos(h(i390[e816 - 1].dot(i390[e816]), -1, 1));
                r300[e816].applyMatrix4(o132.makeRotationAxis(a164, t));
            }
            s197[e816].crossVectors(i390[e816], r300[e816]);
        }
        if (!0 === e817) {
            let e818 = Math.acos(h(r300[0].dot(r300[t]), -1, 1));
            e818 /= t, i390[0].dot(a164.crossVectors(r300[0], r300[t])) > 0 && (e818 = -e818);
            for(let n561 = 1; n561 <= t; n561++)r300[n561].applyMatrix4(o132.makeRotationAxis(i390[n561], e818 * n561)), s197[n561].crossVectors(i390[n561], r300[n561]);
        }
        return {
            tangents: i390,
            normals: r300,
            binormals: s197
        };
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    copy(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
    toJSON() {
        const t = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
    }
    fromJSON(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
}
class Fs extends Ns {
    constructor(t = 0, e819 = 0, n562 = 1, i391 = 1, r301 = 0, s198 = 2 * Math.PI, a165 = !1, o133 = 0){
        super(), this.type = "EllipseCurve", this.aX = t, this.aY = e819, this.xRadius = n562, this.yRadius = i391, this.aStartAngle = r301, this.aEndAngle = s198, this.aClockwise = a165, this.aRotation = o133;
    }
    getPoint(t, e820) {
        const n564 = e820 || new g, i392 = 2 * Math.PI;
        let r302 = this.aEndAngle - this.aStartAngle;
        const s199 = Math.abs(r302) < Number.EPSILON;
        for(; r302 < 0;)r302 += i392;
        for(; r302 > i392;)r302 -= i392;
        r302 < Number.EPSILON && (r302 = s199 ? 0 : i392), !0 !== this.aClockwise || s199 || (r302 === i392 ? r302 = -i392 : r302 -= i392);
        const a166 = this.aStartAngle + t * r302;
        let o134 = this.aX + this.xRadius * Math.cos(a166), l120 = this.aY + this.yRadius * Math.sin(a166);
        if (0 !== this.aRotation) {
            const t = Math.cos(this.aRotation), e821 = Math.sin(this.aRotation), n563 = o134 - this.aX, i393 = l120 - this.aY;
            o134 = n563 * t - i393 * e821 + this.aX, l120 = n563 * e821 + i393 * t + this.aY;
        }
        return n564.set(o134, l120);
    }
    copy(t) {
        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
    }
    toJSON() {
        const t = super.toJSON();
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
    }
    fromJSON(t) {
        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
    }
}
Fs.prototype.isEllipseCurve = !0;
class Us extends Fs {
    constructor(t, e822, n565, i394, r303, s200){
        super(t, e822, n565, n565, i394, r303, s200), this.type = "ArcCurve";
    }
}
function ks() {
    let t218 = 0, e823 = 0, n566 = 0, i395 = 0;
    function r304(r305, s201, a167, o135) {
        t218 = r305, e823 = a167, n566 = -3 * r305 + 3 * s201 - 2 * a167 - o135, i395 = 2 * r305 - 2 * s201 + a167 + o135;
    }
    return {
        initCatmullRom: function(t, e824, n567, i396, s202) {
            r304(e824, n567, s202 * (n567 - t), s202 * (i396 - e824));
        },
        initNonuniformCatmullRom: function(t, e825, n568, i397, s203, a168, o136) {
            let l121 = (e825 - t) / s203 - (n568 - t) / (s203 + a168) + (n568 - e825) / a168, h98 = (n568 - e825) / a168 - (i397 - e825) / (a168 + o136) + (i397 - n568) / o136;
            l121 *= a168, h98 *= a168, r304(e825, n568, l121, h98);
        },
        calc: function(r306) {
            const s204 = r306 * r306;
            return t218 + e823 * r306 + n566 * s204 + i395 * (s204 * r306);
        }
    };
}
Us.prototype.isArcCurve = !0;
const Bs = new V, zs = new ks, Hs = new ks, Vs = new ks;
class Gs extends Ns {
    constructor(t = [], e826 = !1, n569 = "centripetal", i398 = .5){
        super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e826, this.curveType = n569, this.tension = i398;
    }
    getPoint(t, e827 = new V) {
        const n571 = e827, i399 = this.points, r307 = i399.length, s205 = (r307 - (this.closed ? 0 : 1)) * t;
        let a169, o137, l122 = Math.floor(s205), h99 = s205 - l122;
        this.closed ? l122 += l122 > 0 ? 0 : (Math.floor(Math.abs(l122) / r307) + 1) * r307 : 0 === h99 && l122 === r307 - 1 && (l122 = r307 - 2, h99 = 1), this.closed || l122 > 0 ? a169 = i399[(l122 - 1) % r307] : (Bs.subVectors(i399[0], i399[1]).add(i399[0]), a169 = Bs);
        const c76 = i399[l122 % r307], u70 = i399[(l122 + 1) % r307];
        if (this.closed || l122 + 2 < r307 ? o137 = i399[(l122 + 2) % r307] : (Bs.subVectors(i399[r307 - 1], i399[r307 - 2]).add(i399[r307 - 1]), o137 = Bs), "centripetal" === this.curveType || "chordal" === this.curveType) {
            const t = "chordal" === this.curveType ? .5 : .25;
            let e828 = Math.pow(a169.distanceToSquared(c76), t), n570 = Math.pow(c76.distanceToSquared(u70), t), i400 = Math.pow(u70.distanceToSquared(o137), t);
            n570 < 1e-4 && (n570 = 1), e828 < 1e-4 && (e828 = n570), i400 < 1e-4 && (i400 = n570), zs.initNonuniformCatmullRom(a169.x, c76.x, u70.x, o137.x, e828, n570, i400), Hs.initNonuniformCatmullRom(a169.y, c76.y, u70.y, o137.y, e828, n570, i400), Vs.initNonuniformCatmullRom(a169.z, c76.z, u70.z, o137.z, e828, n570, i400);
        } else "catmullrom" === this.curveType && (zs.initCatmullRom(a169.x, c76.x, u70.x, o137.x, this.tension), Hs.initCatmullRom(a169.y, c76.y, u70.y, o137.y, this.tension), Vs.initCatmullRom(a169.z, c76.z, u70.z, o137.z, this.tension));
        return n571.set(zs.calc(h99), Hs.calc(h99), Vs.calc(h99)), n571;
    }
    copy(t) {
        super.copy(t), this.points = [];
        for(let e829 = 0, n572 = t.points.length; e829 < n572; e829++){
            const n573 = t.points[e829];
            this.points.push(n573.clone());
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
    }
    toJSON() {
        const t = super.toJSON();
        t.points = [];
        for(let e830 = 0, n574 = this.points.length; e830 < n574; e830++){
            const n575 = this.points[e830];
            t.points.push(n575.toArray());
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
    }
    fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for(let e831 = 0, n576 = t.points.length; e831 < n576; e831++){
            const n577 = t.points[e831];
            this.points.push((new V).fromArray(n577));
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
    }
}
function Ws(t, e832, n578, i401, r308) {
    const s206 = .5 * (i401 - e832), a170 = .5 * (r308 - n578), o138 = t * t;
    return (2 * n578 - 2 * i401 + s206 + a170) * (t * o138) + (-3 * n578 + 3 * i401 - 2 * s206 - a170) * o138 + s206 * t + n578;
}
function js(t219, e833, n579, i402) {
    return function(t, e834) {
        const n580 = 1 - t;
        return n580 * n580 * e834;
    }(t219, e833) + function(t, e835) {
        return 2 * (1 - t) * t * e835;
    }(t219, n579) + function(t, e836) {
        return t * t * e836;
    }(t219, i402);
}
function qs(t220, e837, n581, i403, r309) {
    return function(t, e838) {
        const n582 = 1 - t;
        return n582 * n582 * n582 * e838;
    }(t220, e837) + function(t, e839) {
        const n583 = 1 - t;
        return 3 * n583 * n583 * t * e839;
    }(t220, n581) + function(t, e840) {
        return 3 * (1 - t) * t * t * e840;
    }(t220, i403) + function(t, e841) {
        return t * t * t * e841;
    }(t220, r309);
}
Gs.prototype.isCatmullRomCurve3 = !0;
class Xs extends Ns {
    constructor(t = new g, e842 = new g, n584 = new g, i404 = new g){
        super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e842, this.v2 = n584, this.v3 = i404;
    }
    getPoint(t, e843 = new g) {
        const n585 = e843, i405 = this.v0, r310 = this.v1, s207 = this.v2, a171 = this.v3;
        return n585.set(qs(t, i405.x, r310.x, s207.x, a171.x), qs(t, i405.y, r310.y, s207.y, a171.y)), n585;
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
    }
}
Xs.prototype.isCubicBezierCurve = !0;
class $s extends Ns {
    constructor(t = new V, e844 = new V, n586 = new V, i406 = new V){
        super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e844, this.v2 = n586, this.v3 = i406;
    }
    getPoint(t, e845 = new V) {
        const n587 = e845, i407 = this.v0, r311 = this.v1, s208 = this.v2, a172 = this.v3;
        return n587.set(qs(t, i407.x, r311.x, s208.x, a172.x), qs(t, i407.y, r311.y, s208.y, a172.y), qs(t, i407.z, r311.z, s208.z, a172.z)), n587;
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
    }
}
$s.prototype.isCubicBezierCurve3 = !0;
class Ys extends Ns {
    constructor(t = new g, e846 = new g){
        super(), this.type = "LineCurve", this.v1 = t, this.v2 = e846;
    }
    getPoint(t, e847 = new g) {
        const n588 = e847;
        return 1 === t ? n588.copy(this.v2) : (n588.copy(this.v2).sub(this.v1), n588.multiplyScalar(t).add(this.v1)), n588;
    }
    getPointAt(t, e848) {
        return this.getPoint(t, e848);
    }
    getTangent(t, e849) {
        const n589 = e849 || new g;
        return n589.copy(this.v2).sub(this.v1).normalize(), n589;
    }
    copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
    toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
}
Ys.prototype.isLineCurve = !0;
class Js extends Ns {
    constructor(t = new g, e850 = new g, n590 = new g){
        super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e850, this.v2 = n590;
    }
    getPoint(t, e851 = new g) {
        const n591 = e851, i408 = this.v0, r312 = this.v1, s209 = this.v2;
        return n591.set(js(t, i408.x, r312.x, s209.x), js(t, i408.y, r312.y, s209.y)), n591;
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
}
Js.prototype.isQuadraticBezierCurve = !0;
class Ks extends Ns {
    constructor(t = new V, e852 = new V, n592 = new V){
        super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e852, this.v2 = n592;
    }
    getPoint(t, e853 = new V) {
        const n593 = e853, i409 = this.v0, r313 = this.v1, s210 = this.v2;
        return n593.set(js(t, i409.x, r313.x, s210.x), js(t, i409.y, r313.y, s210.y), js(t, i409.z, r313.z, s210.z)), n593;
    }
    copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
    toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
    fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
}
Ks.prototype.isQuadraticBezierCurve3 = !0;
class Zs extends Ns {
    constructor(t = []){
        super(), this.type = "SplineCurve", this.points = t;
    }
    getPoint(t, e854 = new g) {
        const n594 = e854, i410 = this.points, r314 = (i410.length - 1) * t, s211 = Math.floor(r314), a173 = r314 - s211, o139 = i410[0 === s211 ? s211 : s211 - 1], l123 = i410[s211], h100 = i410[s211 > i410.length - 2 ? i410.length - 1 : s211 + 1], c77 = i410[s211 > i410.length - 3 ? i410.length - 1 : s211 + 2];
        return n594.set(Ws(a173, o139.x, l123.x, h100.x, c77.x), Ws(a173, o139.y, l123.y, h100.y, c77.y)), n594;
    }
    copy(t) {
        super.copy(t), this.points = [];
        for(let e855 = 0, n595 = t.points.length; e855 < n595; e855++){
            const n596 = t.points[e855];
            this.points.push(n596.clone());
        }
        return this;
    }
    toJSON() {
        const t = super.toJSON();
        t.points = [];
        for(let e856 = 0, n597 = this.points.length; e856 < n597; e856++){
            const n598 = this.points[e856];
            t.points.push(n598.toArray());
        }
        return t;
    }
    fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for(let e857 = 0, n599 = t.points.length; e857 < n599; e857++){
            const n600 = t.points[e857];
            this.points.push((new g).fromArray(n600));
        }
        return this;
    }
}
Zs.prototype.isSplineCurve = !0;
var Qs = Object.freeze({
    __proto__: null,
    ArcCurve: Us,
    CatmullRomCurve3: Gs,
    CubicBezierCurve: Xs,
    CubicBezierCurve3: $s,
    EllipseCurve: Fs,
    LineCurve: Ys,
    LineCurve3: class extends Ns {
        constructor(t = new V, e858 = new V){
            super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e858;
        }
        getPoint(t, e859 = new V) {
            const n601 = e859;
            return 1 === t ? n601.copy(this.v2) : (n601.copy(this.v2).sub(this.v1), n601.multiplyScalar(t).add(this.v1)), n601;
        }
        getPointAt(t, e860) {
            return this.getPoint(t, e860);
        }
        copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
        }
        toJSON() {
            const t = super.toJSON();
            return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
        }
        fromJSON(t) {
            return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
        }
    },
    QuadraticBezierCurve: Js,
    QuadraticBezierCurve3: Ks,
    SplineCurve: Zs
});
class ta extends Ns {
    constructor(){
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
    }
    add(t) {
        this.curves.push(t);
    }
    closePath() {
        const t = this.curves[0].getPoint(0), e861 = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e861) || this.curves.push(new Ys(e861, t));
    }
    getPoint(t, e862) {
        const n602 = t * this.getLength(), i411 = this.getCurveLengths();
        let r315 = 0;
        for(; r315 < i411.length;){
            if (i411[r315] >= n602) {
                const t = i411[r315] - n602, s212 = this.curves[r315], a174 = s212.getLength(), o140 = 0 === a174 ? 0 : 1 - t / a174;
                return s212.getPointAt(o140, e862);
            }
            r315++;
        }
        return null;
    }
    getLength() {
        const t = this.getCurveLengths();
        return t[t.length - 1];
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const t = [];
        let e863 = 0;
        for(let n603 = 0, i412 = this.curves.length; n603 < i412; n603++)e863 += this.curves[n603].getLength(), t.push(e863);
        return this.cacheLengths = t, t;
    }
    getSpacedPoints(t = 40) {
        const e864 = [];
        for(let n604 = 0; n604 <= t; n604++)e864.push(this.getPoint(n604 / t));
        return this.autoClose && e864.push(e864[0]), e864;
    }
    getPoints(t = 12) {
        const e865 = [];
        let n605;
        for(let i413 = 0, r316 = this.curves; i413 < r316.length; i413++){
            const s213 = r316[i413], a175 = s213.isEllipseCurve ? 2 * t : s213.isLineCurve || s213.isLineCurve3 ? 1 : s213.isSplineCurve ? t * s213.points.length : t, o141 = s213.getPoints(a175);
            for(let t221 = 0; t221 < o141.length; t221++){
                const i414 = o141[t221];
                n605 && n605.equals(i414) || (e865.push(i414), n605 = i414);
            }
        }
        return this.autoClose && e865.length > 1 && !e865[e865.length - 1].equals(e865[0]) && e865.push(e865[0]), e865;
    }
    copy(t) {
        super.copy(t), this.curves = [];
        for(let e866 = 0, n606 = t.curves.length; e866 < n606; e866++){
            const n607 = t.curves[e866];
            this.curves.push(n607.clone());
        }
        return this.autoClose = t.autoClose, this;
    }
    toJSON() {
        const t = super.toJSON();
        t.autoClose = this.autoClose, t.curves = [];
        for(let e867 = 0, n608 = this.curves.length; e867 < n608; e867++){
            const n609 = this.curves[e867];
            t.curves.push(n609.toJSON());
        }
        return t;
    }
    fromJSON(t) {
        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
        for(let e868 = 0, n610 = t.curves.length; e868 < n610; e868++){
            const n611 = t.curves[e868];
            this.curves.push((new Qs[n611.type]).fromJSON(n611));
        }
        return this;
    }
}
class ea extends ta {
    constructor(t){
        super(), this.type = "Path", this.currentPoint = new g, t && this.setFromPoints(t);
    }
    setFromPoints(t) {
        this.moveTo(t[0].x, t[0].y);
        for(let e869 = 1, n612 = t.length; e869 < n612; e869++)this.lineTo(t[e869].x, t[e869].y);
        return this;
    }
    moveTo(t, e870) {
        return this.currentPoint.set(t, e870), this;
    }
    lineTo(t, e871) {
        const n613 = new Ys(this.currentPoint.clone(), new g(t, e871));
        return this.curves.push(n613), this.currentPoint.set(t, e871), this;
    }
    quadraticCurveTo(t, e872, n614, i415) {
        const r317 = new Js(this.currentPoint.clone(), new g(t, e872), new g(n614, i415));
        return this.curves.push(r317), this.currentPoint.set(n614, i415), this;
    }
    bezierCurveTo(t, e873, n615, i416, r318, s214) {
        const a176 = new Xs(this.currentPoint.clone(), new g(t, e873), new g(n615, i416), new g(r318, s214));
        return this.curves.push(a176), this.currentPoint.set(r318, s214), this;
    }
    splineThru(t) {
        const e874 = [
            this.currentPoint.clone()
        ].concat(t), n616 = new Zs(e874);
        return this.curves.push(n616), this.currentPoint.copy(t[t.length - 1]), this;
    }
    arc(t, e875, n617, i417, r319, s215) {
        const a177 = this.currentPoint.x, o142 = this.currentPoint.y;
        return this.absarc(t + a177, e875 + o142, n617, i417, r319, s215), this;
    }
    absarc(t, e876, n618, i418, r320, s216) {
        return this.absellipse(t, e876, n618, n618, i418, r320, s216), this;
    }
    ellipse(t, e877, n619, i419, r321, s217, a178, o143) {
        const l124 = this.currentPoint.x, h101 = this.currentPoint.y;
        return this.absellipse(t + l124, e877 + h101, n619, i419, r321, s217, a178, o143), this;
    }
    absellipse(t, e878, n620, i420, r322, s218, a179, o144) {
        const l125 = new Fs(t, e878, n620, i420, r322, s218, a179, o144);
        if (this.curves.length > 0) {
            const t = l125.getPoint(0);
            t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
        }
        this.curves.push(l125);
        const h102 = l125.getPoint(1);
        return this.currentPoint.copy(h102), this;
    }
    copy(t) {
        return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
    }
    toJSON() {
        const t = super.toJSON();
        return t.currentPoint = this.currentPoint.toArray(), t;
    }
    fromJSON(t) {
        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
    }
}
new V, new V, new V, new ee;
class na extends ea {
    constructor(t){
        super(t), this.uuid = l(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(t) {
        const e879 = [];
        for(let n621 = 0, i421 = this.holes.length; n621 < i421; n621++)e879[n621] = this.holes[n621].getPoints(t);
        return e879;
    }
    extractPoints(t) {
        return {
            shape: this.getPoints(t),
            holes: this.getPointsHoles(t)
        };
    }
    copy(t) {
        super.copy(t), this.holes = [];
        for(let e880 = 0, n622 = t.holes.length; e880 < n622; e880++){
            const n623 = t.holes[e880];
            this.holes.push(n623.clone());
        }
        return this;
    }
    toJSON() {
        const t = super.toJSON();
        t.uuid = this.uuid, t.holes = [];
        for(let e881 = 0, n624 = this.holes.length; e881 < n624; e881++){
            const n625 = this.holes[e881];
            t.holes.push(n625.toJSON());
        }
        return t;
    }
    fromJSON(t) {
        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
        for(let e882 = 0, n626 = t.holes.length; e882 < n626; e882++){
            const n627 = t.holes[e882];
            this.holes.push((new ea).fromJSON(n627));
        }
        return this;
    }
}
const ia = function(t222, e883, n628 = 2) {
    const i422 = e883 && e883.length, r323 = i422 ? e883[0] * n628 : t222.length;
    let s219 = ra(t222, 0, r323, n628, !0);
    const a180 = [];
    if (!s219 || s219.next === s219.prev) return a180;
    let o145, l126, h103, c78, u71, d60, p53;
    if (i422 && (s219 = function(t, e884, n629, i423) {
        const r324 = [];
        let s220, a181, o146, l127, h104;
        for(s220 = 0, a181 = e884.length; s220 < a181; s220++)o146 = e884[s220] * i423, l127 = s220 < a181 - 1 ? e884[s220 + 1] * i423 : t.length, h104 = ra(t, o146, l127, i423, !1), h104 === h104.next && (h104.steiner = !0), r324.push(fa(h104));
        for(r324.sort(ua), s220 = 0; s220 < r324.length; s220++)da(r324[s220], n629), n629 = sa(n629, n629.next);
        return n629;
    }(t222, e883, s219, n628)), t222.length > 80 * n628) {
        o145 = h103 = t222[0], l126 = c78 = t222[1];
        for(let e885 = n628; e885 < r323; e885 += n628)u71 = t222[e885], d60 = t222[e885 + 1], u71 < o145 && (o145 = u71), d60 < l126 && (l126 = d60), u71 > h103 && (h103 = u71), d60 > c78 && (c78 = d60);
        p53 = Math.max(h103 - o145, c78 - l126), p53 = 0 !== p53 ? 1 / p53 : 0;
    }
    return aa(s219, a180, n628, o145, l126, p53), a180;
};
function ra(t223, e886, n630, i424, r325) {
    let s221, a182;
    if (r325 === function(t, e887, n631, i425) {
        let r326 = 0;
        for(let s222 = e887, a183 = n631 - i425; s222 < n631; s222 += i425)r326 += (t[a183] - t[s222]) * (t[s222 + 1] + t[a183 + 1]), a183 = s222;
        return r326;
    }(t223, e886, n630, i424) > 0) for(s221 = e886; s221 < n630; s221 += i424)a182 = Ta(s221, t223[s221], t223[s221 + 1], a182);
    else for(s221 = n630 - i424; s221 >= e886; s221 -= i424)a182 = Ta(s221, t223[s221], t223[s221 + 1], a182);
    return a182 && xa(a182, a182.next) && (Ea(a182), a182 = a182.next), a182;
}
function sa(t, e888) {
    if (!t) return t;
    e888 || (e888 = t);
    let n632, i426 = t;
    do if (n632 = !1, i426.steiner || !xa(i426, i426.next) && 0 !== ya(i426.prev, i426, i426.next)) i426 = i426.next;
    else {
        if (Ea(i426), i426 = e888 = i426.prev, i426 === i426.next) break;
        n632 = !0;
    }
    while (n632 || i426 !== e888);
    return e888;
}
function aa(t224, e889, n633, i427, r327, s223, a184) {
    if (!t224) return;
    !a184 && s223 && function(t225, e890, n634, i428) {
        let r328 = t225;
        do null === r328.z && (r328.z = ma(r328.x, r328.y, e890, n634, i428)), r328.prevZ = r328.prev, r328.nextZ = r328.next, r328 = r328.next;
        while (r328 !== t225);
        r328.prevZ.nextZ = null, r328.prevZ = null, function(t) {
            let e891, n635, i429, r329, s224, a185, o148, l129, h106 = 1;
            do {
                for(n635 = t, t = null, s224 = null, a185 = 0; n635;){
                    for(a185++, i429 = n635, o148 = 0, e891 = 0; e891 < h106 && (o148++, i429 = i429.nextZ, i429); e891++);
                    for(l129 = h106; o148 > 0 || l129 > 0 && i429;)0 !== o148 && (0 === l129 || !i429 || n635.z <= i429.z) ? (r329 = n635, n635 = n635.nextZ, o148--) : (r329 = i429, i429 = i429.nextZ, l129--), s224 ? s224.nextZ = r329 : t = r329, r329.prevZ = s224, s224 = r329;
                    n635 = i429;
                }
                s224.nextZ = null, h106 *= 2;
            }while (a185 > 1);
        }(r328);
    }(t224, i427, r327, s223);
    let o147, l128, h105 = t224;
    for(; t224.prev !== t224.next;)if (o147 = t224.prev, l128 = t224.next, s223 ? la(t224, i427, r327, s223) : oa(t224)) e889.push(o147.i / n633), e889.push(t224.i / n633), e889.push(l128.i / n633), Ea(t224), t224 = l128.next, h105 = l128.next;
    else if ((t224 = l128) === h105) {
        a184 ? 1 === a184 ? aa(t224 = ha(sa(t224), e889, n633), e889, n633, i427, r327, s223, 2) : 2 === a184 && ca(t224, e889, n633, i427, r327, s223) : aa(sa(t224), e889, n633, i427, r327, s223, 1);
        break;
    }
}
function oa(t) {
    const e892 = t.prev, n636 = t, i430 = t.next;
    if (ya(e892, n636, i430) >= 0) return !1;
    let r330 = t.next.next;
    for(; r330 !== t.prev;){
        if (ga(e892.x, e892.y, n636.x, n636.y, i430.x, i430.y, r330.x, r330.y) && ya(r330.prev, r330, r330.next) >= 0) return !1;
        r330 = r330.next;
    }
    return !0;
}
function la(t, e893, n637, i431) {
    const r331 = t.prev, s225 = t, a186 = t.next;
    if (ya(r331, s225, a186) >= 0) return !1;
    const o149 = r331.x < s225.x ? r331.x < a186.x ? r331.x : a186.x : s225.x < a186.x ? s225.x : a186.x, l130 = r331.y < s225.y ? r331.y < a186.y ? r331.y : a186.y : s225.y < a186.y ? s225.y : a186.y, h107 = r331.x > s225.x ? r331.x > a186.x ? r331.x : a186.x : s225.x > a186.x ? s225.x : a186.x, c79 = r331.y > s225.y ? r331.y > a186.y ? r331.y : a186.y : s225.y > a186.y ? s225.y : a186.y, u72 = ma(o149, l130, e893, n637, i431), d61 = ma(h107, c79, e893, n637, i431);
    let p54 = t.prevZ, m38 = t.nextZ;
    for(; p54 && p54.z >= u72 && m38 && m38.z <= d61;){
        if (p54 !== t.prev && p54 !== t.next && ga(r331.x, r331.y, s225.x, s225.y, a186.x, a186.y, p54.x, p54.y) && ya(p54.prev, p54, p54.next) >= 0) return !1;
        if (p54 = p54.prevZ, m38 !== t.prev && m38 !== t.next && ga(r331.x, r331.y, s225.x, s225.y, a186.x, a186.y, m38.x, m38.y) && ya(m38.prev, m38, m38.next) >= 0) return !1;
        m38 = m38.nextZ;
    }
    for(; p54 && p54.z >= u72;){
        if (p54 !== t.prev && p54 !== t.next && ga(r331.x, r331.y, s225.x, s225.y, a186.x, a186.y, p54.x, p54.y) && ya(p54.prev, p54, p54.next) >= 0) return !1;
        p54 = p54.prevZ;
    }
    for(; m38 && m38.z <= d61;){
        if (m38 !== t.prev && m38 !== t.next && ga(r331.x, r331.y, s225.x, s225.y, a186.x, a186.y, m38.x, m38.y) && ya(m38.prev, m38, m38.next) >= 0) return !1;
        m38 = m38.nextZ;
    }
    return !0;
}
function ha(t, e894, n638) {
    let i432 = t;
    do {
        const r332 = i432.prev, s226 = i432.next.next;
        !xa(r332, s226) && ba(r332, i432, i432.next, s226) && Ma(r332, s226) && Ma(s226, r332) && (e894.push(r332.i / n638), e894.push(i432.i / n638), e894.push(s226.i / n638), Ea(i432), Ea(i432.next), i432 = t = s226), i432 = i432.next;
    }while (i432 !== t);
    return sa(i432);
}
function ca(t, e895, n639, i433, r333, s227) {
    let a187 = t;
    do {
        let t = a187.next.next;
        for(; t !== a187.prev;){
            if (a187.i !== t.i && va(a187, t)) {
                let o150 = Sa(a187, t);
                return a187 = sa(a187, a187.next), o150 = sa(o150, o150.next), aa(a187, e895, n639, i433, r333, s227), void aa(o150, e895, n639, i433, r333, s227);
            }
            t = t.next;
        }
        a187 = a187.next;
    }while (a187 !== t);
}
function ua(t, e896) {
    return t.x - e896.x;
}
function da(t226, e897) {
    if (e897 = function(t, e898) {
        let n640 = e898;
        const i434 = t.x, r334 = t.y;
        let s228, a188 = -1 / 0;
        do {
            if (r334 <= n640.y && r334 >= n640.next.y && n640.next.y !== n640.y) {
                const t = n640.x + (r334 - n640.y) * (n640.next.x - n640.x) / (n640.next.y - n640.y);
                if (t <= i434 && t > a188) {
                    if (a188 = t, t === i434) {
                        if (r334 === n640.y) return n640;
                        if (r334 === n640.next.y) return n640.next;
                    }
                    s228 = n640.x < n640.next.x ? n640 : n640.next;
                }
            }
            n640 = n640.next;
        }while (n640 !== e898);
        if (!s228) return null;
        if (i434 === a188) return s228;
        const o151 = s228, l131 = s228.x, h108 = s228.y;
        let c80, u73 = 1 / 0;
        n640 = s228;
        do i434 >= n640.x && n640.x >= l131 && i434 !== n640.x && ga(r334 < h108 ? i434 : a188, r334, l131, h108, r334 < h108 ? a188 : i434, r334, n640.x, n640.y) && (c80 = Math.abs(r334 - n640.y) / (i434 - n640.x), Ma(n640, t) && (c80 < u73 || c80 === u73 && (n640.x > s228.x || n640.x === s228.x && pa(s228, n640))) && (s228 = n640, u73 = c80)), n640 = n640.next;
        while (n640 !== o151);
        return s228;
    }(t226, e897), e897) {
        const n641 = Sa(e897, t226);
        sa(e897, e897.next), sa(n641, n641.next);
    }
}
function pa(t, e899) {
    return ya(t.prev, t, e899.prev) < 0 && ya(e899.next, t, t.next) < 0;
}
function ma(t, e900, n642, i435, r335) {
    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n642) * r335) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e900 = 1431655765 & ((e900 = 858993459 & ((e900 = 252645135 & ((e900 = 16711935 & ((e900 = 32767 * (e900 - i435) * r335) | e900 << 8)) | e900 << 4)) | e900 << 2)) | e900 << 1)) << 1;
}
function fa(t) {
    let e901 = t, n643 = t;
    do (e901.x < n643.x || e901.x === n643.x && e901.y < n643.y) && (n643 = e901), e901 = e901.next;
    while (e901 !== t);
    return n643;
}
function ga(t, e902, n644, i436, r336, s229, a189, o152) {
    return (r336 - a189) * (e902 - o152) - (t - a189) * (s229 - o152) >= 0 && (t - a189) * (i436 - o152) - (n644 - a189) * (e902 - o152) >= 0 && (n644 - a189) * (s229 - o152) - (r336 - a189) * (i436 - o152) >= 0;
}
function va(t227, e903) {
    return t227.next.i !== e903.i && t227.prev.i !== e903.i && !function(t, e904) {
        let n645 = t;
        do {
            if (n645.i !== t.i && n645.next.i !== t.i && n645.i !== e904.i && n645.next.i !== e904.i && ba(n645, n645.next, t, e904)) return !0;
            n645 = n645.next;
        }while (n645 !== t);
        return !1;
    }(t227, e903) && (Ma(t227, e903) && Ma(e903, t227) && function(t, e905) {
        let n646 = t, i437 = !1;
        const r337 = (t.x + e905.x) / 2, s230 = (t.y + e905.y) / 2;
        do n646.y > s230 != n646.next.y > s230 && n646.next.y !== n646.y && r337 < (n646.next.x - n646.x) * (s230 - n646.y) / (n646.next.y - n646.y) + n646.x && (i437 = !i437), n646 = n646.next;
        while (n646 !== t);
        return i437;
    }(t227, e903) && (ya(t227.prev, t227, e903.prev) || ya(t227, e903.prev, e903)) || xa(t227, e903) && ya(t227.prev, t227, t227.next) > 0 && ya(e903.prev, e903, e903.next) > 0);
}
function ya(t, e906, n647) {
    return (e906.y - t.y) * (n647.x - e906.x) - (e906.x - t.x) * (n647.y - e906.y);
}
function xa(t, e907) {
    return t.x === e907.x && t.y === e907.y;
}
function ba(t, e908, n648, i438) {
    const r338 = wa(ya(t, e908, n648)), s231 = wa(ya(t, e908, i438)), a190 = wa(ya(n648, i438, t)), o153 = wa(ya(n648, i438, e908));
    return r338 !== s231 && a190 !== o153 || !(0 !== r338 || !_a(t, n648, e908)) || !(0 !== s231 || !_a(t, i438, e908)) || !(0 !== a190 || !_a(n648, t, i438)) || !(0 !== o153 || !_a(n648, e908, i438));
}
function _a(t, e909, n649) {
    return e909.x <= Math.max(t.x, n649.x) && e909.x >= Math.min(t.x, n649.x) && e909.y <= Math.max(t.y, n649.y) && e909.y >= Math.min(t.y, n649.y);
}
function wa(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0;
}
function Ma(t, e910) {
    return ya(t.prev, t, t.next) < 0 ? ya(t, e910, t.next) >= 0 && ya(t, t.prev, e910) >= 0 : ya(t, e910, t.prev) < 0 || ya(t, t.next, e910) < 0;
}
function Sa(t, e911) {
    const n650 = new Aa(t.i, t.x, t.y), i439 = new Aa(e911.i, e911.x, e911.y), r339 = t.next, s232 = e911.prev;
    return t.next = e911, e911.prev = t, n650.next = r339, r339.prev = n650, i439.next = n650, n650.prev = i439, s232.next = i439, i439.prev = s232, i439;
}
function Ta(t, e912, n651, i440) {
    const r340 = new Aa(t, e912, n651);
    return i440 ? (r340.next = i440.next, r340.prev = i440, i440.next.prev = r340, i440.next = r340) : (r340.prev = r340, r340.next = r340), r340;
}
function Ea(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
}
function Aa(t, e913, n652) {
    this.i = t, this.x = e913, this.y = n652, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
class Ra {
    static area(t) {
        const e914 = t.length;
        let n653 = 0;
        for(let i441 = e914 - 1, r341 = 0; r341 < e914; i441 = r341++)n653 += t[i441].x * t[r341].y - t[r341].x * t[i441].y;
        return .5 * n653;
    }
    static isClockWise(t) {
        return Ra.area(t) < 0;
    }
    static triangulateShape(t, e915) {
        const n654 = [], i442 = [], r342 = [];
        Ca(t), La(n654, t);
        let s233 = t.length;
        e915.forEach(Ca);
        for(let t228 = 0; t228 < e915.length; t228++)i442.push(s233), s233 += e915[t228].length, La(n654, e915[t228]);
        const a191 = ia(n654, i442);
        for(let t229 = 0; t229 < a191.length; t229 += 3)r342.push(a191.slice(t229, t229 + 3));
        return r342;
    }
}
function Ca(t) {
    const e916 = t.length;
    e916 > 2 && t[e916 - 1].equals(t[0]) && t.pop();
}
function La(t, e917) {
    for(let n655 = 0; n655 < e917.length; n655++)t.push(e917[n655].x), t.push(e917[n655].y);
}
class Pa extends ye {
    constructor(t237 = new na([
        new g(.5, .5),
        new g(-0.5, .5),
        new g(-0.5, -0.5),
        new g(.5, -0.5)
    ]), e919 = {}){
        super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: t237,
            options: e919
        }, t237 = Array.isArray(t237) ? t237 : [
            t237
        ];
        const n657 = this, i443 = [], r343 = [];
        for(let e918 = 0, n656 = t237.length; e918 < n656; e918++)s234(t237[e918]);
        function s234(t238) {
            const s235 = [], a192 = void 0 !== e919.curveSegments ? e919.curveSegments : 12, o154 = void 0 !== e919.steps ? e919.steps : 1;
            let l132 = void 0 !== e919.depth ? e919.depth : 1, h109 = void 0 === e919.bevelEnabled || e919.bevelEnabled, c81 = void 0 !== e919.bevelThickness ? e919.bevelThickness : .2, u74 = void 0 !== e919.bevelSize ? e919.bevelSize : c81 - .1, d62 = void 0 !== e919.bevelOffset ? e919.bevelOffset : 0, p55 = void 0 !== e919.bevelSegments ? e919.bevelSegments : 3;
            const m39 = e919.extrudePath, f32 = void 0 !== e919.UVGenerator ? e919.UVGenerator : Da;
            void 0 !== e919.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l132 = e919.amount);
            let v26, y27, x24, b22, _18, w13 = !1;
            m39 && (v26 = m39.getSpacedPoints(o154), w13 = !0, h109 = !1, y27 = m39.computeFrenetFrames(o154, !1), x24 = new V, b22 = new V, _18 = new V), h109 || (p55 = 0, c81 = 0, u74 = 0, d62 = 0);
            const M10 = t238.extractPoints(a192);
            let S9 = M10.shape;
            const T11 = M10.holes;
            if (!Ra.isClockWise(S9)) {
                S9 = S9.reverse();
                for(let t = 0, e923 = T11.length; t < e923; t++){
                    const e924 = T11[t];
                    Ra.isClockWise(e924) && (T11[t] = e924.reverse());
                }
            }
            const E9 = Ra.triangulateShape(S9, T11), A9 = S9;
            for(let t230 = 0, e925 = T11.length; t230 < e925; t230++){
                const e926 = T11[t230];
                S9 = S9.concat(e926);
            }
            function R8(t, e927, n659) {
                return e927 || console.error("THREE.ExtrudeGeometry: vec does not exist"), e927.clone().multiplyScalar(n659).add(t);
            }
            const C7 = S9.length, L7 = E9.length;
            function P7(t, e928, n660) {
                let i445, r344, s236;
                const a193 = t.x - e928.x, o155 = t.y - e928.y, l133 = n660.x - t.x, h110 = n660.y - t.y, c82 = a193 * a193 + o155 * o155, u75 = a193 * h110 - o155 * l133;
                if (Math.abs(u75) > Number.EPSILON) {
                    const u76 = Math.sqrt(c82), d63 = Math.sqrt(l133 * l133 + h110 * h110), p56 = e928.x - o155 / u76, m40 = e928.y + a193 / u76, f33 = ((n660.x - h110 / d63 - p56) * h110 - (n660.y + l133 / d63 - m40) * l133) / (a193 * h110 - o155 * l133);
                    i445 = p56 + a193 * f33 - t.x, r344 = m40 + o155 * f33 - t.y;
                    const v27 = i445 * i445 + r344 * r344;
                    if (v27 <= 2) return new g(i445, r344);
                    s236 = Math.sqrt(v27 / 2);
                } else {
                    let t = !1;
                    a193 > Number.EPSILON ? l133 > Number.EPSILON && (t = !0) : a193 < -Number.EPSILON ? l133 < -Number.EPSILON && (t = !0) : Math.sign(o155) === Math.sign(h110) && (t = !0), t ? (i445 = -o155, r344 = a193, s236 = Math.sqrt(c82)) : (i445 = a193, r344 = o155, s236 = Math.sqrt(c82 / 2));
                }
                return new g(i445 / s236, r344 / s236);
            }
            const D6 = [];
            for(let t231 = 0, e920 = A9.length, n658 = e920 - 1, i444 = t231 + 1; t231 < e920; t231++, n658++, i444++)n658 === e920 && (n658 = 0), i444 === e920 && (i444 = 0), D6[t231] = P7(A9[t231], A9[n658], A9[i444]);
            const I7 = [];
            let O7, N7 = D6.concat();
            for(let t232 = 0, e921 = T11.length; t232 < e921; t232++){
                const e929 = T11[t232];
                O7 = [];
                for(let t = 0, n661 = e929.length, i446 = n661 - 1, r345 = t + 1; t < n661; t++, i446++, r345++)i446 === n661 && (i446 = 0), r345 === n661 && (r345 = 0), O7[t] = P7(e929[t], e929[i446], e929[r345]);
                I7.push(O7), N7 = N7.concat(O7);
            }
            for(let t233 = 0; t233 < p55; t233++){
                const e932 = t233 / p55, n662 = c81 * Math.cos(e932 * Math.PI / 2), i447 = u74 * Math.sin(e932 * Math.PI / 2) + d62;
                for(let t = 0, e930 = A9.length; t < e930; t++){
                    const e933 = R8(A9[t], D6[t], i447);
                    k3(e933.x, e933.y, -n662);
                }
                for(let t239 = 0, e931 = T11.length; t239 < e931; t239++){
                    const e934 = T11[t239];
                    O7 = I7[t239];
                    for(let t = 0, r346 = e934.length; t < r346; t++){
                        const r347 = R8(e934[t], O7[t], i447);
                        k3(r347.x, r347.y, -n662);
                    }
                }
            }
            const F5 = u74 + d62;
            for(let t234 = 0; t234 < C7; t234++){
                const e935 = h109 ? R8(S9[t234], N7[t234], F5) : S9[t234];
                w13 ? (b22.copy(y27.normals[0]).multiplyScalar(e935.x), x24.copy(y27.binormals[0]).multiplyScalar(e935.y), _18.copy(v26[0]).add(b22).add(x24), k3(_18.x, _18.y, _18.z)) : k3(e935.x, e935.y, 0);
            }
            for(let t235 = 1; t235 <= o154; t235++)for(let e922 = 0; e922 < C7; e922++){
                const n663 = h109 ? R8(S9[e922], N7[e922], F5) : S9[e922];
                w13 ? (b22.copy(y27.normals[t235]).multiplyScalar(n663.x), x24.copy(y27.binormals[t235]).multiplyScalar(n663.y), _18.copy(v26[t235]).add(b22).add(x24), k3(_18.x, _18.y, _18.z)) : k3(n663.x, n663.y, l132 / o154 * t235);
            }
            for(let t236 = p55 - 1; t236 >= 0; t236--){
                const e938 = t236 / p55, n664 = c81 * Math.cos(e938 * Math.PI / 2), i448 = u74 * Math.sin(e938 * Math.PI / 2) + d62;
                for(let t = 0, e936 = A9.length; t < e936; t++){
                    const e939 = R8(A9[t], D6[t], i448);
                    k3(e939.x, e939.y, l132 + n664);
                }
                for(let t240 = 0, e937 = T11.length; t240 < e937; t240++){
                    const e940 = T11[t240];
                    O7 = I7[t240];
                    for(let t = 0, r348 = e940.length; t < r348; t++){
                        const r349 = R8(e940[t], O7[t], i448);
                        w13 ? k3(r349.x, r349.y + v26[o154 - 1].y, v26[o154 - 1].x + n664) : k3(r349.x, r349.y, l132 + n664);
                    }
                }
            }
            function U2(t, e941) {
                let n665 = t.length;
                for(; --n665 >= 0;){
                    const i449 = n665;
                    let r350 = n665 - 1;
                    r350 < 0 && (r350 = t.length - 1);
                    for(let t241 = 0, n666 = o154 + 2 * p55; t241 < n666; t241++){
                        const n667 = C7 * t241, s237 = C7 * (t241 + 1);
                        z4(e941 + i449 + n667, e941 + r350 + n667, e941 + r350 + s237, e941 + i449 + s237);
                    }
                }
            }
            function k3(t, e942, n668) {
                s235.push(t), s235.push(e942), s235.push(n668);
            }
            function B4(t, e943, r351) {
                H4(t), H4(e943), H4(r351);
                const s238 = i443.length / 3, a194 = f32.generateTopUV(n657, i443, s238 - 3, s238 - 2, s238 - 1);
                G4(a194[0]), G4(a194[1]), G4(a194[2]);
            }
            function z4(t, e944, r352, s239) {
                H4(t), H4(e944), H4(s239), H4(e944), H4(r352), H4(s239);
                const a195 = i443.length / 3, o156 = f32.generateSideWallUV(n657, i443, a195 - 6, a195 - 3, a195 - 2, a195 - 1);
                G4(o156[0]), G4(o156[1]), G4(o156[3]), G4(o156[1]), G4(o156[2]), G4(o156[3]);
            }
            function H4(t) {
                i443.push(s235[3 * t + 0]), i443.push(s235[3 * t + 1]), i443.push(s235[3 * t + 2]);
            }
            function G4(t) {
                r343.push(t.x), r343.push(t.y);
            }
            !function() {
                const t = i443.length / 3;
                if (h109) {
                    let t = 0, e945 = C7 * t;
                    for(let t242 = 0; t242 < L7; t242++){
                        const n669 = E9[t242];
                        B4(n669[2] + e945, n669[1] + e945, n669[0] + e945);
                    }
                    t = o154 + 2 * p55, e945 = C7 * t;
                    for(let t243 = 0; t243 < L7; t243++){
                        const n670 = E9[t243];
                        B4(n670[0] + e945, n670[1] + e945, n670[2] + e945);
                    }
                } else {
                    for(let t = 0; t < L7; t++){
                        const e946 = E9[t];
                        B4(e946[2], e946[1], e946[0]);
                    }
                    for(let t244 = 0; t244 < L7; t244++){
                        const e947 = E9[t244];
                        B4(e947[0] + C7 * o154, e947[1] + C7 * o154, e947[2] + C7 * o154);
                    }
                }
                n657.addGroup(t, i443.length / 3 - t, 0);
            }(), function() {
                const t = i443.length / 3;
                let e948 = 0;
                U2(A9, e948), e948 += A9.length;
                for(let t245 = 0, n671 = T11.length; t245 < n671; t245++){
                    const n672 = T11[t245];
                    U2(n672, e948), e948 += n672.length;
                }
                n657.addGroup(t, i443.length / 3 - t, 1);
            }();
        }
        this.setAttribute("position", new ce(i443, 3)), this.setAttribute("uv", new ce(r343, 2)), this.computeVertexNormals();
    }
    toJSON() {
        const t246 = super.toJSON();
        return function(t, e950, n673) {
            if (n673.shapes = [], Array.isArray(t)) for(let e949 = 0, i450 = t.length; e949 < i450; e949++){
                const i451 = t[e949];
                n673.shapes.push(i451.uuid);
            }
            else n673.shapes.push(t.uuid);
            void 0 !== e950.extrudePath && (n673.options.extrudePath = e950.extrudePath.toJSON());
            return n673;
        }(this.parameters.shapes, this.parameters.options, t246);
    }
    static fromJSON(t, e951) {
        const n674 = [];
        for(let i453 = 0, r353 = t.shapes.length; i453 < r353; i453++){
            const r354 = e951[t.shapes[i453]];
            n674.push(r354);
        }
        const i452 = t.options.extrudePath;
        return void 0 !== i452 && (t.options.extrudePath = (new Qs[i452.type]).fromJSON(i452)), new Pa(n674, t.options);
    }
}
const Da = {
    generateTopUV: function(t, e952, n675, i454, r355) {
        const s240 = e952[3 * n675], a196 = e952[3 * n675 + 1], o157 = e952[3 * i454], l134 = e952[3 * i454 + 1], h111 = e952[3 * r355], c83 = e952[3 * r355 + 1];
        return [
            new g(s240, a196),
            new g(o157, l134),
            new g(h111, c83)
        ];
    },
    generateSideWallUV: function(t, e953, n676, i455, r356, s241) {
        const a197 = e953[3 * n676], o158 = e953[3 * n676 + 1], l135 = e953[3 * n676 + 2], h112 = e953[3 * i455], c84 = e953[3 * i455 + 1], u77 = e953[3 * i455 + 2], d64 = e953[3 * r356], p57 = e953[3 * r356 + 1], m41 = e953[3 * r356 + 2], f34 = e953[3 * s241], v28 = e953[3 * s241 + 1], y28 = e953[3 * s241 + 2];
        return Math.abs(o158 - c84) < Math.abs(a197 - h112) ? [
            new g(a197, 1 - l135),
            new g(h112, 1 - u77),
            new g(d64, 1 - m41),
            new g(f34, 1 - y28)
        ] : [
            new g(o158, 1 - l135),
            new g(c84, 1 - u77),
            new g(p57, 1 - m41),
            new g(v28, 1 - y28)
        ];
    }
};
class Ia extends ye {
    constructor(t251 = new na([
        new g(0, .5),
        new g(-0.5, -0.5),
        new g(.5, -0.5)
    ]), e955 = 12){
        super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: t251,
            curveSegments: e955
        };
        const n677 = [], i456 = [], r357 = [], s242 = [];
        let a198 = 0, o159 = 0;
        if (!1 === Array.isArray(t251)) l136(t251);
        else for(let e954 = 0; e954 < t251.length; e954++)l136(t251[e954]), this.addGroup(a198, o159, e954), a198 += o159, o159 = 0;
        function l136(t) {
            const a199 = i456.length / 3, l137 = t.extractPoints(e955);
            let h113 = l137.shape;
            const c85 = l137.holes;
            !1 === Ra.isClockWise(h113) && (h113 = h113.reverse());
            for(let t247 = 0, e959 = c85.length; t247 < e959; t247++){
                const e960 = c85[t247];
                !0 === Ra.isClockWise(e960) && (c85[t247] = e960.reverse());
            }
            const u78 = Ra.triangulateShape(h113, c85);
            for(let t248 = 0, e956 = c85.length; t248 < e956; t248++){
                const e961 = c85[t248];
                h113 = h113.concat(e961);
            }
            for(let t249 = 0, e957 = h113.length; t249 < e957; t249++){
                const e962 = h113[t249];
                i456.push(e962.x, e962.y, 0), r357.push(0, 0, 1), s242.push(e962.x, e962.y);
            }
            for(let t250 = 0, e958 = u78.length; t250 < e958; t250++){
                const e963 = u78[t250], i457 = e963[0] + a199, r358 = e963[1] + a199, s243 = e963[2] + a199;
                n677.push(i457, r358, s243), o159 += 3;
            }
        }
        this.setIndex(n677), this.setAttribute("position", new ce(i456, 3)), this.setAttribute("normal", new ce(r357, 3)), this.setAttribute("uv", new ce(s242, 2));
    }
    toJSON() {
        const t252 = super.toJSON();
        return function(t, e964) {
            if (e964.shapes = [], Array.isArray(t)) for(let n678 = 0, i458 = t.length; n678 < i458; n678++){
                const i459 = t[n678];
                e964.shapes.push(i459.uuid);
            }
            else e964.shapes.push(t.uuid);
            return e964;
        }(this.parameters.shapes, t252);
    }
    static fromJSON(t, e965) {
        const n679 = [];
        for(let i460 = 0, r359 = t.shapes.length; i460 < r359; i460++){
            const r360 = e965[t.shapes[i460]];
            n679.push(r360);
        }
        return new Ia(n679, t.curveSegments);
    }
}
class Oa extends ie {
    constructor(t){
        super(), this.type = "ShadowMaterial", this.color = new L(0), this.transparent = !0, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this;
    }
}
Oa.prototype.isShadowMaterial = !0;
class Na extends Ve {
    constructor(t){
        super(t), this.type = "RawShaderMaterial";
    }
}
Na.prototype.isRawShaderMaterial = !0;
class Fa extends ie {
    constructor(t){
        super(), this.defines = {
            STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new L(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.defines = {
            STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this;
    }
}
Fa.prototype.isMeshStandardMaterial = !0;
class Ua extends Fa {
    constructor(t253){
        super(), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new g(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
                return h(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t);
            }
        }), this.sheenColor = new L(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new L(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new L(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t253);
    }
    get sheen() {
        return this._sheen;
    }
    set sheen(t) {
        this._sheen > 0 != t > 0 && this.version++, this._sheen = t;
    }
    get clearcoat() {
        return this._clearcoat;
    }
    set clearcoat(t) {
        this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
    }
    get transmission() {
        return this._transmission;
    }
    set transmission(t) {
        this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
    }
    copy(t) {
        return super.copy(t), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
    }
}
Ua.prototype.isMeshPhysicalMaterial = !0;
class ka extends ie {
    constructor(t){
        super(), this.type = "MeshPhongMaterial", this.color = new L(16777215), this.specular = new L(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this;
    }
}
ka.prototype.isMeshPhongMaterial = !0;
class Ba extends ie {
    constructor(t){
        super(), this.defines = {
            TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new L(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
    }
}
Ba.prototype.isMeshToonMaterial = !0;
class za extends ie {
    constructor(t){
        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this;
    }
}
za.prototype.isMeshNormalMaterial = !0;
class Ha extends ie {
    constructor(t){
        super(), this.type = "MeshLambertMaterial", this.color = new L(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new L(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
    }
}
Ha.prototype.isMeshLambertMaterial = !0;
class Va extends ie {
    constructor(t){
        super(), this.defines = {
            MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new L(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new g(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.defines = {
            MATCAP: ""
        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this;
    }
}
Va.prototype.isMeshMatcapMaterial = !0;
class Ga extends gs {
    constructor(t){
        super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
    }
    copy(t) {
        return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
    }
}
Ga.prototype.isLineDashedMaterial = !0;
const Wa = {
    ShadowMaterial: Oa,
    SpriteMaterial: Br,
    RawShaderMaterial: Na,
    ShaderMaterial: Ve,
    PointsMaterial: As,
    MeshPhysicalMaterial: Ua,
    MeshStandardMaterial: Fa,
    MeshPhongMaterial: ka,
    MeshToonMaterial: Ba,
    MeshNormalMaterial: za,
    MeshLambertMaterial: Ha,
    MeshDepthMaterial: _r,
    MeshDistanceMaterial: wr,
    MeshBasicMaterial: re,
    MeshMatcapMaterial: Va,
    LineDashedMaterial: Ga,
    LineBasicMaterial: gs,
    Material: ie
};
ie.fromType = function(t) {
    return new Wa[t];
};
const ja = {
    arraySlice: function(t, e966, n680) {
        return ja.isTypedArray(t) ? new t.constructor(t.subarray(e966, void 0 !== n680 ? n680 : t.length)) : t.slice(e966, n680);
    },
    convertArray: function(t, e967, n681) {
        return !t || !n681 && t.constructor === e967 ? t : "number" == typeof e967.BYTES_PER_ELEMENT ? new e967(t) : Array.prototype.slice.call(t);
    },
    isTypedArray: function(t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView);
    },
    getKeyframeOrder: function(t) {
        const e968 = t.length, n682 = new Array(e968);
        for(let t254 = 0; t254 !== e968; ++t254)n682[t254] = t254;
        return n682.sort(function(e969, n683) {
            return t[e969] - t[n683];
        }), n682;
    },
    sortedArray: function(t, e970, n685) {
        const i461 = t.length, r361 = new t.constructor(i461);
        for(let s244 = 0, a200 = 0; a200 !== i461; ++s244){
            const i462 = n685[s244] * e970;
            for(let n684 = 0; n684 !== e970; ++n684)r361[a200++] = t[i462 + n684];
        }
        return r361;
    },
    flattenJSON: function(t, e971, n686, i463) {
        let r362 = 1, s245 = t[0];
        for(; void 0 !== s245 && void 0 === s245[i463];)s245 = t[r362++];
        if (void 0 === s245) return;
        let a201 = s245[i463];
        if (void 0 !== a201) {
            if (Array.isArray(a201)) do a201 = s245[i463], void 0 !== a201 && (e971.push(s245.time), n686.push.apply(n686, a201)), s245 = t[r362++];
            while (void 0 !== s245);
            else if (void 0 !== a201.toArray) do a201 = s245[i463], void 0 !== a201 && (e971.push(s245.time), a201.toArray(n686, n686.length)), s245 = t[r362++];
            while (void 0 !== s245);
            else do a201 = s245[i463], void 0 !== a201 && (e971.push(s245.time), n686.push(a201)), s245 = t[r362++];
            while (void 0 !== s245);
        }
    },
    subclip: function(t, e972, n687, i464, r363 = 30) {
        const s246 = t.clone();
        s246.name = e972;
        const a202 = [];
        for(let t255 = 0; t255 < s246.tracks.length; ++t255){
            const e973 = s246.tracks[t255], o160 = e973.getValueSize(), l138 = [], h114 = [];
            for(let t = 0; t < e973.times.length; ++t){
                const s247 = e973.times[t] * r363;
                if (!(s247 < n687 || s247 >= i464)) {
                    l138.push(e973.times[t]);
                    for(let n688 = 0; n688 < o160; ++n688)h114.push(e973.values[t * o160 + n688]);
                }
            }
            0 !== l138.length && (e973.times = ja.convertArray(l138, e973.times.constructor), e973.values = ja.convertArray(h114, e973.values.constructor), a202.push(e973));
        }
        s246.tracks = a202;
        let o161 = 1 / 0;
        for(let t256 = 0; t256 < s246.tracks.length; ++t256)o161 > s246.tracks[t256].times[0] && (o161 = s246.tracks[t256].times[0]);
        for(let t257 = 0; t257 < s246.tracks.length; ++t257)s246.tracks[t257].shift(-1 * o161);
        return s246.resetDuration(), s246;
    },
    makeClipAdditive: function(t259, e975 = 0, n689 = t259, i465 = 30) {
        i465 <= 0 && (i465 = 30);
        const r364 = n689.tracks.length, s248 = e975 / i465;
        for(let e974 = 0; e974 < r364; ++e974){
            const i466 = n689.tracks[e974], r365 = i466.ValueTypeName;
            if ("bool" === r365 || "string" === r365) continue;
            const a203 = t259.tracks.find(function(t) {
                return t.name === i466.name && t.ValueTypeName === r365;
            });
            if (void 0 === a203) continue;
            let o162 = 0;
            const l139 = i466.getValueSize();
            i466.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o162 = l139 / 3);
            let h115 = 0;
            const c86 = a203.getValueSize();
            a203.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h115 = c86 / 3);
            const u79 = i466.times.length - 1;
            let d65;
            if (s248 <= i466.times[0]) {
                const t = o162, e976 = l139 - o162;
                d65 = ja.arraySlice(i466.values, t, e976);
            } else if (s248 >= i466.times[u79]) {
                const t = u79 * l139 + o162, e977 = t + l139 - o162;
                d65 = ja.arraySlice(i466.values, t, e977);
            } else {
                const t = i466.createInterpolant(), e978 = o162, n690 = l139 - o162;
                t.evaluate(s248), d65 = ja.arraySlice(t.resultBuffer, e978, n690);
            }
            if ("quaternion" === r365) (new H).fromArray(d65).normalize().conjugate().toArray(d65);
            const p58 = a203.times.length;
            for(let t258 = 0; t258 < p58; ++t258){
                const e979 = t258 * c86 + h115;
                if ("quaternion" === r365) H.multiplyQuaternionsFlat(a203.values, e979, d65, 0, a203.values, e979);
                else {
                    const t = c86 - 2 * h115;
                    for(let n691 = 0; n691 < t; ++n691)a203.values[e979 + n691] -= d65[n691];
                }
            }
        }
        return t259.blendMode = 2501, t259;
    }
};
class qa {
    constructor(t, e980, n692, i467){
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i467 ? i467 : new e980.constructor(n692), this.sampleValues = e980, this.valueSize = n692, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(t) {
        const e981 = this.parameterPositions;
        let n693 = this._cachedIndex, i468 = e981[n693], r366 = e981[n693 - 1];
        t: {
            e: {
                let s250;
                n: {
                    i: if (!(t < i468)) {
                        for(let s249 = n693 + 2;;){
                            if (void 0 === i468) {
                                if (t < r366) break i;
                                return n693 = e981.length, this._cachedIndex = n693, this.afterEnd_(n693 - 1, t, r366);
                            }
                            if (n693 === s249) break;
                            if (r366 = i468, i468 = e981[++n693], t < i468) break e;
                        }
                        s250 = e981.length;
                        break n;
                    }
                    if (t >= r366) break t;
                    {
                        const a204 = e981[1];
                        t < a204 && (n693 = 2, r366 = a204);
                        for(let s251 = n693 - 2;;){
                            if (void 0 === r366) return this._cachedIndex = 0, this.beforeStart_(0, t, i468);
                            if (n693 === s251) break;
                            if (i468 = r366, r366 = e981[--n693 - 1], t >= r366) break e;
                        }
                        s250 = n693, n693 = 0;
                    }
                }
                for(; n693 < s250;){
                    const i469 = n693 + s250 >>> 1;
                    t < e981[i469] ? s250 = i469 : n693 = i469 + 1;
                }
                if (i468 = e981[n693], r366 = e981[n693 - 1], void 0 === r366) return this._cachedIndex = 0, this.beforeStart_(0, t, i468);
                if (void 0 === i468) return n693 = e981.length, this._cachedIndex = n693, this.afterEnd_(n693 - 1, r366, t);
            }
            this._cachedIndex = n693, this.intervalChanged_(n693, r366, i468);
        }
        return this.interpolate_(n693, r366, t, i468);
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t) {
        const e982 = this.resultBuffer, n694 = this.sampleValues, i470 = this.valueSize, r367 = t * i470;
        for(let t260 = 0; t260 !== i470; ++t260)e982[t260] = n694[r367 + t260];
        return e982;
    }
    interpolate_() {
        throw new Error("call to abstract method");
    }
    intervalChanged_() {}
}
qa.prototype.beforeStart_ = qa.prototype.copySampleValue_, qa.prototype.afterEnd_ = qa.prototype.copySampleValue_;
class Xa extends qa {
    constructor(t, e983, n695, i471){
        super(t, e983, n695, i471), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: 2400,
            endingEnd: 2400
        };
    }
    intervalChanged_(t, e984, n696) {
        const i472 = this.parameterPositions;
        let r368 = t - 2, s252 = t + 1, a205 = i472[r368], o163 = i472[s252];
        if (void 0 === a205) switch(this.getSettings_().endingStart){
            case 2401:
                r368 = t, a205 = 2 * e984 - n696;
                break;
            case 2402:
                r368 = i472.length - 2, a205 = e984 + i472[r368] - i472[r368 + 1];
                break;
            default:
                r368 = t, a205 = n696;
        }
        if (void 0 === o163) switch(this.getSettings_().endingEnd){
            case 2401:
                s252 = t, o163 = 2 * n696 - e984;
                break;
            case 2402:
                s252 = 1, o163 = n696 + i472[1] - i472[0];
                break;
            default:
                s252 = t - 1, o163 = e984;
        }
        const l140 = .5 * (n696 - e984), h116 = this.valueSize;
        this._weightPrev = l140 / (e984 - a205), this._weightNext = l140 / (o163 - n696), this._offsetPrev = r368 * h116, this._offsetNext = s252 * h116;
    }
    interpolate_(t, e985, n697, i473) {
        const r369 = this.resultBuffer, s253 = this.sampleValues, a206 = this.valueSize, o164 = t * a206, l141 = o164 - a206, h117 = this._offsetPrev, c87 = this._offsetNext, u80 = this._weightPrev, d66 = this._weightNext, p59 = (n697 - e985) / (i473 - e985), m42 = p59 * p59, f35 = m42 * p59, g27 = -u80 * f35 + 2 * u80 * m42 - u80 * p59, v29 = (1 + u80) * f35 + (-1.5 - 2 * u80) * m42 + (-0.5 + u80) * p59 + 1, y29 = (-1 - d66) * f35 + (1.5 + d66) * m42 + .5 * p59, x25 = d66 * f35 - d66 * m42;
        for(let t261 = 0; t261 !== a206; ++t261)r369[t261] = g27 * s253[h117 + t261] + v29 * s253[l141 + t261] + y29 * s253[o164 + t261] + x25 * s253[c87 + t261];
        return r369;
    }
}
class $a extends qa {
    constructor(t, e986, n698, i474){
        super(t, e986, n698, i474);
    }
    interpolate_(t, e987, n699, i475) {
        const r370 = this.resultBuffer, s254 = this.sampleValues, a207 = this.valueSize, o165 = t * a207, l142 = o165 - a207, h118 = (n699 - e987) / (i475 - e987), c88 = 1 - h118;
        for(let t262 = 0; t262 !== a207; ++t262)r370[t262] = s254[l142 + t262] * c88 + s254[o165 + t262] * h118;
        return r370;
    }
}
class Ya extends qa {
    constructor(t, e988, n700, i476){
        super(t, e988, n700, i476);
    }
    interpolate_(t) {
        return this.copySampleValue_(t - 1);
    }
}
class Ja {
    constructor(t, e989, n701, i477){
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e989 || 0 === e989.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = ja.convertArray(e989, this.TimeBufferType), this.values = ja.convertArray(n701, this.ValueBufferType), this.setInterpolation(i477 || this.DefaultInterpolation);
    }
    static toJSON(t) {
        const e990 = t.constructor;
        let n702;
        if (e990.toJSON !== this.toJSON) n702 = e990.toJSON(t);
        else {
            n702 = {
                name: t.name,
                times: ja.convertArray(t.times, Array),
                values: ja.convertArray(t.values, Array)
            };
            const e991 = t.getInterpolation();
            e991 !== t.DefaultInterpolation && (n702.interpolation = e991);
        }
        return n702.type = t.ValueTypeName, n702;
    }
    InterpolantFactoryMethodDiscrete(t) {
        return new Ya(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodLinear(t) {
        return new $a(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodSmooth(t) {
        return new Xa(this.times, this.values, this.getValueSize(), t);
    }
    setInterpolation(t) {
        let e992;
        switch(t){
            case 2300:
                e992 = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                e992 = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                e992 = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === e992) {
            const e993 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e993);
                this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", e993), this;
        }
        return this.createInterpolant = e992, this;
    }
    getInterpolation() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302;
        }
    }
    getValueSize() {
        return this.values.length / this.times.length;
    }
    shift(t) {
        if (0 !== t) {
            const e994 = this.times;
            for(let n703 = 0, i478 = e994.length; n703 !== i478; ++n703)e994[n703] += t;
        }
        return this;
    }
    scale(t) {
        if (1 !== t) {
            const e995 = this.times;
            for(let n704 = 0, i479 = e995.length; n704 !== i479; ++n704)e995[n704] *= t;
        }
        return this;
    }
    trim(t, e996) {
        const n705 = this.times, i480 = n705.length;
        let r371 = 0, s255 = i480 - 1;
        for(; r371 !== i480 && n705[r371] < t;)++r371;
        for(; -1 !== s255 && n705[s255] > e996;)--s255;
        if (++s255, 0 !== r371 || s255 !== i480) {
            r371 >= s255 && (s255 = Math.max(s255, 1), r371 = s255 - 1);
            const t = this.getValueSize();
            this.times = ja.arraySlice(n705, r371, s255), this.values = ja.arraySlice(this.values, r371 * t, s255 * t);
        }
        return this;
    }
    validate() {
        let t = !0;
        const e999 = this.getValueSize();
        e999 - Math.floor(e999) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
        const n707 = this.times, i482 = this.values, r372 = n707.length;
        0 === r372 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
        let s256 = null;
        for(let e997 = 0; e997 !== r372; e997++){
            const i481 = n707[e997];
            if ("number" == typeof i481 && isNaN(i481)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e997, i481), t = !1;
                break;
            }
            if (null !== s256 && s256 > i481) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, e997, i481, s256), t = !1;
                break;
            }
            s256 = i481;
        }
        if (void 0 !== i482 && ja.isTypedArray(i482)) for(let e998 = 0, n706 = i482.length; e998 !== n706; ++e998){
            const n708 = i482[e998];
            if (isNaN(n708)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e998, n708), t = !1;
                break;
            }
        }
        return t;
    }
    optimize() {
        const t = ja.arraySlice(this.times), e1000 = ja.arraySlice(this.values), n709 = this.getValueSize(), i483 = 2302 === this.getInterpolation(), r373 = t.length - 1;
        let s258 = 1;
        for(let a208 = 1; a208 < r373; ++a208){
            let r374 = !1;
            const o166 = t[a208];
            if (o166 !== t[a208 + 1] && (1 !== a208 || o166 !== t[0])) {
                if (i483) r374 = !0;
                else {
                    const t = a208 * n709, i484 = t - n709, s257 = t + n709;
                    for(let a209 = 0; a209 !== n709; ++a209){
                        const n710 = e1000[t + a209];
                        if (n710 !== e1000[i484 + a209] || n710 !== e1000[s257 + a209]) {
                            r374 = !0;
                            break;
                        }
                    }
                }
            }
            if (r374) {
                if (a208 !== s258) {
                    t[s258] = t[a208];
                    const i485 = a208 * n709, r375 = s258 * n709;
                    for(let t263 = 0; t263 !== n709; ++t263)e1000[r375 + t263] = e1000[i485 + t263];
                }
                ++s258;
            }
        }
        if (r373 > 0) {
            t[s258] = t[r373];
            for(let t266 = r373 * n709, i486 = s258 * n709, a210 = 0; a210 !== n709; ++a210)e1000[i486 + a210] = e1000[t266 + a210];
            ++s258;
        }
        return s258 !== t.length ? (this.times = ja.arraySlice(t, 0, s258), this.values = ja.arraySlice(e1000, 0, s258 * n709)) : (this.times = t, this.values = e1000), this;
    }
    clone() {
        const t = ja.arraySlice(this.times, 0), e1001 = ja.arraySlice(this.values, 0), n711 = new this.constructor(this.name, t, e1001);
        return n711.createInterpolant = this.createInterpolant, n711;
    }
}
Ja.prototype.TimeBufferType = Float32Array, Ja.prototype.ValueBufferType = Float32Array, Ja.prototype.DefaultInterpolation = 2301;
class Ka extends Ja {
}
Ka.prototype.ValueTypeName = "bool", Ka.prototype.ValueBufferType = Array, Ka.prototype.DefaultInterpolation = 2300, Ka.prototype.InterpolantFactoryMethodLinear = void 0, Ka.prototype.InterpolantFactoryMethodSmooth = void 0;
class Za extends Ja {
}
Za.prototype.ValueTypeName = "color";
class Qa extends Ja {
}
Qa.prototype.ValueTypeName = "number";
class to extends qa {
    constructor(t, e1002, n712, i487){
        super(t, e1002, n712, i487);
    }
    interpolate_(t, e1003, n713, i488) {
        const r376 = this.resultBuffer, s259 = this.sampleValues, a211 = this.valueSize, o167 = (n713 - e1003) / (i488 - e1003);
        let l143 = t * a211;
        for(let t267 = l143 + a211; l143 !== t267; l143 += 4)H.slerpFlat(r376, 0, s259, l143 - a211, s259, l143, o167);
        return r376;
    }
}
class eo extends Ja {
    InterpolantFactoryMethodLinear(t) {
        return new to(this.times, this.values, this.getValueSize(), t);
    }
}
eo.prototype.ValueTypeName = "quaternion", eo.prototype.DefaultInterpolation = 2301, eo.prototype.InterpolantFactoryMethodSmooth = void 0;
class no extends Ja {
}
no.prototype.ValueTypeName = "string", no.prototype.ValueBufferType = Array, no.prototype.DefaultInterpolation = 2300, no.prototype.InterpolantFactoryMethodLinear = void 0, no.prototype.InterpolantFactoryMethodSmooth = void 0;
class io extends Ja {
}
io.prototype.ValueTypeName = "vector";
class ro {
    constructor(t, e1004 = -1, n714, i489 = 2500){
        this.name = t, this.tracks = n714, this.duration = e1004, this.blendMode = i489, this.uuid = l(), this.duration < 0 && this.resetDuration();
    }
    static parse(t) {
        const e1005 = [], n715 = t.tracks, i490 = 1 / (t.fps || 1);
        for(let t268 = 0, r378 = n715.length; t268 !== r378; ++t268)e1005.push(so(n715[t268]).scale(i490));
        const r377 = new this(t.name, t.duration, e1005, t.blendMode);
        return r377.uuid = t.uuid, r377;
    }
    static toJSON(t) {
        const e1006 = [], n716 = t.tracks, i492 = {
            name: t.name,
            duration: t.duration,
            tracks: e1006,
            uuid: t.uuid,
            blendMode: t.blendMode
        };
        for(let t269 = 0, i491 = n716.length; t269 !== i491; ++t269)e1006.push(Ja.toJSON(n716[t269]));
        return i492;
    }
    static CreateFromMorphTargetSequence(t, e1007, n717, i493) {
        const r379 = e1007.length, s260 = [];
        for(let t270 = 0; t270 < r379; t270++){
            let a212 = [], o168 = [];
            a212.push((t270 + r379 - 1) % r379, t270, (t270 + 1) % r379), o168.push(0, 1, 0);
            const l144 = ja.getKeyframeOrder(a212);
            a212 = ja.sortedArray(a212, 1, l144), o168 = ja.sortedArray(o168, 1, l144), i493 || 0 !== a212[0] || (a212.push(r379), o168.push(o168[0])), s260.push(new Qa(".morphTargetInfluences[" + e1007[t270].name + "]", a212, o168).scale(1 / n717));
        }
        return new this(t, -1, s260);
    }
    static findByName(t, e1009) {
        let n718 = t;
        if (!Array.isArray(t)) {
            const e1008 = t;
            n718 = e1008.geometry && e1008.geometry.animations || e1008.animations;
        }
        for(let t271 = 0; t271 < n718.length; t271++)if (n718[t271].name === e1009) return n718[t271];
        return null;
    }
    static CreateClipsFromMorphTargetSequences(t, e1012, n721) {
        const i494 = {}, r380 = /^([\w-]*?)([\d]+)$/;
        for(let e1010 = 0, n719 = t.length; e1010 < n719; e1010++){
            const n720 = t[e1010], s261 = n720.name.match(r380);
            if (s261 && s261.length > 1) {
                const t = s261[1];
                let e1011 = i494[t];
                e1011 || (i494[t] = e1011 = []), e1011.push(n720);
            }
        }
        const s262 = [];
        for(const t272 in i494)s262.push(this.CreateFromMorphTargetSequence(t272, i494[t272], e1012, n721));
        return s262;
    }
    static parseAnimation(t274, e1013) {
        if (!t274) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const n722 = function(t, e1014, n723, i496, r382) {
            if (0 !== n723.length) {
                const s264 = [], a214 = [];
                ja.flattenJSON(n723, s264, a214, i496), 0 !== s264.length && r382.push(new t(e1014, s264, a214));
            }
        }, i495 = [], r381 = t274.name || "default", s263 = t274.fps || 30, a213 = t274.blendMode;
        let o169 = t274.length || -1;
        const l145 = t274.hierarchy || [];
        for(let t273 = 0; t273 < l145.length; t273++){
            const r383 = l145[t273].keys;
            if (r383 && 0 !== r383.length) {
                if (r383[0].morphTargets) {
                    const t = {};
                    let e1015;
                    for(e1015 = 0; e1015 < r383.length; e1015++)if (r383[e1015].morphTargets) for(let n725 = 0; n725 < r383[e1015].morphTargets.length; n725++)t[r383[e1015].morphTargets[n725]] = -1;
                    for(const n724 in t){
                        const t = [], s265 = [];
                        for(let i497 = 0; i497 !== r383[e1015].morphTargets.length; ++i497){
                            const i498 = r383[e1015];
                            t.push(i498.time), s265.push(i498.morphTarget === n724 ? 1 : 0);
                        }
                        i495.push(new Qa(".morphTargetInfluence[" + n724 + "]", t, s265));
                    }
                    o169 = t.length * s263;
                } else {
                    const s266 = ".bones[" + e1013[t273].name + "]";
                    n722(io, s266 + ".position", r383, "pos", i495), n722(eo, s266 + ".quaternion", r383, "rot", i495), n722(io, s266 + ".scale", r383, "scl", i495);
                }
            }
        }
        if (0 === i495.length) return null;
        return new this(r381, o169, i495, a213);
    }
    resetDuration() {
        let t = 0;
        for(let e1016 = 0, n726 = this.tracks.length; e1016 !== n726; ++e1016){
            const n727 = this.tracks[e1016];
            t = Math.max(t, n727.times[n727.times.length - 1]);
        }
        return this.duration = t, this;
    }
    trim() {
        for(let t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration);
        return this;
    }
    validate() {
        let t = !0;
        for(let e1017 = 0; e1017 < this.tracks.length; e1017++)t = t && this.tracks[e1017].validate();
        return t;
    }
    optimize() {
        for(let t = 0; t < this.tracks.length; t++)this.tracks[t].optimize();
        return this;
    }
    clone() {
        const t = [];
        for(let e1018 = 0; e1018 < this.tracks.length; e1018++)t.push(this.tracks[e1018].clone());
        return new this.constructor(this.name, this.duration, t, this.blendMode);
    }
    toJSON() {
        return this.constructor.toJSON(this);
    }
}
function so(t275) {
    if (void 0 === t275.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e1020 = function(t) {
        switch(t.toLowerCase()){
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return Qa;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return io;
            case "color":
                return Za;
            case "quaternion":
                return eo;
            case "bool":
            case "boolean":
                return Ka;
            case "string":
                return no;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
    }(t275.type);
    if (void 0 === t275.times) {
        const e1019 = [], n728 = [];
        ja.flattenJSON(t275.keys, e1019, n728, "value"), t275.times = e1019, t275.values = n728;
    }
    return void 0 !== e1020.parse ? e1020.parse(t275) : new e1020(t275.name, t275.times, t275.values, t275.interpolation);
}
const ao = {
    enabled: !1,
    files: {},
    add: function(t, e1021) {
        !1 !== this.enabled && (this.files[t] = e1021);
    },
    get: function(t) {
        if (!1 !== this.enabled) return this.files[t];
    },
    remove: function(t) {
        delete this.files[t];
    },
    clear: function() {
        this.files = {};
    }
};
const oo = new class {
    constructor(t276, e1022, n729){
        const i499 = this;
        let r384, s267 = !1, a215 = 0, o170 = 0;
        const l146 = [];
        this.onStart = void 0, this.onLoad = t276, this.onProgress = e1022, this.onError = n729, this.itemStart = function(t) {
            o170++, !1 === s267 && void 0 !== i499.onStart && i499.onStart(t, a215, o170), s267 = !0;
        }, this.itemEnd = function(t) {
            a215++, void 0 !== i499.onProgress && i499.onProgress(t, a215, o170), a215 === o170 && (s267 = !1, void 0 !== i499.onLoad && i499.onLoad());
        }, this.itemError = function(t) {
            void 0 !== i499.onError && i499.onError(t);
        }, this.resolveURL = function(t) {
            return r384 ? r384(t) : t;
        }, this.setURLModifier = function(t) {
            return r384 = t, this;
        }, this.addHandler = function(t, e1023) {
            return l146.push(t, e1023), this;
        }, this.removeHandler = function(t) {
            const e1024 = l146.indexOf(t);
            return -1 !== e1024 && l146.splice(e1024, 2), this;
        }, this.getHandler = function(t) {
            for(let e1025 = 0, n730 = l146.length; e1025 < n730; e1025 += 2){
                const n731 = l146[e1025], i500 = l146[e1025 + 1];
                if (n731.global && (n731.lastIndex = 0), n731.test(t)) return i500;
            }
            return null;
        };
    }
};
class lo {
    constructor(t){
        this.manager = void 0 !== t ? t : oo, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {}
    loadAsync(t, e1026) {
        const n732 = this;
        return new Promise(function(i501, r385) {
            n732.load(t, i501, e1026, r385);
        });
    }
    parse() {}
    setCrossOrigin(t) {
        return this.crossOrigin = t, this;
    }
    setWithCredentials(t) {
        return this.withCredentials = t, this;
    }
    setPath(t) {
        return this.path = t, this;
    }
    setResourcePath(t) {
        return this.resourcePath = t, this;
    }
    setRequestHeader(t) {
        return this.requestHeader = t, this;
    }
}
const ho = {};
class co extends lo {
    constructor(t){
        super(t);
    }
    load(t277, e1027, n733, i502) {
        void 0 === t277 && (t277 = ""), void 0 !== this.path && (t277 = this.path + t277), t277 = this.manager.resolveURL(t277);
        const r386 = ao.get(t277);
        if (void 0 !== r386) return this.manager.itemStart(t277), setTimeout(()=>{
            e1027 && e1027(r386), this.manager.itemEnd(t277);
        }, 0), r386;
        if (void 0 !== ho[t277]) return void ho[t277].push({
            onLoad: e1027,
            onProgress: n733,
            onError: i502
        });
        ho[t277] = [], ho[t277].push({
            onLoad: e1027,
            onProgress: n733,
            onError: i502
        });
        const s268 = new Request(t277, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        }), a216 = this.mimeType, o171 = this.responseType;
        fetch(s268).then((e1028)=>{
            if (200 === e1028.status || 0 === e1028.status) {
                if (0 === e1028.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e1028.body || void 0 === e1028.body.getReader) return e1028;
                const n734 = ho[t277], i503 = e1028.body.getReader(), r387 = e1028.headers.get("Content-Length"), s269 = r387 ? parseInt(r387) : 0, a217 = 0 !== s269;
                let o172 = 0;
                const l147 = new ReadableStream({
                    start (t278) {
                        !function e1029() {
                            i503.read().then(({ done: i504 , value: r388  })=>{
                                if (i504) t278.close();
                                else {
                                    o172 += r388.byteLength;
                                    const i505 = new ProgressEvent("progress", {
                                        lengthComputable: a217,
                                        loaded: o172,
                                        total: s269
                                    });
                                    for(let t = 0, e1030 = n734.length; t < e1030; t++){
                                        const e1031 = n734[t];
                                        e1031.onProgress && e1031.onProgress(i505);
                                    }
                                    t278.enqueue(r388), e1029();
                                }
                            });
                        }();
                    }
                });
                return new Response(l147);
            }
            throw Error(`fetch for "${e1028.url}" responded with ${e1028.status}: ${e1028.statusText}`);
        }).then((t279)=>{
            switch(o171){
                case "arraybuffer":
                    return t279.arrayBuffer();
                case "blob":
                    return t279.blob();
                case "document":
                    return t279.text().then((t)=>(new DOMParser).parseFromString(t, a216));
                case "json":
                    return t279.json();
                default:
                    if (void 0 === a216) return t279.text();
                    {
                        const e1032 = /charset="?([^;"\s]*)"?/i.exec(a216), n735 = e1032 && e1032[1] ? e1032[1].toLowerCase() : void 0, i506 = new TextDecoder(n735);
                        return t279.arrayBuffer().then((t)=>i506.decode(t));
                    }
            }
        }).then((e1033)=>{
            ao.add(t277, e1033);
            const n736 = ho[t277];
            delete ho[t277];
            for(let t = 0, i507 = n736.length; t < i507; t++){
                const i508 = n736[t];
                i508.onLoad && i508.onLoad(e1033);
            }
        }).catch((e1034)=>{
            const n737 = ho[t277];
            if (void 0 === n737) throw this.manager.itemError(t277), e1034;
            delete ho[t277];
            for(let t = 0, i509 = n737.length; t < i509; t++){
                const i510 = n737[t];
                i510.onError && i510.onError(e1034);
            }
            this.manager.itemError(t277);
        }).finally(()=>{
            this.manager.itemEnd(t277);
        }), this.manager.itemStart(t277);
    }
    setResponseType(t) {
        return this.responseType = t, this;
    }
    setMimeType(t) {
        return this.mimeType = t, this;
    }
}
class uo extends lo {
    constructor(t){
        super(t);
    }
    load(t, e1035, n, i511) {
        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const r389 = this, s270 = ao.get(t);
        if (void 0 !== s270) return r389.manager.itemStart(t), setTimeout(function() {
            e1035 && e1035(s270), r389.manager.itemEnd(t);
        }, 0), s270;
        const a218 = x("img");
        function o173() {
            h119(), ao.add(t, this), e1035 && e1035(this), r389.manager.itemEnd(t);
        }
        function l148(e1036) {
            h119(), i511 && i511(e1036), r389.manager.itemError(t), r389.manager.itemEnd(t);
        }
        function h119() {
            a218.removeEventListener("load", o173, !1), a218.removeEventListener("error", l148, !1);
        }
        return a218.addEventListener("load", o173, !1), a218.addEventListener("error", l148, !1), "data:" !== t.slice(0, 5) && void 0 !== this.crossOrigin && (a218.crossOrigin = this.crossOrigin), r389.manager.itemStart(t), a218.src = t, a218;
    }
}
class po extends lo {
    constructor(t){
        super(t);
    }
    load(t280, e1038, n738, i512) {
        const r390 = new qe, s271 = new uo(this.manager);
        s271.setCrossOrigin(this.crossOrigin), s271.setPath(this.path);
        let a219 = 0;
        function o174(n739) {
            s271.load(t280[n739], function(t) {
                r390.images[n739] = t, a219++, 6 === a219 && (r390.needsUpdate = !0, e1038 && e1038(r390));
            }, void 0, i512);
        }
        for(let e1037 = 0; e1037 < t280.length; ++e1037)o174(e1037);
        return r390;
    }
}
class mo extends lo {
    constructor(t){
        super(t);
    }
    load(t281, e1039, n740, i513) {
        const r391 = this, s272 = new os, a220 = new co(this.manager);
        return a220.setResponseType("arraybuffer"), a220.setRequestHeader(this.requestHeader), a220.setPath(this.path), a220.setWithCredentials(r391.withCredentials), a220.load(t281, function(t) {
            const n741 = r391.parse(t);
            n741 && (void 0 !== n741.image ? s272.image = n741.image : void 0 !== n741.data && (s272.image.width = n741.width, s272.image.height = n741.height, s272.image.data = n741.data), s272.wrapS = void 0 !== n741.wrapS ? n741.wrapS : 1001, s272.wrapT = void 0 !== n741.wrapT ? n741.wrapT : 1001, s272.magFilter = void 0 !== n741.magFilter ? n741.magFilter : 1006, s272.minFilter = void 0 !== n741.minFilter ? n741.minFilter : 1006, s272.anisotropy = void 0 !== n741.anisotropy ? n741.anisotropy : 1, void 0 !== n741.encoding && (s272.encoding = n741.encoding), void 0 !== n741.flipY && (s272.flipY = n741.flipY), void 0 !== n741.format && (s272.format = n741.format), void 0 !== n741.type && (s272.type = n741.type), void 0 !== n741.mipmaps && (s272.mipmaps = n741.mipmaps, s272.minFilter = 1008), 1 === n741.mipmapCount && (s272.minFilter = 1006), void 0 !== n741.generateMipmaps && (s272.generateMipmaps = n741.generateMipmaps), s272.needsUpdate = !0, e1039 && e1039(s272, n741));
        }, n740, i513), s272;
    }
}
class fo extends lo {
    constructor(t){
        super(t);
    }
    load(t282, e1040, n742, i514) {
        const r392 = new F, s273 = new uo(this.manager);
        return s273.setCrossOrigin(this.crossOrigin), s273.setPath(this.path), s273.load(t282, function(t) {
            r392.image = t, r392.needsUpdate = !0, void 0 !== e1040 && e1040(r392);
        }, n742, i514), r392;
    }
}
class go extends Wt {
    constructor(t, e1041 = 1){
        super(), this.type = "Light", this.color = new L(t), this.intensity = e1041;
    }
    dispose() {}
    copy(t) {
        return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this;
    }
    toJSON(t) {
        const e1042 = super.toJSON(t);
        return e1042.object.color = this.color.getHex(), e1042.object.intensity = this.intensity, void 0 !== this.groundColor && (e1042.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e1042.object.distance = this.distance), void 0 !== this.angle && (e1042.object.angle = this.angle), void 0 !== this.decay && (e1042.object.decay = this.decay), void 0 !== this.penumbra && (e1042.object.penumbra = this.penumbra), void 0 !== this.shadow && (e1042.object.shadow = this.shadow.toJSON()), e1042;
    }
}
go.prototype.isLight = !0;
(class extends go {
    constructor(t, e1043, n743){
        super(t, n743), this.type = "HemisphereLight", this.position.copy(Wt.DefaultUp), this.updateMatrix(), this.groundColor = new L(e1043);
    }
    copy(t) {
        return go.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
    }
}).prototype.isHemisphereLight = !0;
const vo = new xt, yo = new V, xo = new V;
class bo {
    constructor(t){
        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new g(512, 512), this.map = null, this.mapPass = null, this.matrix = new xt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new tn, this._frameExtents = new g(1, 1), this._viewportCount = 1, this._viewports = [
            new U(0, 0, 1, 1)
        ];
    }
    getViewportCount() {
        return this._viewportCount;
    }
    getFrustum() {
        return this._frustum;
    }
    updateMatrices(t) {
        const e1044 = this.camera, n744 = this.matrix;
        yo.setFromMatrixPosition(t.matrixWorld), e1044.position.copy(yo), xo.setFromMatrixPosition(t.target.matrixWorld), e1044.lookAt(xo), e1044.updateMatrixWorld(), vo.multiplyMatrices(e1044.projectionMatrix, e1044.matrixWorldInverse), this._frustum.setFromProjectionMatrix(vo), n744.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n744.multiply(e1044.projectionMatrix), n744.multiply(e1044.matrixWorldInverse);
    }
    getViewport(t) {
        return this._viewports[t];
    }
    getFrameExtents() {
        return this._frameExtents;
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t) {
        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    toJSON() {
        const t = {};
        return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t;
    }
}
class _o extends bo {
    constructor(){
        super(new We(50, 1, .5, 500)), this.focus = 1;
    }
    updateMatrices(t) {
        const e1045 = this.camera, n745 = 2 * o * t.angle * this.focus, i515 = this.mapSize.width / this.mapSize.height, r393 = t.distance || e1045.far;
        n745 === e1045.fov && i515 === e1045.aspect && r393 === e1045.far || (e1045.fov = n745, e1045.aspect = i515, e1045.far = r393, e1045.updateProjectionMatrix()), super.updateMatrices(t);
    }
    copy(t) {
        return super.copy(t), this.focus = t.focus, this;
    }
}
_o.prototype.isSpotLightShadow = !0;
class wo extends go {
    constructor(t, e1046, n746 = 0, i516 = Math.PI / 3, r394 = 0, s274 = 1){
        super(t, e1046), this.type = "SpotLight", this.position.copy(Wt.DefaultUp), this.updateMatrix(), this.target = new Wt, this.distance = n746, this.angle = i516, this.penumbra = r394, this.decay = s274, this.shadow = new _o;
    }
    get power() {
        return this.intensity * Math.PI;
    }
    set power(t) {
        this.intensity = t / Math.PI;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(t) {
        return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
}
wo.prototype.isSpotLight = !0;
const Mo = new xt, So = new V, To = new V;
class Eo extends bo {
    constructor(){
        super(new We(90, 1, .5, 500)), this._frameExtents = new g(4, 2), this._viewportCount = 6, this._viewports = [
            new U(2, 1, 1, 1),
            new U(0, 1, 1, 1),
            new U(3, 1, 1, 1),
            new U(1, 1, 1, 1),
            new U(3, 0, 1, 1),
            new U(1, 0, 1, 1)
        ], this._cubeDirections = [
            new V(1, 0, 0),
            new V(-1, 0, 0),
            new V(0, 0, 1),
            new V(0, 0, -1),
            new V(0, 1, 0),
            new V(0, -1, 0)
        ], this._cubeUps = [
            new V(0, 1, 0),
            new V(0, 1, 0),
            new V(0, 1, 0),
            new V(0, 1, 0),
            new V(0, 0, 1),
            new V(0, 0, -1)
        ];
    }
    updateMatrices(t, e1047 = 0) {
        const n747 = this.camera, i517 = this.matrix, r395 = t.distance || n747.far;
        r395 !== n747.far && (n747.far = r395, n747.updateProjectionMatrix()), So.setFromMatrixPosition(t.matrixWorld), n747.position.copy(So), To.copy(n747.position), To.add(this._cubeDirections[e1047]), n747.up.copy(this._cubeUps[e1047]), n747.lookAt(To), n747.updateMatrixWorld(), i517.makeTranslation(-So.x, -So.y, -So.z), Mo.multiplyMatrices(n747.projectionMatrix, n747.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Mo);
    }
}
Eo.prototype.isPointLightShadow = !0;
class Ao extends go {
    constructor(t, e1048, n748 = 0, i518 = 1){
        super(t, e1048), this.type = "PointLight", this.distance = n748, this.decay = i518, this.shadow = new Eo;
    }
    get power() {
        return 4 * this.intensity * Math.PI;
    }
    set power(t) {
        this.intensity = t / (4 * Math.PI);
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(t) {
        return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
}
Ao.prototype.isPointLight = !0;
class Ro extends bo {
    constructor(){
        super(new mn(-5, 5, 5, -5, .5, 500));
    }
}
Ro.prototype.isDirectionalLightShadow = !0;
class Co extends go {
    constructor(t, e1049){
        super(t, e1049), this.type = "DirectionalLight", this.position.copy(Wt.DefaultUp), this.updateMatrix(), this.target = new Wt, this.shadow = new Ro;
    }
    dispose() {
        this.shadow.dispose();
    }
    copy(t) {
        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
}
Co.prototype.isDirectionalLight = !0;
(class extends go {
    constructor(t, e1050){
        super(t, e1050), this.type = "AmbientLight";
    }
}).prototype.isAmbientLight = !0;
(class extends go {
    constructor(t, e1051, n749 = 10, i519 = 10){
        super(t, e1051), this.type = "RectAreaLight", this.width = n749, this.height = i519;
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI;
    }
    set power(t) {
        this.intensity = t / (this.width * this.height * Math.PI);
    }
    copy(t) {
        return super.copy(t), this.width = t.width, this.height = t.height, this;
    }
    toJSON(t) {
        const e1052 = super.toJSON(t);
        return e1052.object.width = this.width, e1052.object.height = this.height, e1052;
    }
}).prototype.isRectAreaLight = !0;
class Lo {
    constructor(){
        this.coefficients = [];
        for(let t = 0; t < 9; t++)this.coefficients.push(new V);
    }
    set(t) {
        for(let e1053 = 0; e1053 < 9; e1053++)this.coefficients[e1053].copy(t[e1053]);
        return this;
    }
    zero() {
        for(let t = 0; t < 9; t++)this.coefficients[t].set(0, 0, 0);
        return this;
    }
    getAt(t, e1054) {
        const n750 = t.x, i520 = t.y, r396 = t.z, s275 = this.coefficients;
        return e1054.copy(s275[0]).multiplyScalar(.282095), e1054.addScaledVector(s275[1], .488603 * i520), e1054.addScaledVector(s275[2], .488603 * r396), e1054.addScaledVector(s275[3], .488603 * n750), e1054.addScaledVector(s275[4], n750 * i520 * 1.092548), e1054.addScaledVector(s275[5], i520 * r396 * 1.092548), e1054.addScaledVector(s275[6], .315392 * (3 * r396 * r396 - 1)), e1054.addScaledVector(s275[7], n750 * r396 * 1.092548), e1054.addScaledVector(s275[8], .546274 * (n750 * n750 - i520 * i520)), e1054;
    }
    getIrradianceAt(t, e1055) {
        const n751 = t.x, i521 = t.y, r397 = t.z, s276 = this.coefficients;
        return e1055.copy(s276[0]).multiplyScalar(.886227), e1055.addScaledVector(s276[1], 1.023328 * i521), e1055.addScaledVector(s276[2], 1.023328 * r397), e1055.addScaledVector(s276[3], 1.023328 * n751), e1055.addScaledVector(s276[4], .858086 * n751 * i521), e1055.addScaledVector(s276[5], .858086 * i521 * r397), e1055.addScaledVector(s276[6], .743125 * r397 * r397 - .247708), e1055.addScaledVector(s276[7], .858086 * n751 * r397), e1055.addScaledVector(s276[8], .429043 * (n751 * n751 - i521 * i521)), e1055;
    }
    add(t) {
        for(let e1056 = 0; e1056 < 9; e1056++)this.coefficients[e1056].add(t.coefficients[e1056]);
        return this;
    }
    addScaledSH(t, e1057) {
        for(let n752 = 0; n752 < 9; n752++)this.coefficients[n752].addScaledVector(t.coefficients[n752], e1057);
        return this;
    }
    scale(t) {
        for(let e1058 = 0; e1058 < 9; e1058++)this.coefficients[e1058].multiplyScalar(t);
        return this;
    }
    lerp(t, e1059) {
        for(let n753 = 0; n753 < 9; n753++)this.coefficients[n753].lerp(t.coefficients[n753], e1059);
        return this;
    }
    equals(t) {
        for(let e1060 = 0; e1060 < 9; e1060++)if (!this.coefficients[e1060].equals(t.coefficients[e1060])) return !1;
        return !0;
    }
    copy(t) {
        return this.set(t.coefficients);
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    fromArray(t, e1061 = 0) {
        const n754 = this.coefficients;
        for(let i522 = 0; i522 < 9; i522++)n754[i522].fromArray(t, e1061 + 3 * i522);
        return this;
    }
    toArray(t = [], e1062 = 0) {
        const n755 = this.coefficients;
        for(let i523 = 0; i523 < 9; i523++)n755[i523].toArray(t, e1062 + 3 * i523);
        return t;
    }
    static getBasisAt(t, e1063) {
        const n756 = t.x, i524 = t.y, r398 = t.z;
        e1063[0] = .282095, e1063[1] = .488603 * i524, e1063[2] = .488603 * r398, e1063[3] = .488603 * n756, e1063[4] = 1.092548 * n756 * i524, e1063[5] = 1.092548 * i524 * r398, e1063[6] = .315392 * (3 * r398 * r398 - 1), e1063[7] = 1.092548 * n756 * r398, e1063[8] = .546274 * (n756 * n756 - i524 * i524);
    }
}
Lo.prototype.isSphericalHarmonics3 = !0;
class Po extends go {
    constructor(t = new Lo, e1064 = 1){
        super(void 0, e1064), this.sh = t;
    }
    copy(t) {
        return super.copy(t), this.sh.copy(t.sh), this;
    }
    fromJSON(t) {
        return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
    }
    toJSON(t) {
        const e1065 = super.toJSON(t);
        return e1065.object.sh = this.sh.toArray(), e1065;
    }
}
Po.prototype.isLightProbe = !0;
class Do {
    static decodeText(t) {
        if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
        let e1066 = "";
        for(let n757 = 0, i525 = t.length; n757 < i525; n757++)e1066 += String.fromCharCode(t[n757]);
        try {
            return decodeURIComponent(escape(e1066));
        } catch (t283) {
            return e1066;
        }
    }
    static extractUrlBase(t) {
        const e1067 = t.lastIndexOf("/");
        return -1 === e1067 ? "./" : t.slice(0, e1067 + 1);
    }
    static resolveURL(t, e1068) {
        return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e1068) && /^\//.test(t) && (e1068 = e1068.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e1068 + t);
    }
}
(class extends ye {
    constructor(){
        super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(t) {
        return super.copy(t), this.instanceCount = t.instanceCount, this;
    }
    clone() {
        return (new this.constructor).copy(this);
    }
    toJSON() {
        const t = super.toJSON(this);
        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t;
    }
}).prototype.isInstancedBufferGeometry = !0;
class Io extends lo {
    constructor(t){
        super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
        };
    }
    setOptions(t) {
        return this.options = t, this;
    }
    load(t284, e1069, n758, i526) {
        void 0 === t284 && (t284 = ""), void 0 !== this.path && (t284 = this.path + t284), t284 = this.manager.resolveURL(t284);
        const r399 = this, s277 = ao.get(t284);
        if (void 0 !== s277) return r399.manager.itemStart(t284), setTimeout(function() {
            e1069 && e1069(s277), r399.manager.itemEnd(t284);
        }, 0), s277;
        const a221 = {};
        a221.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", a221.headers = this.requestHeader, fetch(t284, a221).then(function(t) {
            return t.blob();
        }).then(function(t) {
            return createImageBitmap(t, Object.assign(r399.options, {
                colorSpaceConversion: "none"
            }));
        }).then(function(n759) {
            ao.add(t284, n759), e1069 && e1069(n759), r399.manager.itemEnd(t284);
        }).catch(function(e1070) {
            i526 && i526(e1070), r399.manager.itemError(t284), r399.manager.itemEnd(t284);
        }), r399.manager.itemStart(t284);
    }
}
let Oo;
Io.prototype.isImageBitmapLoader = !0;
const No = function() {
    return void 0 === Oo && (Oo = new (window.AudioContext || window.webkitAudioContext)), Oo;
};
class Fo extends lo {
    constructor(t){
        super(t);
    }
    load(t285, e1071, n760, i527) {
        const r400 = this, s278 = new co(this.manager);
        s278.setResponseType("arraybuffer"), s278.setPath(this.path), s278.setRequestHeader(this.requestHeader), s278.setWithCredentials(this.withCredentials), s278.load(t285, function(n761) {
            try {
                const t286 = n761.slice(0);
                No().decodeAudioData(t286, function(t) {
                    e1071(t);
                });
            } catch (e1072) {
                i527 ? i527(e1072) : console.error(e1072), r400.manager.itemError(t285);
            }
        }, n760, i527);
    }
}
(class extends Po {
    constructor(t, e1073, n762 = 1){
        super(void 0, n762);
        const i528 = (new L).set(t), r401 = (new L).set(e1073), s279 = new V(i528.r, i528.g, i528.b), a222 = new V(r401.r, r401.g, r401.b), o175 = Math.sqrt(Math.PI), l149 = o175 * Math.sqrt(.75);
        this.sh.coefficients[0].copy(s279).add(a222).multiplyScalar(o175), this.sh.coefficients[1].copy(s279).sub(a222).multiplyScalar(l149);
    }
}).prototype.isHemisphereLightProbe = !0;
(class extends Po {
    constructor(t, e1074 = 1){
        super(void 0, e1074);
        const n763 = (new L).set(t);
        this.sh.coefficients[0].set(n763.r, n763.g, n763.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
}).prototype.isAmbientLightProbe = !0;
class Uo {
    constructor(t, e1075, n764){
        let i529, r402, s280;
        switch(this.binding = t, this.valueSize = n764, e1075){
            case "quaternion":
                i529 = this._slerp, r402 = this._slerpAdditive, s280 = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n764), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                i529 = this._select, r402 = this._select, s280 = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n764);
                break;
            default:
                i529 = this._lerp, r402 = this._lerpAdditive, s280 = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n764);
        }
        this._mixBufferRegion = i529, this._mixBufferRegionAdditive = r402, this._setIdentity = s280, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(t, e1076) {
        const n765 = this.buffer, i530 = this.valueSize, r403 = t * i530 + i530;
        let s281 = this.cumulativeWeight;
        if (0 === s281) {
            for(let t = 0; t !== i530; ++t)n765[r403 + t] = n765[t];
            s281 = e1076;
        } else {
            s281 += e1076;
            const t = e1076 / s281;
            this._mixBufferRegion(n765, r403, 0, t, i530);
        }
        this.cumulativeWeight = s281;
    }
    accumulateAdditive(t) {
        const e1077 = this.buffer, n766 = this.valueSize, i531 = n766 * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e1077, i531, 0, t, n766), this.cumulativeWeightAdditive += t;
    }
    apply(t) {
        const e1078 = this.valueSize, n767 = this.buffer, i532 = t * e1078 + e1078, r405 = this.cumulativeWeight, s282 = this.cumulativeWeightAdditive, a223 = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r405 < 1) {
            const t = e1078 * this._origIndex;
            this._mixBufferRegion(n767, i532, t, 1 - r405, e1078);
        }
        s282 > 0 && this._mixBufferRegionAdditive(n767, i532, this._addIndex * e1078, 1, e1078);
        for(let t288 = e1078, r404 = e1078 + e1078; t288 !== r404; ++t288)if (n767[t288] !== n767[t288 + e1078]) {
            a223.setValue(n767, i532);
            break;
        }
    }
    saveOriginalState() {
        const t = this.binding, e1079 = this.buffer, n768 = this.valueSize, i533 = n768 * this._origIndex;
        t.getValue(e1079, i533);
        for(let t289 = n768, r406 = i533; t289 !== r406; ++t289)e1079[t289] = e1079[i533 + t289 % n768];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
        const t = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t);
    }
    _setAdditiveIdentityNumeric() {
        const t = this._addIndex * this.valueSize, e1080 = t + this.valueSize;
        for(let n769 = t; n769 < e1080; n769++)this.buffer[n769] = 0;
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
        const t = this._origIndex * this.valueSize, e1081 = this._addIndex * this.valueSize;
        for(let n770 = 0; n770 < this.valueSize; n770++)this.buffer[e1081 + n770] = this.buffer[t + n770];
    }
    _select(t, e1082, n771, i535, r407) {
        if (i535 >= .5) for(let i534 = 0; i534 !== r407; ++i534)t[e1082 + i534] = t[n771 + i534];
    }
    _slerp(t, e1083, n772, i536) {
        H.slerpFlat(t, e1083, t, e1083, t, n772, i536);
    }
    _slerpAdditive(t, e1084, n773, i537, r408) {
        const s283 = this._workIndex * r408;
        H.multiplyQuaternionsFlat(t, s283, t, e1084, t, n773), H.slerpFlat(t, e1084, t, e1084, t, s283, i537);
    }
    _lerp(t, e1085, n774, i538, r409) {
        const s284 = 1 - i538;
        for(let a224 = 0; a224 !== r409; ++a224){
            const r410 = e1085 + a224;
            t[r410] = t[r410] * s284 + t[n774 + a224] * i538;
        }
    }
    _lerpAdditive(t, e1086, n775, i539, r411) {
        for(let s285 = 0; s285 !== r411; ++s285){
            const r412 = e1086 + s285;
            t[r412] = t[r412] + t[n775 + s285] * i539;
        }
    }
}
const ko = new RegExp("[\\[\\]\\.:\\/]", "g"), Bo = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", zo = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ho = /(WCOD+)?/.source.replace("WCOD", Bo), Vo = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Go = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Wo = new RegExp("^" + zo + Ho + Vo + Go + "$"), jo = [
    "material",
    "materials",
    "bones"
];
class qo {
    constructor(t, e1087, n776){
        this.path = e1087, this.parsedPath = n776 || qo.parseTrackName(e1087), this.node = qo.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
    static create(t, e1088, n777) {
        return t && t.isAnimationObjectGroup ? new qo.Composite(t, e1088, n777) : new qo(t, e1088, n777);
    }
    static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(ko, "");
    }
    static parseTrackName(t) {
        const e1089 = Wo.exec(t);
        if (null === e1089) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const n778 = {
            nodeName: e1089[2],
            objectName: e1089[3],
            objectIndex: e1089[4],
            propertyName: e1089[5],
            propertyIndex: e1089[6]
        }, i540 = n778.nodeName && n778.nodeName.lastIndexOf(".");
        if (void 0 !== i540 && -1 !== i540) {
            const t = n778.nodeName.substring(i540 + 1);
            -1 !== jo.indexOf(t) && (n778.nodeName = n778.nodeName.substring(0, i540), n778.objectName = t);
        }
        if (null === n778.propertyName || 0 === n778.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
        return n778;
    }
    static findNode(t290, e1090) {
        if (void 0 === e1090 || "" === e1090 || "." === e1090 || -1 === e1090 || e1090 === t290.name || e1090 === t290.uuid) return t290;
        if (t290.skeleton) {
            const n779 = t290.skeleton.getBoneByName(e1090);
            if (void 0 !== n779) return n779;
        }
        if (t290.children) {
            const n780 = function(t) {
                for(let i543 = 0; i543 < t.length; i543++){
                    const r413 = t[i543];
                    if (r413.name === e1090 || r413.uuid === e1090) return r413;
                    const s286 = n780(r413.children);
                    if (s286) return s286;
                }
                return null;
            }, i541 = n780(t290.children);
            if (i541) return i541;
        }
        return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(t, e1091) {
        t[e1091] = this.targetObject[this.propertyName];
    }
    _getValue_array(t, e1092) {
        const n781 = this.resolvedProperty;
        for(let i544 = 0, r414 = n781.length; i544 !== r414; ++i544)t[e1092++] = n781[i544];
    }
    _getValue_arrayElement(t, e1093) {
        t[e1093] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t, e1094) {
        this.resolvedProperty.toArray(t, e1094);
    }
    _setValue_direct(t, e1095) {
        this.targetObject[this.propertyName] = t[e1095];
    }
    _setValue_direct_setNeedsUpdate(t, e1096) {
        this.targetObject[this.propertyName] = t[e1096], this.targetObject.needsUpdate = !0;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e1097) {
        this.targetObject[this.propertyName] = t[e1097], this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_array(t, e1098) {
        const n782 = this.resolvedProperty;
        for(let i545 = 0, r415 = n782.length; i545 !== r415; ++i545)n782[i545] = t[e1098++];
    }
    _setValue_array_setNeedsUpdate(t, e1099) {
        const n783 = this.resolvedProperty;
        for(let i546 = 0, r416 = n783.length; i546 !== r416; ++i546)n783[i546] = t[e1099++];
        this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e1100) {
        const n784 = this.resolvedProperty;
        for(let i547 = 0, r417 = n784.length; i547 !== r417; ++i547)n784[i547] = t[e1100++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(t, e1101) {
        this.resolvedProperty[this.propertyIndex] = t[e1101];
    }
    _setValue_arrayElement_setNeedsUpdate(t, e1102) {
        this.resolvedProperty[this.propertyIndex] = t[e1102], this.targetObject.needsUpdate = !0;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e1103) {
        this.resolvedProperty[this.propertyIndex] = t[e1103], this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_fromArray(t, e1104) {
        this.resolvedProperty.fromArray(t, e1104);
    }
    _setValue_fromArray_setNeedsUpdate(t, e1105) {
        this.resolvedProperty.fromArray(t, e1105), this.targetObject.needsUpdate = !0;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e1106) {
        this.resolvedProperty.fromArray(t, e1106), this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _getValue_unbound(t, e1107) {
        this.bind(), this.getValue(t, e1107);
    }
    _setValue_unbound(t, e1108) {
        this.bind(), this.setValue(t, e1108);
    }
    bind() {
        let t = this.node;
        const e1109 = this.parsedPath, n785 = e1109.objectName, i549 = e1109.propertyName;
        let r418 = e1109.propertyIndex;
        if (t || (t = qo.findNode(this.rootNode, e1109.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        if (n785) {
            let i548 = e1109.objectIndex;
            switch(n785){
                case "materials":
                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    t = t.material.materials;
                    break;
                case "bones":
                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    t = t.skeleton.bones;
                    for(let e1110 = 0; e1110 < t.length; e1110++)if (t[e1110].name === i548) {
                        i548 = e1110;
                        break;
                    }
                    break;
                default:
                    if (void 0 === t[n785]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    t = t[n785];
            }
            if (void 0 !== i548) {
                if (void 0 === t[i548]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                t = t[i548];
            }
        }
        const s287 = t[i549];
        if (void 0 === s287) {
            const n786 = e1109.nodeName;
            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n786 + "." + i549 + " but it wasn't found.", t);
        }
        let a225 = this.Versioning.None;
        this.targetObject = t, void 0 !== t.needsUpdate ? a225 = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (a225 = this.Versioning.MatrixWorldNeedsUpdate);
        let o176 = this.BindingType.Direct;
        if (void 0 !== r418) {
            if ("morphTargetInfluences" === i549) {
                if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                void 0 !== t.morphTargetDictionary[r418] && (r418 = t.morphTargetDictionary[r418]);
            }
            o176 = this.BindingType.ArrayElement, this.resolvedProperty = s287, this.propertyIndex = r418;
        } else void 0 !== s287.fromArray && void 0 !== s287.toArray ? (o176 = this.BindingType.HasFromToArray, this.resolvedProperty = s287) : Array.isArray(s287) ? (o176 = this.BindingType.EntireArray, this.resolvedProperty = s287) : this.propertyName = i549;
        this.getValue = this.GetterByBindingType[o176], this.setValue = this.SetterByBindingTypeAndVersioning[o176][a225];
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
    }
}
qo.Composite = class {
    constructor(t, e1111, n787){
        const i550 = n787 || qo.parseTrackName(e1111);
        this._targetGroup = t, this._bindings = t.subscribe_(e1111, i550);
    }
    getValue(t, e1112) {
        this.bind();
        const n788 = this._targetGroup.nCachedObjects_, i551 = this._bindings[n788];
        void 0 !== i551 && i551.getValue(t, e1112);
    }
    setValue(t, e1113) {
        const n789 = this._bindings;
        for(let i552 = this._targetGroup.nCachedObjects_, r419 = n789.length; i552 !== r419; ++i552)n789[i552].setValue(t, e1113);
    }
    bind() {
        const t = this._bindings;
        for(let e1114 = this._targetGroup.nCachedObjects_, n790 = t.length; e1114 !== n790; ++e1114)t[e1114].bind();
    }
    unbind() {
        const t = this._bindings;
        for(let e1115 = this._targetGroup.nCachedObjects_, n791 = t.length; e1115 !== n791; ++e1115)t[e1115].unbind();
    }
}, qo.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
}, qo.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
}, qo.prototype.GetterByBindingType = [
    qo.prototype._getValue_direct,
    qo.prototype._getValue_array,
    qo.prototype._getValue_arrayElement,
    qo.prototype._getValue_toArray
], qo.prototype.SetterByBindingTypeAndVersioning = [
    [
        qo.prototype._setValue_direct,
        qo.prototype._setValue_direct_setNeedsUpdate,
        qo.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
        qo.prototype._setValue_array,
        qo.prototype._setValue_array_setNeedsUpdate,
        qo.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
        qo.prototype._setValue_arrayElement,
        qo.prototype._setValue_arrayElement_setNeedsUpdate,
        qo.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
        qo.prototype._setValue_fromArray,
        qo.prototype._setValue_fromArray_setNeedsUpdate,
        qo.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
];
class Xo {
    constructor(t, e1116, n792 = null, i553 = e1116.blendMode){
        this._mixer = t, this._clip = e1116, this._localRoot = n792, this.blendMode = i553;
        const r420 = e1116.tracks, s288 = r420.length, a226 = new Array(s288), o177 = {
            endingStart: 2400,
            endingEnd: 2400
        };
        for(let t291 = 0; t291 !== s288; ++t291){
            const e1117 = r420[t291].createInterpolant(null);
            a226[t291] = e1117, e1117.settings = o177;
        }
        this._interpolantSettings = o177, this._interpolants = a226, this._propertyBindings = new Array(s288), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
    }
    play() {
        return this._mixer._activateAction(this), this;
    }
    stop() {
        return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
    }
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(t) {
        return this._startTime = t, this;
    }
    setLoop(t, e1118) {
        return this.loop = t, this.repetitions = e1118, this;
    }
    setEffectiveWeight(t) {
        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
    }
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(t) {
        return this._scheduleFading(t, 0, 1);
    }
    fadeOut(t) {
        return this._scheduleFading(t, 1, 0);
    }
    crossFadeFrom(t, e1119, n793) {
        if (t.fadeOut(e1119), this.fadeIn(e1119), n793) {
            const n794 = this._clip.duration, i554 = t._clip.duration, r421 = i554 / n794, s289 = n794 / i554;
            t.warp(1, r421, e1119), this.warp(s289, 1, e1119);
        }
        return this;
    }
    crossFadeTo(t, e1120, n795) {
        return t.crossFadeFrom(this, e1120, n795);
    }
    stopFading() {
        const t = this._weightInterpolant;
        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }
    setEffectiveTimeScale(t) {
        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(t) {
        return this.timeScale = this._clip.duration / t, this.stopWarping();
    }
    syncWith(t) {
        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
    }
    halt(t) {
        return this.warp(this._effectiveTimeScale, 0, t);
    }
    warp(t, e1121, n796) {
        const i555 = this._mixer, r422 = i555.time, s290 = this.timeScale;
        let a227 = this._timeScaleInterpolant;
        null === a227 && (a227 = i555._lendControlInterpolant(), this._timeScaleInterpolant = a227);
        const o178 = a227.parameterPositions, l150 = a227.sampleValues;
        return o178[0] = r422, o178[1] = r422 + n796, l150[0] = t / s290, l150[1] = e1121 / s290, this;
    }
    stopWarping() {
        const t = this._timeScaleInterpolant;
        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    _update(t, e1122, n797, i558) {
        if (!this.enabled) return void this._updateWeight(t);
        const r423 = this._startTime;
        if (null !== r423) {
            const i556 = (t - r423) * n797;
            if (i556 < 0 || 0 === n797) return;
            this._startTime = null, e1122 = n797 * i556;
        }
        e1122 *= this._updateTimeScale(t);
        const s291 = this._updateTime(e1122), a228 = this._updateWeight(t);
        if (a228 > 0) {
            const t = this._interpolants, e1123 = this._propertyBindings;
            if (2501 === this.blendMode) for(let n799 = 0, i557 = t.length; n799 !== i557; ++n799)t[n799].evaluate(s291), e1123[n799].accumulateAdditive(a228);
            else for(let n798 = 0, r424 = t.length; n798 !== r424; ++n798)t[n798].evaluate(s291), e1123[n798].accumulate(i558, a228);
        }
    }
    _updateWeight(t) {
        let e1124 = 0;
        if (this.enabled) {
            e1124 = this.weight;
            const n800 = this._weightInterpolant;
            if (null !== n800) {
                const i559 = n800.evaluate(t)[0];
                e1124 *= i559, t > n800.parameterPositions[1] && (this.stopFading(), 0 === i559 && (this.enabled = !1));
            }
        }
        return this._effectiveWeight = e1124, e1124;
    }
    _updateTimeScale(t) {
        let e1125 = 0;
        if (!this.paused) {
            e1125 = this.timeScale;
            const n801 = this._timeScaleInterpolant;
            if (null !== n801) e1125 *= n801.evaluate(t)[0], t > n801.parameterPositions[1] && (this.stopWarping(), 0 === e1125 ? this.paused = !0 : this.timeScale = e1125);
        }
        return this._effectiveTimeScale = e1125, e1125;
    }
    _updateTime(t) {
        const e1126 = this._clip.duration, n802 = this.loop;
        let i560 = this.time + t, r425 = this._loopCount;
        const s292 = 2202 === n802;
        if (0 === t) return -1 === r425 ? i560 : s292 && 1 == (1 & r425) ? e1126 - i560 : i560;
        if (2200 === n802) {
            -1 === r425 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            t: {
                if (i560 >= e1126) i560 = e1126;
                else {
                    if (!(i560 < 0)) {
                        this.time = i560;
                        break t;
                    }
                    i560 = 0;
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i560, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t < 0 ? -1 : 1
                });
            }
        } else {
            if (-1 === r425 && (t >= 0 ? (r425 = 0, this._setEndings(!0, 0 === this.repetitions, s292)) : this._setEndings(0 === this.repetitions, !0, s292)), i560 >= e1126 || i560 < 0) {
                const n803 = Math.floor(i560 / e1126);
                i560 -= e1126 * n803, r425 += Math.abs(n803);
                const a229 = this.repetitions - r425;
                if (a229 <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i560 = t > 0 ? e1126 : 0, this.time = i560, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t > 0 ? 1 : -1
                });
                else {
                    if (1 === a229) {
                        const e1127 = t < 0;
                        this._setEndings(e1127, !e1127, s292);
                    } else this._setEndings(!1, !1, s292);
                    this._loopCount = r425, this.time = i560, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: n803
                    });
                }
            } else this.time = i560;
            if (s292 && 1 == (1 & r425)) return e1126 - i560;
        }
        return i560;
    }
    _setEndings(t, e1128, n804) {
        const i561 = this._interpolantSettings;
        n804 ? (i561.endingStart = 2401, i561.endingEnd = 2401) : (i561.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, i561.endingEnd = e1128 ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402);
    }
    _scheduleFading(t, e1129, n805) {
        const i562 = this._mixer, r426 = i562.time;
        let s293 = this._weightInterpolant;
        null === s293 && (s293 = i562._lendControlInterpolant(), this._weightInterpolant = s293);
        const a230 = s293.parameterPositions, o179 = s293.sampleValues;
        return a230[0] = r426, o179[0] = e1129, a230[1] = r426 + t, o179[1] = n805, this;
    }
}
class $o extends i {
    constructor(t){
        super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(t, e1130) {
        const n806 = t._localRoot || this._root, i563 = t._clip.tracks, r427 = i563.length, s294 = t._propertyBindings, a231 = t._interpolants, o180 = n806.uuid, l151 = this._bindingsByRootAndName;
        let h120 = l151[o180];
        void 0 === h120 && (h120 = {}, l151[o180] = h120);
        for(let t292 = 0; t292 !== r427; ++t292){
            const r428 = i563[t292], l152 = r428.name;
            let c89 = h120[l152];
            if (void 0 !== c89) ++c89.referenceCount, s294[t292] = c89;
            else {
                if (c89 = s294[t292], void 0 !== c89) {
                    null === c89._cacheIndex && (++c89.referenceCount, this._addInactiveBinding(c89, o180, l152));
                    continue;
                }
                const i564 = e1130 && e1130._propertyBindings[t292].binding.parsedPath;
                c89 = new Uo(qo.create(n806, l152, i564), r428.ValueTypeName, r428.getValueSize()), ++c89.referenceCount, this._addInactiveBinding(c89, o180, l152), s294[t292] = c89;
            }
            a231[t292].resultBuffer = c89.buffer;
        }
    }
    _activateAction(t) {
        if (!this._isActiveAction(t)) {
            if (null === t._cacheIndex) {
                const e1131 = (t._localRoot || this._root).uuid, n807 = t._clip.uuid, i565 = this._actionsByClip[n807];
                this._bindAction(t, i565 && i565.knownActions[0]), this._addInactiveAction(t, n807, e1131);
            }
            const e1132 = t._propertyBindings;
            for(let t293 = 0, n808 = e1132.length; t293 !== n808; ++t293){
                const n809 = e1132[t293];
                0 == n809.useCount++ && (this._lendBinding(n809), n809.saveOriginalState());
            }
            this._lendAction(t);
        }
    }
    _deactivateAction(t) {
        if (this._isActiveAction(t)) {
            const e1133 = t._propertyBindings;
            for(let t294 = 0, n810 = e1133.length; t294 !== n810; ++t294){
                const n811 = e1133[t294];
                0 == --n811.useCount && (n811.restoreOriginalState(), this._takeBackBinding(n811));
            }
            this._takeBackAction(t);
        }
    }
    _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const t = this;
        this.stats = {
            actions: {
                get total () {
                    return t._actions.length;
                },
                get inUse () {
                    return t._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return t._bindings.length;
                },
                get inUse () {
                    return t._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return t._controlInterpolants.length;
                },
                get inUse () {
                    return t._nActiveControlInterpolants;
                }
            }
        };
    }
    _isActiveAction(t) {
        const e1134 = t._cacheIndex;
        return null !== e1134 && e1134 < this._nActiveActions;
    }
    _addInactiveAction(t, e1135, n812) {
        const i566 = this._actions, r429 = this._actionsByClip;
        let s295 = r429[e1135];
        if (void 0 === s295) s295 = {
            knownActions: [
                t
            ],
            actionByRoot: {}
        }, t._byClipCacheIndex = 0, r429[e1135] = s295;
        else {
            const e1136 = s295.knownActions;
            t._byClipCacheIndex = e1136.length, e1136.push(t);
        }
        t._cacheIndex = i566.length, i566.push(t), s295.actionByRoot[n812] = t;
    }
    _removeInactiveAction(t) {
        const e1137 = this._actions, n813 = e1137[e1137.length - 1], i567 = t._cacheIndex;
        n813._cacheIndex = i567, e1137[i567] = n813, e1137.pop(), t._cacheIndex = null;
        const r430 = t._clip.uuid, s296 = this._actionsByClip, a232 = s296[r430], o181 = a232.knownActions, l153 = o181[o181.length - 1], h121 = t._byClipCacheIndex;
        l153._byClipCacheIndex = h121, o181[h121] = l153, o181.pop(), t._byClipCacheIndex = null;
        delete a232.actionByRoot[(t._localRoot || this._root).uuid], 0 === o181.length && delete s296[r430], this._removeInactiveBindingsForAction(t);
    }
    _removeInactiveBindingsForAction(t) {
        const e1138 = t._propertyBindings;
        for(let t295 = 0, n814 = e1138.length; t295 !== n814; ++t295){
            const n815 = e1138[t295];
            0 == --n815.referenceCount && this._removeInactiveBinding(n815);
        }
    }
    _lendAction(t) {
        const e1139 = this._actions, n816 = t._cacheIndex, i568 = this._nActiveActions++, r431 = e1139[i568];
        t._cacheIndex = i568, e1139[i568] = t, r431._cacheIndex = n816, e1139[n816] = r431;
    }
    _takeBackAction(t) {
        const e1140 = this._actions, n817 = t._cacheIndex, i569 = --this._nActiveActions, r432 = e1140[i569];
        t._cacheIndex = i569, e1140[i569] = t, r432._cacheIndex = n817, e1140[n817] = r432;
    }
    _addInactiveBinding(t, e1141, n818) {
        const i570 = this._bindingsByRootAndName, r433 = this._bindings;
        let s297 = i570[e1141];
        void 0 === s297 && (s297 = {}, i570[e1141] = s297), s297[n818] = t, t._cacheIndex = r433.length, r433.push(t);
    }
    _removeInactiveBinding(t) {
        const e1142 = this._bindings, n819 = t.binding, i571 = n819.rootNode.uuid, r434 = n819.path, s298 = this._bindingsByRootAndName, a233 = s298[i571], o182 = e1142[e1142.length - 1], l154 = t._cacheIndex;
        o182._cacheIndex = l154, e1142[l154] = o182, e1142.pop(), delete a233[r434], 0 === Object.keys(a233).length && delete s298[i571];
    }
    _lendBinding(t) {
        const e1143 = this._bindings, n820 = t._cacheIndex, i572 = this._nActiveBindings++, r435 = e1143[i572];
        t._cacheIndex = i572, e1143[i572] = t, r435._cacheIndex = n820, e1143[n820] = r435;
    }
    _takeBackBinding(t) {
        const e1144 = this._bindings, n821 = t._cacheIndex, i573 = --this._nActiveBindings, r436 = e1144[i573];
        t._cacheIndex = i573, e1144[i573] = t, r436._cacheIndex = n821, e1144[n821] = r436;
    }
    _lendControlInterpolant() {
        const t = this._controlInterpolants, e1145 = this._nActiveControlInterpolants++;
        let n822 = t[e1145];
        return void 0 === n822 && (n822 = new $a(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n822.__cacheIndex = e1145, t[e1145] = n822), n822;
    }
    _takeBackControlInterpolant(t) {
        const e1146 = this._controlInterpolants, n823 = t.__cacheIndex, i574 = --this._nActiveControlInterpolants, r437 = e1146[i574];
        t.__cacheIndex = i574, e1146[i574] = t, r437.__cacheIndex = n823, e1146[n823] = r437;
    }
    clipAction(t, e1147, n824) {
        const i575 = e1147 || this._root, r438 = i575.uuid;
        let s299 = "string" == typeof t ? ro.findByName(i575, t) : t;
        const a234 = null !== s299 ? s299.uuid : t, o183 = this._actionsByClip[a234];
        let l155 = null;
        if (void 0 === n824 && (n824 = null !== s299 ? s299.blendMode : 2500), void 0 !== o183) {
            const t = o183.actionByRoot[r438];
            if (void 0 !== t && t.blendMode === n824) return t;
            l155 = o183.knownActions[0], null === s299 && (s299 = l155._clip);
        }
        if (null === s299) return null;
        const h122 = new Xo(this, s299, e1147, n824);
        return this._bindAction(h122, l155), this._addInactiveAction(h122, a234, r438), h122;
    }
    existingAction(t, e1148) {
        const n825 = e1148 || this._root, i576 = n825.uuid, r439 = "string" == typeof t ? ro.findByName(n825, t) : t, s300 = r439 ? r439.uuid : t, a235 = this._actionsByClip[s300];
        return void 0 !== a235 && a235.actionByRoot[i576] || null;
    }
    stopAllAction() {
        const t = this._actions;
        for(let e1149 = this._nActiveActions - 1; e1149 >= 0; --e1149)t[e1149].stop();
        return this;
    }
    update(t) {
        t *= this.timeScale;
        const e1150 = this._actions, n826 = this._nActiveActions, i577 = this.time += t, r440 = Math.sign(t), s301 = this._accuIndex ^= 1;
        for(let a237 = 0; a237 !== n826; ++a237)e1150[a237]._update(i577, t, r440, s301);
        const a236 = this._bindings, o184 = this._nActiveBindings;
        for(let t296 = 0; t296 !== o184; ++t296)a236[t296].apply(s301);
        return this;
    }
    setTime(t) {
        this.time = 0;
        for(let t297 = 0; t297 < this._actions.length; t297++)this._actions[t297].time = 0;
        return this.update(t);
    }
    getRoot() {
        return this._root;
    }
    uncacheClip(t) {
        const e1151 = this._actions, n827 = t.uuid, i578 = this._actionsByClip, r441 = i578[n827];
        if (void 0 !== r441) {
            const t = r441.knownActions;
            for(let n828 = 0, i579 = t.length; n828 !== i579; ++n828){
                const i580 = t[n828];
                this._deactivateAction(i580);
                const r442 = i580._cacheIndex, s302 = e1151[e1151.length - 1];
                i580._cacheIndex = null, i580._byClipCacheIndex = null, s302._cacheIndex = r442, e1151[r442] = s302, e1151.pop(), this._removeInactiveBindingsForAction(i580);
            }
            delete i578[n827];
        }
    }
    uncacheRoot(t) {
        const e1152 = t.uuid, n829 = this._actionsByClip;
        for(const t298 in n829){
            const i581 = n829[t298].actionByRoot[e1152];
            void 0 !== i581 && (this._deactivateAction(i581), this._removeInactiveAction(i581));
        }
        const i582 = this._bindingsByRootAndName[e1152];
        if (void 0 !== i582) for(const t299 in i582){
            const e1153 = i582[t299];
            e1153.restoreOriginalState(), this._removeInactiveBinding(e1153);
        }
    }
    uncacheAction(t, e1154) {
        const n830 = this.existingAction(t, e1154);
        null !== n830 && (this._deactivateAction(n830), this._removeInactiveAction(n830));
    }
}
$o.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
(class extends Fr {
    constructor(t, e1155, n831 = 1){
        super(t, e1155), this.meshPerAttribute = n831;
    }
    copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
    clone(t) {
        const e1156 = super.clone(t);
        return e1156.meshPerAttribute = this.meshPerAttribute, e1156;
    }
    toJSON(t) {
        const e1157 = super.toJSON(t);
        return e1157.isInstancedInterleavedBuffer = !0, e1157.meshPerAttribute = this.meshPerAttribute, e1157;
    }
}).prototype.isInstancedInterleavedBuffer = !0;
function Yo(t, e1158) {
    return t.distance - e1158.distance;
}
function Jo(t, e1159, n832, i583) {
    if (t.layers.test(e1159.layers) && t.raycast(e1159, n832), !0 === i583) {
        const i584 = t.children;
        for(let t300 = 0, r443 = i584.length; t300 < r443; t300++)Jo(i584[t300], e1159, n832, !0);
    }
}
class Ko {
    constructor(t = 1, e1160 = 0, n833 = 0){
        return this.radius = t, this.phi = e1160, this.theta = n833, this;
    }
    set(t, e1161, n834) {
        return this.radius = t, this.phi = e1161, this.theta = n834, this;
    }
    copy(t) {
        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    }
    makeSafe() {
        const t = 1e-6;
        return this.phi = Math.max(t, Math.min(Math.PI - t, this.phi)), this;
    }
    setFromVector3(t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z);
    }
    setFromCartesianCoords(t, e1162, n835) {
        return this.radius = Math.sqrt(t * t + e1162 * e1162 + n835 * n835), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n835), this.phi = Math.acos(h(e1162 / this.radius, -1, 1))), this;
    }
    clone() {
        return (new this.constructor).copy(this);
    }
}
const Zo = new V, Qo = new xt, tl = new xt;
function el(t) {
    const e1163 = [];
    !0 === t.isBone && e1163.push(t);
    for(let n836 = 0; n836 < t.children.length; n836++)e1163.push.apply(e1163, el(t.children[n836]));
    return e1163;
}
class nl {
    static toHalfFloat(t) {
        Math.abs(t) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), t = h(t, -65504, 65504), rl[0] = t;
        const e1164 = sl[0], n837 = e1164 >> 23 & 511;
        return al[n837] + ((8388607 & e1164) >> ol[n837]);
    }
    static fromHalfFloat(t) {
        const e1165 = t >> 10;
        return sl[0] = ll[cl[e1165] + (1023 & t)] + hl[e1165], rl[0];
    }
}
const il = new ArrayBuffer(4), rl = new Float32Array(il), sl = new Uint32Array(il), al = new Uint32Array(512), ol = new Uint32Array(512);
for(let t2 = 0; t2 < 256; ++t2){
    const e = t2 - 127;
    e < -27 ? (al[t2] = 0, al[256 | t2] = 32768, ol[t2] = 24, ol[256 | t2] = 24) : e < -14 ? (al[t2] = 1024 >> -e - 14, al[256 | t2] = 1024 >> -e - 14 | 32768, ol[t2] = -e - 1, ol[256 | t2] = -e - 1) : e <= 15 ? (al[t2] = e + 15 << 10, al[256 | t2] = e + 15 << 10 | 32768, ol[t2] = 13, ol[256 | t2] = 13) : e < 128 ? (al[t2] = 31744, al[256 | t2] = 64512, ol[t2] = 24, ol[256 | t2] = 24) : (al[t2] = 31744, al[256 | t2] = 64512, ol[t2] = 13, ol[256 | t2] = 13);
}
const ll = new Uint32Array(2048), hl = new Uint32Array(64), cl = new Uint32Array(64);
for(let t3 = 1; t3 < 1024; ++t3){
    let e = t3 << 13, n = 0;
    for(; 0 == (8388608 & e);)e <<= 1, n -= 8388608;
    e &= -8388609, n += 947912704, ll[t3] = e | n;
}
for(let t4 = 1024; t4 < 2048; ++t4)ll[t4] = 939524096 + (t4 - 1024 << 13);
for(let t5 = 1; t5 < 31; ++t5)hl[t5] = t5 << 23;
hl[31] = 1199570944, hl[32] = 2147483648;
for(let t6 = 33; t6 < 63; ++t6)hl[t6] = 2147483648 + (t6 - 32 << 23);
hl[63] = 3347054592;
for(let t7 = 1; t7 < 64; ++t7)32 !== t7 && (cl[t7] = 1024);
Ns.create = function(t, e1166) {
    return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ns.prototype), t.prototype.constructor = t, t.prototype.getPoint = e1166, t;
}, ea.prototype.fromPoints = function(t) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t);
}, (class extends Ts {
    constructor(t = 10, e1167 = 10, n838 = 4473924, i585 = 8947848){
        n838 = new L(n838), i585 = new L(i585);
        const r444 = e1167 / 2, s303 = t / e1167, a238 = t / 2, o185 = [], l156 = [];
        for(let t301 = 0, h124 = 0, c90 = -a238; t301 <= e1167; t301++, c90 += s303){
            o185.push(-a238, 0, c90, a238, 0, c90), o185.push(c90, 0, -a238, c90, 0, a238);
            const e1168 = t301 === r444 ? n838 : i585;
            e1168.toArray(l156, h124), h124 += 3, e1168.toArray(l156, h124), h124 += 3, e1168.toArray(l156, h124), h124 += 3, e1168.toArray(l156, h124), h124 += 3;
        }
        const h123 = new ye;
        h123.setAttribute("position", new ce(o185, 3)), h123.setAttribute("color", new ce(l156, 3));
        super(h123, new gs({
            vertexColors: !0,
            toneMapped: !1
        })), this.type = "GridHelper";
    }
}).prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
}, (class extends Ts {
    constructor(t){
        const e1169 = el(t), n840 = new ye, i586 = [], r445 = [], s304 = new L(0, 0, 1), a239 = new L(0, 1, 0);
        for(let t302 = 0; t302 < e1169.length; t302++){
            const n839 = e1169[t302];
            n839.parent && n839.parent.isBone && (i586.push(0, 0, 0), i586.push(0, 0, 0), r445.push(s304.r, s304.g, s304.b), r445.push(a239.r, a239.g, a239.b));
        }
        n840.setAttribute("position", new ce(i586, 3)), n840.setAttribute("color", new ce(r445, 3));
        super(n840, new gs({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e1169, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1;
    }
    updateMatrixWorld(t) {
        const e1170 = this.bones, n842 = this.geometry, i587 = n842.getAttribute("position");
        tl.copy(this.root.matrixWorld).invert();
        for(let t303 = 0, n841 = 0; t303 < e1170.length; t303++){
            const r446 = e1170[t303];
            r446.parent && r446.parent.isBone && (Qo.multiplyMatrices(tl, r446.matrixWorld), Zo.setFromMatrixPosition(Qo), i587.setXYZ(n841, Zo.x, Zo.y, Zo.z), Qo.multiplyMatrices(tl, r446.parent.matrixWorld), Zo.setFromMatrixPosition(Qo), i587.setXYZ(n841 + 1, Zo.x, Zo.y, Zo.z), n841 += 2);
        }
        n842.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t);
    }
}).prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
}, lo.prototype.extractUrlBase = function(t) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Do.extractUrlBase(t);
}, lo.Handlers = {
    add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    },
    get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    }
}, j.prototype.center = function(t) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t);
}, j.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
}, j.prototype.isIntersectionBox = function(t) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
}, j.prototype.isIntersectionSphere = function(t) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
}, j.prototype.size = function(t) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t);
}, Ct.prototype.toVector3 = function() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
}, ct.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
}, tn.prototype.setFromMatrix = function(t) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t);
}, v.prototype.flattenToArrayOffset = function(t, e1171) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e1171);
}, v.prototype.multiplyVector3 = function(t) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
}, v.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
}, v.prototype.applyToBufferAttribute = function(t) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this);
}, v.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
}, v.prototype.getInverse = function(t) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
}, xt.prototype.extractPosition = function(t) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t);
}, xt.prototype.flattenToArrayOffset = function(t, e1172) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e1172);
}, xt.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new V).setFromMatrixColumn(this, 3);
}, xt.prototype.setRotationFromQuaternion = function(t) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t);
}, xt.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
}, xt.prototype.multiplyVector3 = function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
}, xt.prototype.multiplyVector4 = function(t) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
}, xt.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
}, xt.prototype.rotateAxis = function(t) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this);
}, xt.prototype.crossVector = function(t) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
}, xt.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
}, xt.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
}, xt.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
}, xt.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
}, xt.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
}, xt.prototype.applyToBufferAttribute = function(t) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this);
}, xt.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
}, xt.prototype.makeFrustum = function(t, e1173, n843, i588, r447, s305) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e1173, i588, n843, r447, s305);
}, xt.prototype.getInverse = function(t) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert();
}, Ke.prototype.isIntersectionLine = function(t) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t);
}, H.prototype.multiplyVector3 = function(t) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this);
}, H.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
}, yt.prototype.isIntersectionBox = function(t) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t);
}, yt.prototype.isIntersectionPlane = function(t) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t);
}, yt.prototype.isIntersectionSphere = function(t) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t);
}, ee.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
}, ee.prototype.barycoordFromPoint = function(t, e1174) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e1174);
}, ee.prototype.midpoint = function(t) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t);
}, ee.prototypenormal = function(t) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t);
}, ee.prototype.plane = function(t) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t);
}, ee.barycoordFromPoint = function(t, e1175, n844, i589, r448) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), ee.getBarycoord(t, e1175, n844, i589, r448);
}, ee.normal = function(t, e1176, n845, i590) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), ee.getNormal(t, e1176, n845, i590);
}, na.prototype.extractAllPoints = function(t) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t);
}, na.prototype.extrude = function(t) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Pa(this, t);
}, na.prototype.makeGeometry = function(t) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Ia(this, t);
}, g.prototype.fromAttribute = function(t, e1177, n846) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e1177, n846);
}, g.prototype.distanceToManhattan = function(t) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
}, g.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, V.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
}, V.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
}, V.prototype.getPositionFromMatrix = function(t) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t);
}, V.prototype.getScaleFromMatrix = function(t) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t);
}, V.prototype.getColumnFromMatrix = function(t, e1178) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e1178, t);
}, V.prototype.applyProjection = function(t) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t);
}, V.prototype.fromAttribute = function(t, e1179, n847) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e1179, n847);
}, V.prototype.distanceToManhattan = function(t) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t);
}, V.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, U.prototype.fromAttribute = function(t, e1180, n848) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e1180, n848);
}, U.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, Wt.prototype.getChildByName = function(t) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t);
}, Wt.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
}, Wt.prototype.translate = function(t, e1181) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e1181, t);
}, Wt.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
}, Wt.prototype.applyMatrix = function(t) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
}, Object.defineProperties(Wt.prototype, {
    eulerOrder: {
        get: function() {
            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
        },
        set: function(t) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t;
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
    }
}), Fe.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
}, Object.defineProperties(Fe.prototype, {
    drawMode: {
        get: function() {
            return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
        },
        set: function() {
            console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
        }
    }
}), ss.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
}, We.prototype.setLens = function(t, e1182) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e1182 && (this.filmGauge = e1182), this.setFocalLength(t);
}, Object.defineProperties(go.prototype, {
    onlyShadow: {
        set: function() {
            console.warn("THREE.Light: .onlyShadow has been removed.");
        }
    },
    shadowCameraFov: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t;
        }
    },
    shadowCameraLeft: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t;
        }
    },
    shadowCameraRight: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t;
        }
    },
    shadowCameraTop: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t;
        }
    },
    shadowCameraBottom: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t;
        }
    },
    shadowCameraNear: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t;
        }
    },
    shadowCameraFar: {
        set: function(t) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t;
        }
    },
    shadowCameraVisible: {
        set: function() {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
    },
    shadowBias: {
        set: function(t) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t;
        }
    },
    shadowDarkness: {
        set: function() {
            console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
    },
    shadowMapWidth: {
        set: function(t) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t;
        }
    },
    shadowMapHeight: {
        set: function(t) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t;
        }
    }
}), Object.defineProperties(oe.prototype, {
    length: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
        }
    },
    dynamic: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage;
        },
        set: function() {
            console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048);
        }
    }
}), oe.prototype.setDynamic = function(t) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this;
}, oe.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, oe.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
}, ye.prototype.addIndex = function(t) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t);
}, ye.prototype.addAttribute = function(t, e1183) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e1183 && e1183.isBufferAttribute || e1183 && e1183.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e1183), this) : this.setAttribute(t, e1183) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new oe(arguments[1], arguments[2])));
}, ye.prototype.addDrawCall = function(t, e1184, n849) {
    void 0 !== n849 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e1184);
}, ye.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
}, ye.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
}, ye.prototype.removeAttribute = function(t) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t);
}, ye.prototype.applyMatrix = function(t) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t);
}, Object.defineProperties(ye.prototype, {
    drawcalls: {
        get: function() {
            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
        }
    },
    offsets: {
        get: function() {
            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
        }
    }
}), Fr.prototype.setDynamic = function(t) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? 35048 : 35044), this;
}, Fr.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
}, Pa.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
}, Pa.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
}, Pa.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
}, Nr.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
}, Object.defineProperties(ie.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function() {
            console.warn("THREE.Material: .wrapAround has been removed.");
        }
    },
    overdraw: {
        get: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function() {
            console.warn("THREE.Material: .overdraw has been removed.");
        }
    },
    wrapRGB: {
        get: function() {
            return console.warn("THREE.Material: .wrapRGB has been removed."), new L;
        }
    },
    shading: {
        get: function() {
            console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        },
        set: function(t) {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t;
        }
    },
    stencilMask: {
        get: function() {
            return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
        },
        set: function(t) {
            console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t;
        }
    },
    vertexTangents: {
        get: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        },
        set: function() {
            console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        }
    }
}), Object.defineProperties(Ve.prototype, {
    derivatives: {
        get: function() {
            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
        },
        set: function(t) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t;
        }
    }
}), Or.prototype.clearTarget = function(t, e1185, n850, i591) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e1185, n850, i591);
}, Or.prototype.animate = function(t) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t);
}, Or.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
}, Or.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
}, Or.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
}, Or.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
}, Or.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
}, Or.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
}, Or.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
}, Or.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
}, Or.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
}, Or.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
}, Or.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
}, Or.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
}, Or.prototype.enableScissorTest = function(t) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t);
}, Or.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
}, Or.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
}, Or.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
}, Or.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
}, Or.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
}, Or.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
}, Or.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
}, Or.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
}, Or.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
}, Or.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
}, Object.defineProperties(Or.prototype, {
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t;
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t;
        }
    },
    shadowMapCullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }
    },
    context: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
        }
    },
    vr: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
        }
    },
    gammaInput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        }
    },
    gammaOutput: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? 3001 : 3e3;
        }
    },
    toneMappingWhitePoint: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        }
    },
    gammaFactor: {
        get: function() {
            return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
        }
    }
}), Object.defineProperties(Mr.prototype, {
    cullFace: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }
    },
    renderReverseSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }
    },
    renderSingleSided: {
        get: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        },
        set: function() {
            console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }
    }
}), Object.defineProperties(k.prototype, {
    wrapS: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t;
        }
    },
    wrapT: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t;
        }
    },
    magFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t;
        }
    },
    minFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t;
        }
    },
    anisotropy: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t;
        }
    },
    offset: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t;
        }
    },
    repeat: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t;
        }
    },
    format: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t;
        }
    },
    type: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t;
        }
    },
    generateMipmaps: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
        },
        set: function(t) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t;
        }
    }
}), (class extends Wt {
    constructor(t){
        super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
    }
    getOutput() {
        return this.gain;
    }
    setNodeSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this;
    }
    setMediaElementSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
    }
    setMediaStreamSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
    }
    setBuffer(t) {
        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(t = 0) {
        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
        this._startedAt = this.context.currentTime + t;
        const e1186 = this.context.createBufferSource();
        return e1186.buffer = this.buffer, e1186.loop = this.loop, e1186.loopStart = this.loopStart, e1186.loopEnd = this.loopEnd, e1186.onended = this.onEnded.bind(this), e1186.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e1186, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
    }
    stop() {
        if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
        console.warn("THREE.Audio: this Audio has no playback control.");
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let t = 1, e1187 = this.filters.length; t < e1187; t++)this.filters[t - 1].connect(this.filters[t]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this._connected = !0, this;
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let t = 1, e1188 = this.filters.length; t < e1188; t++)this.filters[t - 1].disconnect(this.filters[t]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this._connected = !1, this;
    }
    getFilters() {
        return this.filters;
    }
    setFilters(t) {
        return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this;
    }
    setDetune(t) {
        if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this;
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(t) {
        return this.setFilters(t ? [
            t
        ] : []);
    }
    setPlaybackRate(t) {
        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = !1;
    }
    getLoop() {
        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
    }
    setLoop(t) {
        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
        console.warn("THREE.Audio: this Audio has no playback control.");
    }
    setLoopStart(t) {
        return this.loopStart = t, this;
    }
    setLoopEnd(t) {
        return this.loopEnd = t, this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this;
    }
}).prototype.load = function(t304) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const e1189 = this;
    return (new Fo).load(t304, function(t) {
        e1189.setBuffer(t);
    }), this;
}, je.prototype.updateCubeMap = function(t, e1190) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e1190);
}, je.prototype.clear = function(t, e1191, n851, i592) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e1191, n851, i592);
}, D.crossOrigin = void 0, D.loadTexture = function(t, e1192, n852, i593) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const r449 = new fo;
    r449.setCrossOrigin(this.crossOrigin);
    const s306 = r449.load(t, n852, void 0, i593);
    return e1192 && (s306.mapping = e1192), s306;
}, D.loadTextureCube = function(t, e1193, n853, i594) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const r450 = new po;
    r450.setCrossOrigin(this.crossOrigin);
    const s307 = r450.load(t, n853, void 0, i594);
    return e1193 && (s307.mapping = e1193), s307;
}, D.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
}, D.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
}, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: "139"
    }
})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "139" /**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ );
const ul = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, dl = Symbol(), pl = new Map;
class ml {
    constructor(t, e1194){
        if (this._$cssResult$ = !0, e1194 !== dl) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = t;
    }
    get styleSheet() {
        let t = pl.get(this.cssText);
        return ul && void 0 === t && (pl.set(this.cssText, t = new CSSStyleSheet), t.replaceSync(this.cssText)), t;
    }
    toString() {
        return this.cssText;
    }
}
const fl = ul ? (t)=>t : (t305)=>t305 instanceof CSSStyleSheet ? ((t306)=>{
        let e1195 = "";
        for (const n854 of t306.cssRules)e1195 += n854.cssText;
        return ((t)=>new ml("string" == typeof t ? t : t + "", dl))(e1195);
    })(t305) : t305 /**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ ;
var gl;
const vl = window.trustedTypes, yl = vl ? vl.emptyScript : "", xl = window.reactiveElementPolyfillSupport, bl = {
    toAttribute (t, e1196) {
        switch(e1196){
            case Boolean:
                t = t ? yl : null;
                break;
            case Object:
            case Array:
                t = null == t ? t : JSON.stringify(t);
        }
        return t;
    },
    fromAttribute (t, e1197) {
        let n855 = t;
        switch(e1197){
            case Boolean:
                n855 = null !== t;
                break;
            case Number:
                n855 = null === t ? null : Number(t);
                break;
            case Object:
            case Array:
                try {
                    n855 = JSON.parse(t);
                } catch (t307) {
                    n855 = null;
                }
        }
        return n855;
    }
}, _l = (t, e1198)=>e1198 !== t && (e1198 == e1198 || t == t), wl = {
    attribute: !0,
    type: String,
    converter: bl,
    reflect: !1,
    hasChanged: _l
};
class Ml extends HTMLElement {
    constructor(){
        super(), this._$Et = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Ei = null, this.o();
    }
    static addInitializer(t) {
        var e1199;
        null !== (e1199 = this.l) && void 0 !== e1199 || (this.l = []), this.l.push(t);
    }
    static get observedAttributes() {
        this.finalize();
        const t = [];
        return this.elementProperties.forEach((e1200, n856)=>{
            const i595 = this._$Eh(n856, e1200);
            void 0 !== i595 && (this._$Eu.set(i595, n856), t.push(i595));
        }), t;
    }
    static createProperty(t, e1201 = wl) {
        if (e1201.state && (e1201.attribute = !1), this.finalize(), this.elementProperties.set(t, e1201), !e1201.noAccessor && !this.prototype.hasOwnProperty(t)) {
            const n857 = "symbol" == typeof t ? Symbol() : "__" + t, i596 = this.getPropertyDescriptor(t, n857, e1201);
            void 0 !== i596 && Object.defineProperty(this.prototype, t, i596);
        }
    }
    static getPropertyDescriptor(t, e1202, n858) {
        return {
            get () {
                return this[e1202];
            },
            set (i597) {
                const r451 = this[t];
                this[e1202] = i597, this.requestUpdate(t, r451, n858);
            },
            configurable: !0,
            enumerable: !0
        };
    }
    static getPropertyOptions(t) {
        return this.elementProperties.get(t) || wl;
    }
    static finalize() {
        if (this.hasOwnProperty("finalized")) return !1;
        this.finalized = !0;
        const t = Object.getPrototypeOf(this);
        if (t.finalize(), this.elementProperties = new Map(t.elementProperties), this._$Eu = new Map, this.hasOwnProperty("properties")) {
            const t = this.properties, e1203 = [
                ...Object.getOwnPropertyNames(t),
                ...Object.getOwnPropertySymbols(t)
            ];
            for (const n859 of e1203)this.createProperty(n859, t[n859]);
        }
        return this.elementStyles = this.finalizeStyles(this.styles), !0;
    }
    static finalizeStyles(t) {
        const e1204 = [];
        if (Array.isArray(t)) {
            const n860 = new Set(t.flat(1 / 0).reverse());
            for (const t308 of n860)e1204.unshift(fl(t308));
        } else void 0 !== t && e1204.push(fl(t));
        return e1204;
    }
    static _$Eh(t, e1205) {
        const n861 = e1205.attribute;
        return !1 === n861 ? void 0 : "string" == typeof n861 ? n861 : "string" == typeof t ? t.toLowerCase() : void 0;
    }
    o() {
        var t309;
        this._$Ep = new Promise((t)=>this.enableUpdating = t), this._$AL = new Map, this._$Em(), this.requestUpdate(), null === (t309 = this.constructor.l) || void 0 === t309 || t309.forEach((t)=>t(this));
    }
    addController(t) {
        var e1206, n862;
        (null !== (e1206 = this._$Eg) && void 0 !== e1206 ? e1206 : this._$Eg = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (n862 = t.hostConnected) || void 0 === n862 || n862.call(t));
    }
    removeController(t) {
        var e1207;
        null === (e1207 = this._$Eg) || void 0 === e1207 || e1207.splice(this._$Eg.indexOf(t) >>> 0, 1);
    }
    _$Em() {
        this.constructor.elementProperties.forEach((t, e1208)=>{
            this.hasOwnProperty(e1208) && (this._$Et.set(e1208, this[e1208]), delete this[e1208]);
        });
    }
    createRenderRoot() {
        var t310;
        const e1209 = null !== (t310 = this.shadowRoot) && void 0 !== t310 ? t310 : this.attachShadow(this.constructor.shadowRootOptions);
        return ((t311, e1210)=>{
            ul ? t311.adoptedStyleSheets = e1210.map((t)=>t instanceof CSSStyleSheet ? t : t.styleSheet) : e1210.forEach((e1211)=>{
                const n863 = document.createElement("style"), i598 = window.litNonce;
                void 0 !== i598 && n863.setAttribute("nonce", i598), n863.textContent = e1211.cssText, t311.appendChild(n863);
            });
        })(e1209, this.constructor.elementStyles), e1209;
    }
    connectedCallback() {
        var t312;
        void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t312 = this._$Eg) || void 0 === t312 || t312.forEach((t)=>{
            var e1212;
            return null === (e1212 = t.hostConnected) || void 0 === e1212 ? void 0 : e1212.call(t);
        });
    }
    enableUpdating(t) {}
    disconnectedCallback() {
        var t313;
        null === (t313 = this._$Eg) || void 0 === t313 || t313.forEach((t)=>{
            var e1213;
            return null === (e1213 = t.hostDisconnected) || void 0 === e1213 ? void 0 : e1213.call(t);
        });
    }
    attributeChangedCallback(t, e, n864) {
        this._$AK(t, n864);
    }
    _$ES(t, e1214, n865 = wl) {
        var i599, r452;
        const s308 = this.constructor._$Eh(t, n865);
        if (void 0 !== s308 && !0 === n865.reflect) {
            const a240 = (null !== (r452 = null === (i599 = n865.converter) || void 0 === i599 ? void 0 : i599.toAttribute) && void 0 !== r452 ? r452 : bl.toAttribute)(e1214, n865.type);
            this._$Ei = t, null == a240 ? this.removeAttribute(s308) : this.setAttribute(s308, a240), this._$Ei = null;
        }
    }
    _$AK(t, e1215) {
        var n866, i600, r453;
        const s309 = this.constructor, a241 = s309._$Eu.get(t);
        if (void 0 !== a241 && this._$Ei !== a241) {
            const t = s309.getPropertyOptions(a241), o186 = t.converter, l157 = null !== (r453 = null !== (i600 = null === (n866 = o186) || void 0 === n866 ? void 0 : n866.fromAttribute) && void 0 !== i600 ? i600 : "function" == typeof o186 ? o186 : null) && void 0 !== r453 ? r453 : bl.fromAttribute;
            this._$Ei = a241, this[a241] = l157(e1215, t.type), this._$Ei = null;
        }
    }
    requestUpdate(t, e1216, n867) {
        let i601 = !0;
        void 0 !== t && (((n867 = n867 || this.constructor.getPropertyOptions(t)).hasChanged || _l)(this[t], e1216) ? (this._$AL.has(t) || this._$AL.set(t, e1216), !0 === n867.reflect && this._$Ei !== t && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(t, n867))) : i601 = !1), !this.isUpdatePending && i601 && (this._$Ep = this._$E_());
    }
    async _$E_() {
        this.isUpdatePending = !0;
        try {
            await this._$Ep;
        } catch (t314) {
            Promise.reject(t314);
        }
        const t = this.scheduleUpdate();
        return null != t && await t, !this.isUpdatePending;
    }
    scheduleUpdate() {
        return this.performUpdate();
    }
    performUpdate() {
        var t315;
        if (!this.isUpdatePending) return;
        this.hasUpdated, this._$Et && (this._$Et.forEach((t, e1218)=>this[e1218] = t), this._$Et = void 0);
        let e1217 = !1;
        const n868 = this._$AL;
        try {
            e1217 = this.shouldUpdate(n868), e1217 ? (this.willUpdate(n868), null === (t315 = this._$Eg) || void 0 === t315 || t315.forEach((t)=>{
                var e1219;
                return null === (e1219 = t.hostUpdate) || void 0 === e1219 ? void 0 : e1219.call(t);
            }), this.update(n868)) : this._$EU();
        } catch (t) {
            throw e1217 = !1, this._$EU(), t;
        }
        e1217 && this._$AE(n868);
    }
    willUpdate(t) {}
    _$AE(t316) {
        var e1220;
        null === (e1220 = this._$Eg) || void 0 === e1220 || e1220.forEach((t)=>{
            var e1221;
            return null === (e1221 = t.hostUpdated) || void 0 === e1221 ? void 0 : e1221.call(t);
        }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t316)), this.updated(t316);
    }
    _$EU() {
        this._$AL = new Map, this.isUpdatePending = !1;
    }
    get updateComplete() {
        return this.getUpdateComplete();
    }
    getUpdateComplete() {
        return this._$Ep;
    }
    shouldUpdate(t) {
        return !0;
    }
    update(t317) {
        void 0 !== this._$EC && (this._$EC.forEach((t, e1222)=>this._$ES(e1222, this[e1222], t)), this._$EC = void 0), this._$EU();
    }
    updated(t) {}
    firstUpdated(t) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var Sl;
Ml.finalized = !0, Ml.elementProperties = new Map, Ml.elementStyles = [], Ml.shadowRootOptions = {
    mode: "open"
}, null == xl || xl({
    ReactiveElement: Ml
}), (null !== (gl = globalThis.reactiveElementVersions) && void 0 !== gl ? gl : globalThis.reactiveElementVersions = []).push("1.3.2");
const Tl = globalThis.trustedTypes, El = Tl ? Tl.createPolicy("lit-html", {
    createHTML: (t)=>t
}) : void 0, Al = `lit$${(Math.random() + "").slice(9)}$`, Rl = "?" + Al, Cl = `<${Rl}>`, Ll = document, Pl = (t = "")=>Ll.createComment(t), Dl = (t)=>null === t || "object" != typeof t && "function" != typeof t, Il = Array.isArray, Ol = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, Nl = /-->/g, Fl = />/g, Ul = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g, kl = /'/g, Bl = /"/g, zl = /^(?:script|style|textarea|title)$/i, Hl = ((t)=>(e1223, ...n869)=>({
            _$litType$: t,
            strings: e1223,
            values: n869
        }))(1), Vl = Symbol.for("lit-noChange"), Gl = Symbol.for("lit-nothing"), Wl = new WeakMap, jl = (t, e1224, n870)=>{
    var i602, r454;
    const s310 = null !== (i602 = null == n870 ? void 0 : n870.renderBefore) && void 0 !== i602 ? i602 : e1224;
    let a242 = s310._$litPart$;
    if (void 0 === a242) {
        const t = null !== (r454 = null == n870 ? void 0 : n870.renderBefore) && void 0 !== r454 ? r454 : null;
        s310._$litPart$ = a242 = new Kl(e1224.insertBefore(Pl(), t), t, void 0, null != n870 ? n870 : {});
    }
    return a242._$AI(t), a242;
}, ql = Ll.createTreeWalker(Ll, 129, null, !1), Xl = (t, e1226)=>{
    const n871 = t.length - 1, i603 = [];
    let r455, s311 = 2 === e1226 ? "<svg>" : "", a243 = Ol;
    for(let e1225 = 0; e1225 < n871; e1225++){
        const n872 = t[e1225];
        let o187, l158, h125 = -1, c91 = 0;
        for(; c91 < n872.length && (a243.lastIndex = c91, l158 = a243.exec(n872), null !== l158);)c91 = a243.lastIndex, a243 === Ol ? "!--" === l158[1] ? a243 = Nl : void 0 !== l158[1] ? a243 = Fl : void 0 !== l158[2] ? (zl.test(l158[2]) && (r455 = RegExp("</" + l158[2], "g")), a243 = Ul) : void 0 !== l158[3] && (a243 = Ul) : a243 === Ul ? ">" === l158[0] ? (a243 = null != r455 ? r455 : Ol, h125 = -1) : void 0 === l158[1] ? h125 = -2 : (h125 = a243.lastIndex - l158[2].length, o187 = l158[1], a243 = void 0 === l158[3] ? Ul : '"' === l158[3] ? Bl : kl) : a243 === Bl || a243 === kl ? a243 = Ul : a243 === Nl || a243 === Fl ? a243 = Ol : (a243 = Ul, r455 = void 0);
        const u81 = a243 === Ul && t[e1225 + 1].startsWith("/>") ? " " : "";
        s311 += a243 === Ol ? n872 + Cl : h125 >= 0 ? (i603.push(o187), n872.slice(0, h125) + "$lit$" + n872.slice(h125) + Al + u81) : n872 + Al + (-2 === h125 ? (i603.push(void 0), e1225) : u81);
    }
    const o188 = s311 + (t[n871] || "<?>") + (2 === e1226 ? "</svg>" : "");
    if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return [
        void 0 !== El ? El.createHTML(o188) : o188,
        i603
    ];
};
class $l {
    constructor({ strings: t , _$litType$: e1227  }, n873){
        let i604;
        this.parts = [];
        let r456 = 0, s312 = 0;
        const a244 = t.length - 1, o189 = this.parts, [l159, h126] = Xl(t, e1227);
        if (this.el = $l.createElement(l159, n873), ql.currentNode = this.el.content, 2 === e1227) {
            const t = this.el.content, e1228 = t.firstChild;
            e1228.remove(), t.append(...e1228.childNodes);
        }
        for(; null !== (i604 = ql.nextNode()) && o189.length < a244;){
            if (1 === i604.nodeType) {
                if (i604.hasAttributes()) {
                    const t = [];
                    for (const e1230 of i604.getAttributeNames())if (e1230.endsWith("$lit$") || e1230.startsWith(Al)) {
                        const n874 = h126[s312++];
                        if (t.push(e1230), void 0 !== n874) {
                            const t = i604.getAttribute(n874.toLowerCase() + "$lit$").split(Al), e1231 = /([.?@])?(.*)/.exec(n874);
                            o189.push({
                                type: 1,
                                index: r456,
                                name: e1231[2],
                                strings: t,
                                ctor: "." === e1231[1] ? Ql : "?" === e1231[1] ? eh : "@" === e1231[1] ? nh : Zl
                            });
                        } else o189.push({
                            type: 6,
                            index: r456
                        });
                    }
                    for (const e1229 of t)i604.removeAttribute(e1229);
                }
                if (zl.test(i604.tagName)) {
                    const t = i604.textContent.split(Al), e1232 = t.length - 1;
                    if (e1232 > 0) {
                        i604.textContent = Tl ? Tl.emptyScript : "";
                        for(let n875 = 0; n875 < e1232; n875++)i604.append(t[n875], Pl()), ql.nextNode(), o189.push({
                            type: 2,
                            index: ++r456
                        });
                        i604.append(t[e1232], Pl());
                    }
                }
            } else if (8 === i604.nodeType) {
                if (i604.data === Rl) o189.push({
                    type: 2,
                    index: r456
                });
                else {
                    let t = -1;
                    for(; -1 !== (t = i604.data.indexOf(Al, t + 1));)o189.push({
                        type: 7,
                        index: r456
                    }), t += Al.length - 1;
                }
            }
            r456++;
        }
    }
    static createElement(t, e) {
        const n876 = Ll.createElement("template");
        return n876.innerHTML = t, n876;
    }
}
function Yl(t, e1233, n877 = t, i605) {
    var r457, s313, a245, o190;
    if (e1233 === Vl) return e1233;
    let l160 = void 0 !== i605 ? null === (r457 = n877._$Cl) || void 0 === r457 ? void 0 : r457[i605] : n877._$Cu;
    const h127 = Dl(e1233) ? void 0 : e1233._$litDirective$;
    return (null == l160 ? void 0 : l160.constructor) !== h127 && (null === (s313 = null == l160 ? void 0 : l160._$AO) || void 0 === s313 || s313.call(l160, !1), void 0 === h127 ? l160 = void 0 : (l160 = new h127(t), l160._$AT(t, n877, i605)), void 0 !== i605 ? (null !== (a245 = (o190 = n877)._$Cl) && void 0 !== a245 ? a245 : o190._$Cl = [])[i605] = l160 : n877._$Cu = l160), void 0 !== l160 && (e1233 = Yl(t, l160._$AS(t, e1233.values), l160, i605)), e1233;
}
class Jl {
    constructor(t, e1234){
        this.v = [], this._$AN = void 0, this._$AD = t, this._$AM = e1234;
    }
    get parentNode() {
        return this._$AM.parentNode;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    p(t) {
        var e1235;
        const { el: { content: n878  } , parts: i606  } = this._$AD, r458 = (null !== (e1235 = null == t ? void 0 : t.creationScope) && void 0 !== e1235 ? e1235 : Ll).importNode(n878, !0);
        ql.currentNode = r458;
        let s314 = ql.nextNode(), a246 = 0, o191 = 0, l161 = i606[0];
        for(; void 0 !== l161;){
            if (a246 === l161.index) {
                let e1236;
                2 === l161.type ? e1236 = new Kl(s314, s314.nextSibling, this, t) : 1 === l161.type ? e1236 = new l161.ctor(s314, l161.name, l161.strings, this, t) : 6 === l161.type && (e1236 = new ih(s314, this, t)), this.v.push(e1236), l161 = i606[++o191];
            }
            a246 !== (null == l161 ? void 0 : l161.index) && (s314 = ql.nextNode(), a246++);
        }
        return r458;
    }
    m(t) {
        let e1237 = 0;
        for (const n879 of this.v)void 0 !== n879 && (void 0 !== n879.strings ? (n879._$AI(t, n879, e1237), e1237 += n879.strings.length - 2) : n879._$AI(t[e1237])), e1237++;
    }
}
class Kl {
    constructor(t, e1238, n880, i607){
        var r459;
        this.type = 2, this._$AH = Gl, this._$AN = void 0, this._$AA = t, this._$AB = e1238, this._$AM = n880, this.options = i607, this._$Cg = null === (r459 = null == i607 ? void 0 : i607.isConnected) || void 0 === r459 || r459;
    }
    get _$AU() {
        var t, e1239;
        return null !== (e1239 = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== e1239 ? e1239 : this._$Cg;
    }
    get parentNode() {
        let t = this._$AA.parentNode;
        const e1240 = this._$AM;
        return void 0 !== e1240 && 11 === t.nodeType && (t = e1240.parentNode), t;
    }
    get startNode() {
        return this._$AA;
    }
    get endNode() {
        return this._$AB;
    }
    _$AI(t318, e1241 = this) {
        t318 = Yl(this, t318, e1241), Dl(t318) ? t318 === Gl || null == t318 || "" === t318 ? (this._$AH !== Gl && this._$AR(), this._$AH = Gl) : t318 !== this._$AH && t318 !== Vl && this.$(t318) : void 0 !== t318._$litType$ ? this.T(t318) : void 0 !== t318.nodeType ? this.k(t318) : ((t)=>{
            var e1242;
            return Il(t) || "function" == typeof (null === (e1242 = t) || void 0 === e1242 ? void 0 : e1242[Symbol.iterator]);
        })(t318) ? this.S(t318) : this.$(t318);
    }
    M(t, e1243 = this._$AB) {
        return this._$AA.parentNode.insertBefore(t, e1243);
    }
    k(t) {
        this._$AH !== t && (this._$AR(), this._$AH = this.M(t));
    }
    $(t) {
        this._$AH !== Gl && Dl(this._$AH) ? this._$AA.nextSibling.data = t : this.k(Ll.createTextNode(t)), this._$AH = t;
    }
    T(t) {
        var e1244;
        const { values: n881 , _$litType$: i608  } = t, r460 = "number" == typeof i608 ? this._$AC(t) : (void 0 === i608.el && (i608.el = $l.createElement(i608.h, this.options)), i608);
        if ((null === (e1244 = this._$AH) || void 0 === e1244 ? void 0 : e1244._$AD) === r460) this._$AH.m(n881);
        else {
            const t = new Jl(r460, this), e1245 = t.p(this.options);
            t.m(n881), this.k(e1245), this._$AH = t;
        }
    }
    _$AC(t) {
        let e1246 = Wl.get(t.strings);
        return void 0 === e1246 && Wl.set(t.strings, e1246 = new $l(t)), e1246;
    }
    S(t) {
        Il(this._$AH) || (this._$AH = [], this._$AR());
        const e1247 = this._$AH;
        let n882, i609 = 0;
        for (const r461 of t)i609 === e1247.length ? e1247.push(n882 = new Kl(this.M(Pl()), this.M(Pl()), this, this.options)) : n882 = e1247[i609], n882._$AI(r461), i609++;
        i609 < e1247.length && (this._$AR(n882 && n882._$AB.nextSibling, i609), e1247.length = i609);
    }
    _$AR(t = this._$AA.nextSibling, e1248) {
        var n883;
        for(null === (n883 = this._$AP) || void 0 === n883 || n883.call(this, !1, !0, e1248); t && t !== this._$AB;){
            const e1249 = t.nextSibling;
            t.remove(), t = e1249;
        }
    }
    setConnected(t) {
        var e1250;
        void 0 === this._$AM && (this._$Cg = t, null === (e1250 = this._$AP) || void 0 === e1250 || e1250.call(this, t));
    }
}
class Zl {
    constructor(t, e1251, n884, i610, r462){
        this.type = 1, this._$AH = Gl, this._$AN = void 0, this.element = t, this.name = e1251, this._$AM = i610, this.options = r462, n884.length > 2 || "" !== n884[0] || "" !== n884[1] ? (this._$AH = Array(n884.length - 1).fill(new String), this.strings = n884) : this._$AH = Gl;
    }
    get tagName() {
        return this.element.tagName;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t, e1252 = this, n885, i612) {
        const r463 = this.strings;
        let s315 = !1;
        if (void 0 === r463) t = Yl(this, t, e1252, 0), s315 = !Dl(t) || t !== this._$AH && t !== Vl, s315 && (this._$AH = t);
        else {
            const i611 = t;
            let a247, o192;
            for(t = r463[0], a247 = 0; a247 < r463.length - 1; a247++)o192 = Yl(this, i611[n885 + a247], e1252, a247), o192 === Vl && (o192 = this._$AH[a247]), s315 || (s315 = !Dl(o192) || o192 !== this._$AH[a247]), o192 === Gl ? t = Gl : t !== Gl && (t += (null != o192 ? o192 : "") + r463[a247 + 1]), this._$AH[a247] = o192;
        }
        s315 && !i612 && this.C(t);
    }
    C(t) {
        t === Gl ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "");
    }
}
class Ql extends Zl {
    constructor(){
        super(...arguments), this.type = 3;
    }
    C(t) {
        this.element[this.name] = t === Gl ? void 0 : t;
    }
}
const th = Tl ? Tl.emptyScript : "";
class eh extends Zl {
    constructor(){
        super(...arguments), this.type = 4;
    }
    C(t) {
        t && t !== Gl ? this.element.setAttribute(this.name, th) : this.element.removeAttribute(this.name);
    }
}
class nh extends Zl {
    constructor(t, e1253, n886, i613, r464){
        super(t, e1253, n886, i613, r464), this.type = 5;
    }
    _$AI(t, e1254 = this) {
        var n887;
        if ((t = null !== (n887 = Yl(this, t, e1254, 0)) && void 0 !== n887 ? n887 : Gl) === Vl) return;
        const i614 = this._$AH, r465 = t === Gl && i614 !== Gl || t.capture !== i614.capture || t.once !== i614.once || t.passive !== i614.passive, s316 = t !== Gl && (i614 === Gl || r465);
        r465 && this.element.removeEventListener(this.name, this, i614), s316 && this.element.addEventListener(this.name, this, t), this._$AH = t;
    }
    handleEvent(t) {
        var e1255, n888;
        "function" == typeof this._$AH ? this._$AH.call(null !== (n888 = null === (e1255 = this.options) || void 0 === e1255 ? void 0 : e1255.host) && void 0 !== n888 ? n888 : this.element, t) : this._$AH.handleEvent(t);
    }
}
class ih {
    constructor(t, e1256, n889){
        this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e1256, this.options = n889;
    }
    get _$AU() {
        return this._$AM._$AU;
    }
    _$AI(t) {
        Yl(this, t);
    }
}
const rh = window.litHtmlPolyfillSupport;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */ var sh, ah;
null == rh || rh($l, Kl), (null !== (Sl = globalThis.litHtmlVersions) && void 0 !== Sl ? Sl : globalThis.litHtmlVersions = []).push("2.2.3");
class oh extends Ml {
    constructor(){
        super(...arguments), this.renderOptions = {
            host: this
        }, this._$Dt = void 0;
    }
    createRenderRoot() {
        var t, e1257;
        const n890 = super.createRenderRoot();
        return null !== (t = (e1257 = this.renderOptions).renderBefore) && void 0 !== t || (e1257.renderBefore = n890.firstChild), n890;
    }
    update(t) {
        const e1258 = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Dt = jl(e1258, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
        var t;
        super.connectedCallback(), null === (t = this._$Dt) || void 0 === t || t.setConnected(!0);
    }
    disconnectedCallback() {
        var t;
        super.disconnectedCallback(), null === (t = this._$Dt) || void 0 === t || t.setConnected(!1);
    }
    render() {
        return Vl;
    }
}
oh.finalized = !0, oh._$litElement$ = !0, null === (sh = globalThis.litElementHydrateSupport) || void 0 === sh || sh.call(globalThis, {
    LitElement: oh
});
const lh = globalThis.litElementPolyfillSupport;
null == lh || lh({
    LitElement: oh
}), (null !== (ah = globalThis.litElementVersions) && void 0 !== ah ? ah : globalThis.litElementVersions = []).push("3.2.0");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const hh = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported, ch = hh && self.XRSession.prototype.requestHitTestSource, uh = null != self.ResizeObserver, dh = null != self.IntersectionObserver, ph = ch;
(()=>{
    const t = navigator.userAgent || navigator.vendor || self.opera;
    let e1259 = !1;
    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e1259 = !0);
})(), /\bCrOS\b/.test(navigator.userAgent);
const mh = /android/i.test(navigator.userAgent), fh = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1, gh = (()=>{
    const t = document.createElement("a");
    return Boolean(t.relList && t.relList.supports && t.relList.supports("ar"));
})();
/Safari\//.test(navigator.userAgent);
const vh = /firefox/i.test(navigator.userAgent), yh = /OculusBrowser/.test(navigator.userAgent);
fh && /CriOS\//.test(navigator.userAgent);
const xh = mh && !vh && !yh;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const bh = Hl`
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

/* NOTE: This ruleset is our integration surface area with the
 * :focus-visible polyfill.
 *
 * @see https://github.com/WICG/focus-visible/pull/196 */
:host([data-js-focus-visible]:focus:not(.focus-visible)),
:host([data-js-focus-visible]) :focus:not(.focus-visible) {
  outline: none;
}

.container {
  position: relative;
}

.userInput {
  width: 100%;
  height: 100%;
  display: block;
  position: relative;
  overflow: hidden;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

canvas.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  left: 0;
  top: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
  pointer-events: none;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  opacity: 0;
  transition: opacity 0.3s 0.3s;
  background-color: inherit;
}

.slot.poster.show {
  opacity: 1;
  transition: none;
}

.slot.poster.quick {
  transition: none;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: var(--poster-color, #fff);
  background-image: var(--poster-image, none);
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .mask {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: var(--progress-mask, #fff);
  transition: opacity 0.3s;
  opacity: 0.2;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.centered {
  align-items: center;
  justify-content: center;
}

.cover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  overflow: hidden;
  opacity: 0;
  will-change: opacity;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.animated-container {
  will-change: transform, opacity;
  opacity: 0;
  transition: opacity 0.3s;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.pan-target {
  display: block;
  position: absolute;
  width: 0;
  height: 0;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  background-color: transparent;
  opacity: 0;
  transition: opacity 0.3s;
}

#default-pan-target {
  width: 6px;
  height: 6px;
  border-radius: 6px;
  border: 1px solid white;
  box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.8);
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 16px;
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="3D model">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>

  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Loading 3D model"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          aria-label="View in your space">
        ${Hl`
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`}
      </a>
    </slot>
  </div>

  <div class="slot pan-target">
    <slot name="pan-target">
      <div id="default-pan-target">
      </div>
    </slot>
  </div>

  <div class="slot interaction-prompt cover centered">
    <div id="prompt" class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${Hl`
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`}
      </slot>
    </div>
  </div>

  <div id="finger0" class="animated-container cover">
    <slot name="finger0" aria-hidden="true">
    </slot>
  </div>
  <div id="finger1" class="animated-container cover">
    <slot name="finger1" aria-hidden="true">
    </slot>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="mask" part="default-progress-mask"></div>
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>

    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${Hl`
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`}
        </a>
      </slot>
    </div>
  </div>
</div>
<div class="screen-reader-only" role="region" aria-label="Live announcements">
  <span id="status" role="status"></span>
</div>`, _h = new WeakMap;
function wh() {
    let t319, e1260;
    function n891(t320, e1261, n892, i615, r466, s317) {
        const a248 = s317.num_components(), o193 = n892.num_points() * a248, l162 = o193 * r466.BYTES_PER_ELEMENT, h128 = function(t, e1262) {
            switch(e1262){
                case Float32Array:
                    return t.DT_FLOAT32;
                case Int8Array:
                    return t.DT_INT8;
                case Int16Array:
                    return t.DT_INT16;
                case Int32Array:
                    return t.DT_INT32;
                case Uint8Array:
                    return t.DT_UINT8;
                case Uint16Array:
                    return t.DT_UINT16;
                case Uint32Array:
                    return t.DT_UINT32;
            }
        }(t320, r466), c92 = t320._malloc(l162);
        e1261.GetAttributeDataArrayForAllPoints(n892, s317, h128, l162, c92);
        const u82 = new r466(t320.HEAPF32.buffer, c92, o193).slice();
        return t320._free(c92), {
            name: i615,
            array: u82,
            itemSize: a248
        };
    }
    onmessage = function(i617) {
        const r467 = i617.data;
        switch(r467.type){
            case "init":
                t319 = r467.decoderConfig, e1260 = new Promise(function(e1263) {
                    t319.onModuleLoaded = function(t) {
                        e1263({
                            draco: t
                        });
                    }, DracoDecoderModule(t319);
                });
                break;
            case "decode":
                const i616 = r467.buffer, s318 = r467.taskConfig;
                e1260.then((t322)=>{
                    const e1264 = t322.draco, a249 = new e1264.Decoder, o194 = new e1264.DecoderBuffer;
                    o194.Init(new Int8Array(i616), i616.byteLength);
                    try {
                        const t321 = function(t323, e1265, i621, r468) {
                            const s319 = r468.attributeIDs, a250 = r468.attributeTypes;
                            let o195, l163;
                            const h129 = e1265.GetEncodedGeometryType(i621);
                            if (h129 === t323.TRIANGULAR_MESH) o195 = new t323.Mesh, l163 = e1265.DecodeBufferToMesh(i621, o195);
                            else {
                                if (h129 !== t323.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                o195 = new t323.PointCloud, l163 = e1265.DecodeBufferToPointCloud(i621, o195);
                            }
                            if (!l163.ok() || 0 === o195.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l163.error_msg());
                            const c93 = {
                                index: null,
                                attributes: []
                            };
                            for(const i618 in s319){
                                const l164 = self[a250[i618]];
                                let h130, u83;
                                if (r468.useUniqueIDs) u83 = s319[i618], h130 = e1265.GetAttributeByUniqueId(o195, u83);
                                else {
                                    if (u83 = e1265.GetAttributeId(o195, t323[s319[i618]]), -1 === u83) continue;
                                    h130 = e1265.GetAttribute(o195, u83);
                                }
                                c93.attributes.push(n891(t323, e1265, o195, i618, l164, h130));
                            }
                            h129 === t323.TRIANGULAR_MESH && (c93.index = function(t, e1266, n893) {
                                const i622 = 3 * n893.num_faces(), r469 = 4 * i622, s320 = t._malloc(r469);
                                e1266.GetTrianglesUInt32Array(n893, r469, s320);
                                const a251 = new Uint32Array(t.HEAPF32.buffer, s320, i622).slice();
                                return t._free(s320), {
                                    array: a251,
                                    itemSize: 1
                                };
                            }(t323, e1265, o195));
                            return t323.destroy(o195), c93;
                        }(e1264, a249, o194, s318), i619 = t321.attributes.map((t)=>t.array.buffer);
                        t321.index && i619.push(t321.index.array.buffer), self.postMessage({
                            type: "decode",
                            id: r467.id,
                            geometry: t321
                        }, i619);
                    } catch (t) {
                        console.error(t), self.postMessage({
                            type: "error",
                            id: r467.id,
                            error: t.message
                        });
                    } finally{
                        e1264.destroy(o194), e1264.destroy(a249);
                    }
                });
        }
    };
}
class Mh extends lo {
    constructor(t324){
        super(t324), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
            return new Rh(t);
        }), this.register(function(t) {
            return new Oh(t);
        }), this.register(function(t) {
            return new Nh(t);
        }), this.register(function(t) {
            return new Ch(t);
        }), this.register(function(t) {
            return new Lh(t);
        }), this.register(function(t) {
            return new Ph(t);
        }), this.register(function(t) {
            return new Dh(t);
        }), this.register(function(t) {
            return new Ih(t);
        }), this.register(function(t) {
            return new Eh(t);
        }), this.register(function(t) {
            return new Fh(t);
        });
    }
    load(t325, e1267, n894, i623) {
        const r470 = this;
        let s321;
        s321 = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Do.extractUrlBase(t325), this.manager.itemStart(t325);
        const a252 = function(e1268) {
            i623 ? i623(e1268) : console.error(e1268), r470.manager.itemError(t325), r470.manager.itemEnd(t325);
        }, o196 = new co(this.manager);
        o196.setPath(this.path), o196.setResponseType("arraybuffer"), o196.setRequestHeader(this.requestHeader), o196.setWithCredentials(this.withCredentials), o196.load(t325, function(n895) {
            try {
                r470.parse(n895, s321, function(n896) {
                    e1267(n896), r470.manager.itemEnd(t325);
                }, a252);
            } catch (t) {
                a252(t);
            }
        }, n894, a252);
    }
    setDRACOLoader(t) {
        return this.dracoLoader = t, this;
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
    setKTX2Loader(t) {
        return this.ktx2Loader = t, this;
    }
    setMeshoptDecoder(t) {
        return this.meshoptDecoder = t, this;
    }
    register(t) {
        return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this;
    }
    unregister(t) {
        return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
    }
    parse(t, e1269, n898, i624) {
        let r471;
        const s322 = {}, a253 = {};
        if ("string" == typeof t) r471 = t;
        else if (Do.decodeText(new Uint8Array(t, 0, 4)) === Uh) {
            try {
                s322[Th.KHR_BINARY_GLTF] = new zh(t);
            } catch (t) {
                return void (i624 && i624(t));
            }
            r471 = s322[Th.KHR_BINARY_GLTF].content;
        } else r471 = Do.decodeText(new Uint8Array(t));
        const o197 = JSON.parse(r471);
        if (void 0 === o197.asset || o197.asset.version[0] < 2) return void (i624 && i624(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
        const l165 = new xc(o197, {
            path: e1269 || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        l165.fileLoader.setRequestHeader(this.requestHeader);
        for(let t326 = 0; t326 < this.pluginCallbacks.length; t326++){
            const e1270 = this.pluginCallbacks[t326](l165);
            a253[e1270.name] = e1270, s322[e1270.name] = !0;
        }
        if (o197.extensionsUsed) for(let t327 = 0; t327 < o197.extensionsUsed.length; ++t327){
            const e1271 = o197.extensionsUsed[t327], n897 = o197.extensionsRequired || [];
            switch(e1271){
                case Th.KHR_MATERIALS_UNLIT:
                    s322[e1271] = new Ah;
                    break;
                case Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    s322[e1271] = new Wh;
                    break;
                case Th.KHR_DRACO_MESH_COMPRESSION:
                    s322[e1271] = new Hh(o197, this.dracoLoader);
                    break;
                case Th.KHR_TEXTURE_TRANSFORM:
                    s322[e1271] = new Vh;
                    break;
                case Th.KHR_MESH_QUANTIZATION:
                    s322[e1271] = new jh;
                    break;
                default:
                    n897.indexOf(e1271) >= 0 && void 0 === a253[e1271] && console.warn('THREE.GLTFLoader: Unknown extension "' + e1271 + '".');
            }
        }
        l165.setExtensions(s322), l165.setPlugins(a253), l165.parse(n898, i624);
    }
    parseAsync(t, e1272) {
        const n899 = this;
        return new Promise(function(i625, r472) {
            n899.parse(t, e1272, i625, r472);
        });
    }
}
function Sh() {
    let t = {};
    return {
        get: function(e1273) {
            return t[e1273];
        },
        add: function(e1274, n900) {
            t[e1274] = n900;
        },
        remove: function(e1275) {
            delete t[e1275];
        },
        removeAll: function() {
            t = {};
        }
    };
}
const Th = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class Eh {
    constructor(t){
        this.parser = t, this.name = Th.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
        };
    }
    _markDefs() {
        const t = this.parser, e1276 = this.parser.json.nodes || [];
        for(let n901 = 0, i626 = e1276.length; n901 < i626; n901++){
            const i627 = e1276[n901];
            i627.extensions && i627.extensions[this.name] && void 0 !== i627.extensions[this.name].light && t._addNodeRef(this.cache, i627.extensions[this.name].light);
        }
    }
    _loadLight(t) {
        const e1277 = this.parser, n902 = "light:" + t;
        let i628 = e1277.cache.get(n902);
        if (i628) return i628;
        const r473 = e1277.json, s323 = ((r473.extensions && r473.extensions[this.name] || {}).lights || [])[t];
        let a254;
        const o198 = new L(16777215);
        void 0 !== s323.color && o198.fromArray(s323.color);
        const l166 = void 0 !== s323.range ? s323.range : 0;
        switch(s323.type){
            case "directional":
                a254 = new Co(o198), a254.target.position.set(0, 0, -1), a254.add(a254.target);
                break;
            case "point":
                a254 = new Ao(o198), a254.distance = l166;
                break;
            case "spot":
                a254 = new wo(o198), a254.distance = l166, s323.spot = s323.spot || {}, s323.spot.innerConeAngle = void 0 !== s323.spot.innerConeAngle ? s323.spot.innerConeAngle : 0, s323.spot.outerConeAngle = void 0 !== s323.spot.outerConeAngle ? s323.spot.outerConeAngle : Math.PI / 4, a254.angle = s323.spot.outerConeAngle, a254.penumbra = 1 - s323.spot.innerConeAngle / s323.spot.outerConeAngle, a254.target.position.set(0, 0, -1), a254.add(a254.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + s323.type);
        }
        return a254.position.set(0, 0, 0), a254.decay = 2, void 0 !== s323.intensity && (a254.intensity = s323.intensity), a254.name = e1277.createUniqueName(s323.name || "light_" + t), i628 = Promise.resolve(a254), e1277.cache.add(n902, i628), i628;
    }
    createNodeAttachment(t328) {
        const e1278 = this, n903 = this.parser, i629 = n903.json.nodes[t328], r474 = (i629.extensions && i629.extensions[this.name] || {}).light;
        return void 0 === r474 ? null : this._loadLight(r474).then(function(t) {
            return n903._getNodeRef(e1278.cache, r474, t);
        });
    }
}
class Ah {
    constructor(){
        this.name = Th.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
        return re;
    }
    extendParams(t, e1279, n904) {
        const i630 = [];
        t.color = new L(1, 1, 1), t.opacity = 1;
        const r475 = e1279.pbrMetallicRoughness;
        if (r475) {
            if (Array.isArray(r475.baseColorFactor)) {
                const e1280 = r475.baseColorFactor;
                t.color.fromArray(e1280), t.opacity = e1280[3];
            }
            void 0 !== r475.baseColorTexture && i630.push(n904.assignTexture(t, "map", r475.baseColorTexture, 3001));
        }
        return Promise.all(i630);
    }
}
class Rh {
    constructor(t){
        this.parser = t, this.name = Th.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(t) {
        const e1281 = this.parser.json.materials[t];
        return e1281.extensions && e1281.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t, e1282) {
        const n905 = this.parser, i631 = n905.json.materials[t];
        if (!i631.extensions || !i631.extensions[this.name]) return Promise.resolve();
        const r476 = [], s324 = i631.extensions[this.name];
        if (void 0 !== s324.clearcoatFactor && (e1282.clearcoat = s324.clearcoatFactor), void 0 !== s324.clearcoatTexture && r476.push(n905.assignTexture(e1282, "clearcoatMap", s324.clearcoatTexture)), void 0 !== s324.clearcoatRoughnessFactor && (e1282.clearcoatRoughness = s324.clearcoatRoughnessFactor), void 0 !== s324.clearcoatRoughnessTexture && r476.push(n905.assignTexture(e1282, "clearcoatRoughnessMap", s324.clearcoatRoughnessTexture)), void 0 !== s324.clearcoatNormalTexture && (r476.push(n905.assignTexture(e1282, "clearcoatNormalMap", s324.clearcoatNormalTexture)), void 0 !== s324.clearcoatNormalTexture.scale)) {
            const t = s324.clearcoatNormalTexture.scale;
            e1282.clearcoatNormalScale = new g(t, t);
        }
        return Promise.all(r476);
    }
}
class Ch {
    constructor(t){
        this.parser = t, this.name = Th.KHR_MATERIALS_SHEEN;
    }
    getMaterialType(t) {
        const e1283 = this.parser.json.materials[t];
        return e1283.extensions && e1283.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t, e1284) {
        const n906 = this.parser, i632 = n906.json.materials[t];
        if (!i632.extensions || !i632.extensions[this.name]) return Promise.resolve();
        const r477 = [];
        e1284.sheenColor = new L(0, 0, 0), e1284.sheenRoughness = 0, e1284.sheen = 1;
        const s325 = i632.extensions[this.name];
        return void 0 !== s325.sheenColorFactor && e1284.sheenColor.fromArray(s325.sheenColorFactor), void 0 !== s325.sheenRoughnessFactor && (e1284.sheenRoughness = s325.sheenRoughnessFactor), void 0 !== s325.sheenColorTexture && r477.push(n906.assignTexture(e1284, "sheenColorMap", s325.sheenColorTexture, 3001)), void 0 !== s325.sheenRoughnessTexture && r477.push(n906.assignTexture(e1284, "sheenRoughnessMap", s325.sheenRoughnessTexture)), Promise.all(r477);
    }
}
class Lh {
    constructor(t){
        this.parser = t, this.name = Th.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(t) {
        const e1285 = this.parser.json.materials[t];
        return e1285.extensions && e1285.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t, e1286) {
        const n907 = this.parser, i633 = n907.json.materials[t];
        if (!i633.extensions || !i633.extensions[this.name]) return Promise.resolve();
        const r478 = [], s326 = i633.extensions[this.name];
        return void 0 !== s326.transmissionFactor && (e1286.transmission = s326.transmissionFactor), void 0 !== s326.transmissionTexture && r478.push(n907.assignTexture(e1286, "transmissionMap", s326.transmissionTexture)), Promise.all(r478);
    }
}
class Ph {
    constructor(t){
        this.parser = t, this.name = Th.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(t) {
        const e1287 = this.parser.json.materials[t];
        return e1287.extensions && e1287.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t, e1288) {
        const n908 = this.parser, i634 = n908.json.materials[t];
        if (!i634.extensions || !i634.extensions[this.name]) return Promise.resolve();
        const r479 = [], s327 = i634.extensions[this.name];
        e1288.thickness = void 0 !== s327.thicknessFactor ? s327.thicknessFactor : 0, void 0 !== s327.thicknessTexture && r479.push(n908.assignTexture(e1288, "thicknessMap", s327.thicknessTexture)), e1288.attenuationDistance = s327.attenuationDistance || 0;
        const a255 = s327.attenuationColor || [
            1,
            1,
            1
        ];
        return e1288.attenuationColor = new L(a255[0], a255[1], a255[2]), Promise.all(r479);
    }
}
class Dh {
    constructor(t){
        this.parser = t, this.name = Th.KHR_MATERIALS_IOR;
    }
    getMaterialType(t) {
        const e1289 = this.parser.json.materials[t];
        return e1289.extensions && e1289.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t, e1290) {
        const n909 = this.parser.json.materials[t];
        if (!n909.extensions || !n909.extensions[this.name]) return Promise.resolve();
        const i635 = n909.extensions[this.name];
        return e1290.ior = void 0 !== i635.ior ? i635.ior : 1.5, Promise.resolve();
    }
}
class Ih {
    constructor(t){
        this.parser = t, this.name = Th.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(t) {
        const e1291 = this.parser.json.materials[t];
        return e1291.extensions && e1291.extensions[this.name] ? Ua : null;
    }
    extendMaterialParams(t, e1292) {
        const n910 = this.parser, i636 = n910.json.materials[t];
        if (!i636.extensions || !i636.extensions[this.name]) return Promise.resolve();
        const r480 = [], s328 = i636.extensions[this.name];
        e1292.specularIntensity = void 0 !== s328.specularFactor ? s328.specularFactor : 1, void 0 !== s328.specularTexture && r480.push(n910.assignTexture(e1292, "specularIntensityMap", s328.specularTexture));
        const a256 = s328.specularColorFactor || [
            1,
            1,
            1
        ];
        return e1292.specularColor = new L(a256[0], a256[1], a256[2]), void 0 !== s328.specularColorTexture && r480.push(n910.assignTexture(e1292, "specularColorMap", s328.specularColorTexture, 3001)), Promise.all(r480);
    }
}
class Oh {
    constructor(t){
        this.parser = t, this.name = Th.KHR_TEXTURE_BASISU;
    }
    loadTexture(t) {
        const e1293 = this.parser, n911 = e1293.json, i637 = n911.textures[t];
        if (!i637.extensions || !i637.extensions[this.name]) return null;
        const r481 = i637.extensions[this.name], s329 = e1293.options.ktx2Loader;
        if (!s329) {
            if (n911.extensionsRequired && n911.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null;
        }
        return e1293.loadTextureImage(t, r481.source, s329);
    }
}
class Nh {
    constructor(t){
        this.parser = t, this.name = Th.EXT_TEXTURE_WEBP, this.isSupported = null;
    }
    loadTexture(t) {
        const e1294 = this.name, n912 = this.parser, i638 = n912.json, r482 = i638.textures[t];
        if (!r482.extensions || !r482.extensions[e1294]) return null;
        const s330 = r482.extensions[e1294], a257 = i638.images[s330.source];
        let o199 = n912.textureLoader;
        if (a257.uri) {
            const t = n912.options.manager.getHandler(a257.uri);
            null !== t && (o199 = t);
        }
        return this.detectSupport().then(function(r483) {
            if (r483) return n912.loadTextureImage(t, s330.source, o199);
            if (i638.extensionsRequired && i638.extensionsRequired.indexOf(e1294) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return n912.loadTexture(t);
        });
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(t) {
            const e1295 = new Image;
            e1295.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", e1295.onload = e1295.onerror = function() {
                t(1 === e1295.height);
            };
        })), this.isSupported;
    }
}
class Fh {
    constructor(t){
        this.name = Th.EXT_MESHOPT_COMPRESSION, this.parser = t;
    }
    loadBufferView(t) {
        const e1296 = this.parser.json, n913 = e1296.bufferViews[t];
        if (n913.extensions && n913.extensions[this.name]) {
            const t = n913.extensions[this.name], i639 = this.parser.getDependency("buffer", t.buffer), r484 = this.parser.options.meshoptDecoder;
            if (!r484 || !r484.supported) {
                if (e1296.extensionsRequired && e1296.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null;
            }
            return Promise.all([
                i639,
                r484.ready
            ]).then(function(e1297) {
                const n914 = t.byteOffset || 0, i640 = t.byteLength || 0, s331 = t.count, a258 = t.byteStride, o200 = new ArrayBuffer(s331 * a258), l167 = new Uint8Array(e1297[0], n914, i640);
                return r484.decodeGltfBuffer(new Uint8Array(o200), s331, a258, l167, t.mode, t.filter), o200;
            });
        }
        return null;
    }
}
const Uh = "glTF", kh = 1313821514, Bh = 5130562;
class zh {
    constructor(t){
        this.name = Th.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const e1298 = new DataView(t, 0, 12);
        if (this.header = {
            magic: Do.decodeText(new Uint8Array(t.slice(0, 4))),
            version: e1298.getUint32(4, !0),
            length: e1298.getUint32(8, !0)
        }, this.header.magic !== Uh) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n915 = this.header.length - 12, i641 = new DataView(t, 12);
        let r485 = 0;
        for(; r485 < n915;){
            const e1299 = i641.getUint32(r485, !0);
            r485 += 4;
            const n916 = i641.getUint32(r485, !0);
            if (r485 += 4, n916 === kh) {
                const n917 = new Uint8Array(t, 12 + r485, e1299);
                this.content = Do.decodeText(n917);
            } else if (n916 === Bh) {
                const n918 = 12 + r485;
                this.body = t.slice(n918, n918 + e1299);
            }
            r485 += e1299;
        }
        if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
}
class Hh {
    constructor(t, e1300){
        if (!e1300) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = Th.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e1300, this.dracoLoader.preload();
    }
    decodePrimitive(t330, e1303) {
        const n919 = this.json, i643 = this.dracoLoader, r487 = t330.extensions[this.name].bufferView, s332 = t330.extensions[this.name].attributes, a259 = {}, o201 = {}, l168 = {};
        for(const t329 in s332){
            const e1302 = ac[t329] || t329.toLowerCase();
            a259[e1302] = s332[t329];
        }
        for(const e1301 in t330.attributes){
            const i642 = ac[e1301] || e1301.toLowerCase();
            if (void 0 !== s332[e1301]) {
                const r486 = n919.accessors[t330.attributes[e1301]], s333 = nc[r486.componentType];
                l168[i642] = s333, o201[i642] = !0 === r486.normalized;
            }
        }
        return e1303.getDependency("bufferView", r487).then(function(t331) {
            return new Promise(function(e1304) {
                i643.decodeDracoFile(t331, function(t) {
                    for(const e1305 in t.attributes){
                        const n920 = t.attributes[e1305], i644 = o201[e1305];
                        void 0 !== i644 && (n920.normalized = i644);
                    }
                    e1304(t);
                }, a259, l168);
            });
        });
    }
}
class Vh {
    constructor(){
        this.name = Th.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(t, e1306) {
        return void 0 !== e1306.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e1306.offset && void 0 === e1306.rotation && void 0 === e1306.scale || (t = t.clone(), void 0 !== e1306.offset && t.offset.fromArray(e1306.offset), void 0 !== e1306.rotation && (t.rotation = e1306.rotation), void 0 !== e1306.scale && t.repeat.fromArray(e1306.scale), t.needsUpdate = !0), t;
    }
}
class Gh extends Fa {
    constructor(t332){
        super(), this.isGLTFSpecularGlossinessMaterial = !0;
        const e1307 = [
            "#ifdef USE_SPECULARMAP",
            "	uniform sampler2D specularMap;",
            "#endif"
        ].join("\n"), n921 = [
            "#ifdef USE_GLOSSINESSMAP",
            "	uniform sampler2D glossinessMap;",
            "#endif"
        ].join("\n"), i645 = [
            "vec3 specularFactor = specular;",
            "#ifdef USE_SPECULARMAP",
            "	vec4 texelSpecular = texture2D( specularMap, vUv );",
            "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "	specularFactor *= texelSpecular.rgb;",
            "#endif"
        ].join("\n"), r488 = [
            "float glossinessFactor = glossiness;",
            "#ifdef USE_GLOSSINESSMAP",
            "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
            "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
            "	glossinessFactor *= texelGlossiness.a;",
            "#endif"
        ].join("\n"), s334 = [
            "PhysicalMaterial material;",
            "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
            "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
            "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
            "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
            "material.roughness += geometryRoughness;",
            "material.roughness = min( material.roughness, 1.0 );",
            "material.specularColor = specularFactor;"
        ].join("\n"), a260 = {
            specular: {
                value: (new L).setHex(16777215)
            },
            glossiness: {
                value: 1
            },
            specularMap: {
                value: null
            },
            glossinessMap: {
                value: null
            }
        };
        this._extraUniforms = a260, this.onBeforeCompile = function(t) {
            for(const e1308 in a260)t.uniforms[e1308] = a260[e1308];
            t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e1307).replace("#include <metalnessmap_pars_fragment>", n921).replace("#include <roughnessmap_fragment>", i645).replace("#include <metalnessmap_fragment>", r488).replace("#include <lights_physical_fragment>", s334);
        }, Object.defineProperties(this, {
            specular: {
                get: function() {
                    return a260.specular.value;
                },
                set: function(t) {
                    a260.specular.value = t;
                }
            },
            specularMap: {
                get: function() {
                    return a260.specularMap.value;
                },
                set: function(t) {
                    a260.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
                }
            },
            glossiness: {
                get: function() {
                    return a260.glossiness.value;
                },
                set: function(t) {
                    a260.glossiness.value = t;
                }
            },
            glossinessMap: {
                get: function() {
                    return a260.glossinessMap.value;
                },
                set: function(t) {
                    a260.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
                }
            }
        }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t332);
    }
    copy(t) {
        return super.copy(t), this.specularMap = t.specularMap, this.specular.copy(t.specular), this.glossinessMap = t.glossinessMap, this.glossiness = t.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
    }
}
class Wh {
    constructor(){
        this.name = Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = [
            "color",
            "map",
            "lightMap",
            "lightMapIntensity",
            "aoMap",
            "aoMapIntensity",
            "emissive",
            "emissiveIntensity",
            "emissiveMap",
            "bumpMap",
            "bumpScale",
            "normalMap",
            "normalMapType",
            "displacementMap",
            "displacementScale",
            "displacementBias",
            "specularMap",
            "specular",
            "glossinessMap",
            "glossiness",
            "alphaMap",
            "envMap",
            "envMapIntensity"
        ];
    }
    getMaterialType() {
        return Gh;
    }
    extendParams(t, e1309, n922) {
        const i646 = e1309.extensions[this.name];
        t.color = new L(1, 1, 1), t.opacity = 1;
        const r489 = [];
        if (Array.isArray(i646.diffuseFactor)) {
            const e1310 = i646.diffuseFactor;
            t.color.fromArray(e1310), t.opacity = e1310[3];
        }
        if (void 0 !== i646.diffuseTexture && r489.push(n922.assignTexture(t, "map", i646.diffuseTexture, 3001)), t.emissive = new L(0, 0, 0), t.glossiness = void 0 !== i646.glossinessFactor ? i646.glossinessFactor : 1, t.specular = new L(1, 1, 1), Array.isArray(i646.specularFactor) && t.specular.fromArray(i646.specularFactor), void 0 !== i646.specularGlossinessTexture) {
            const e1311 = i646.specularGlossinessTexture;
            r489.push(n922.assignTexture(t, "glossinessMap", e1311)), r489.push(n922.assignTexture(t, "specularMap", e1311, 3001));
        }
        return Promise.all(r489);
    }
    createMaterial(t) {
        const e1312 = new Gh(t);
        return e1312.fog = !0, e1312.color = t.color, e1312.map = void 0 === t.map ? null : t.map, e1312.lightMap = null, e1312.lightMapIntensity = 1, e1312.aoMap = void 0 === t.aoMap ? null : t.aoMap, e1312.aoMapIntensity = 1, e1312.emissive = t.emissive, e1312.emissiveIntensity = 1, e1312.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e1312.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e1312.bumpScale = 1, e1312.normalMap = void 0 === t.normalMap ? null : t.normalMap, e1312.normalMapType = 0, t.normalScale && (e1312.normalScale = t.normalScale), e1312.displacementMap = null, e1312.displacementScale = 1, e1312.displacementBias = 0, e1312.specularMap = void 0 === t.specularMap ? null : t.specularMap, e1312.specular = t.specular, e1312.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e1312.glossiness = t.glossiness, e1312.alphaMap = null, e1312.envMap = void 0 === t.envMap ? null : t.envMap, e1312.envMapIntensity = 1, e1312;
    }
}
class jh {
    constructor(){
        this.name = Th.KHR_MESH_QUANTIZATION;
    }
}
class qh extends qa {
    constructor(t, e1313, n923, i647){
        super(t, e1313, n923, i647);
    }
    copySampleValue_(t) {
        const e1314 = this.resultBuffer, n924 = this.sampleValues, i648 = this.valueSize, r490 = t * i648 * 3 + i648;
        for(let t333 = 0; t333 !== i648; t333++)e1314[t333] = n924[r490 + t333];
        return e1314;
    }
}
qh.prototype.beforeStart_ = qh.prototype.copySampleValue_, qh.prototype.afterEnd_ = qh.prototype.copySampleValue_, qh.prototype.interpolate_ = function(t, e1315, n925, i649) {
    const r491 = this.resultBuffer, s335 = this.sampleValues, a261 = this.valueSize, o202 = 2 * a261, l169 = 3 * a261, h131 = i649 - e1315, c94 = (n925 - e1315) / h131, u84 = c94 * c94, d67 = u84 * c94, p60 = t * l169, m43 = p60 - l169, f36 = -2 * d67 + 3 * u84, g28 = d67 - u84, v30 = 1 - f36, y30 = g28 - u84 + c94;
    for(let t334 = 0; t334 !== a261; t334++){
        const e1316 = s335[m43 + t334 + a261], n926 = s335[m43 + t334 + o202] * h131, i650 = s335[p60 + t334 + a261], l170 = s335[p60 + t334] * h131;
        r491[t334] = v30 * e1316 + y30 * n926 + f36 * i650 + g28 * l170;
    }
    return r491;
};
const Xh = new H;
class $h extends qh {
    interpolate_(t, e1317, n927, i651) {
        const r492 = super.interpolate_(t, e1317, n927, i651);
        return Xh.fromArray(r492).normalize().toArray(r492), r492;
    }
}
const Yh = 0, Jh = 1, Kh = 2, Zh = 3, Qh = 4, tc = 5, ec = 6, nc = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}, ic = {
    9728: 1003,
    9729: 1006,
    9984: 1004,
    9985: 1007,
    9986: 1005,
    9987: 1008
}, rc = {
    33071: 1001,
    33648: 1002,
    10497: 1e3
}, sc = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}, ac = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}, oc = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}, lc = {
    CUBICSPLINE: void 0,
    LINEAR: 2301,
    STEP: 2300
}, hc = "OPAQUE", cc = "MASK", uc = "BLEND";
function dc(t) {
    return void 0 === t.DefaultMaterial && (t.DefaultMaterial = new Fa({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: 0
    })), t.DefaultMaterial;
}
function pc(t, e1318, n928) {
    for(const i652 in n928.extensions)void 0 === t[i652] && (e1318.userData.gltfExtensions = e1318.userData.gltfExtensions || {}, e1318.userData.gltfExtensions[i652] = n928.extensions[i652]);
}
function mc(t, e1319) {
    void 0 !== e1319.extras && ("object" == typeof e1319.extras ? Object.assign(t.userData, e1319.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e1319.extras));
}
function fc(t, e1320) {
    if (t.updateMorphTargets(), void 0 !== e1320.weights) for(let n929 = 0, i653 = e1320.weights.length; n929 < i653; n929++)t.morphTargetInfluences[n929] = e1320.weights[n929];
    if (e1320.extras && Array.isArray(e1320.extras.targetNames)) {
        const n930 = e1320.extras.targetNames;
        if (t.morphTargetInfluences.length === n930.length) {
            t.morphTargetDictionary = {};
            for(let e1321 = 0, i654 = n930.length; e1321 < i654; e1321++)t.morphTargetDictionary[n930[e1321]] = e1321;
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
}
function gc(t) {
    const e1322 = t.extensions && t.extensions[Th.KHR_DRACO_MESH_COMPRESSION];
    let n931;
    return n931 = e1322 ? "draco:" + e1322.bufferView + ":" + e1322.indices + ":" + vc(e1322.attributes) : t.indices + ":" + vc(t.attributes) + ":" + t.mode, n931;
}
function vc(t) {
    let e1323 = "";
    const n932 = Object.keys(t).sort();
    for(let i655 = 0, r493 = n932.length; i655 < r493; i655++)e1323 += n932[i655] + ":" + t[n932[i655]] + ";";
    return e1323;
}
function yc(t) {
    switch(t){
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
}
class xc {
    constructor(t = {}, e1324 = {}){
        this.json = t, this.extensions = {}, this.plugins = {}, this.options = e1324, this.cache = new Sh, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
            refs: {},
            uses: {}
        }, this.cameraCache = {
            refs: {},
            uses: {}
        }, this.lightCache = {
            refs: {},
            uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? this.textureLoader = new Io(this.options.manager) : this.textureLoader = new fo(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new co(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0);
    }
    setExtensions(t) {
        this.extensions = t;
    }
    setPlugins(t) {
        this.plugins = t;
    }
    parse(t335, e1325) {
        const n933 = this, i656 = this.json, r494 = this.extensions;
        this.cache.removeAll(), this._invokeAll(function(t) {
            return t._markDefs && t._markDefs();
        }), Promise.all(this._invokeAll(function(t) {
            return t.beforeRoot && t.beforeRoot();
        })).then(function() {
            return Promise.all([
                n933.getDependencies("scene"),
                n933.getDependencies("animation"),
                n933.getDependencies("camera")
            ]);
        }).then(function(e1326) {
            const s336 = {
                scene: e1326[0][i656.scene || 0],
                scenes: e1326[0],
                animations: e1326[1],
                cameras: e1326[2],
                asset: i656.asset,
                parser: n933,
                userData: {}
            };
            pc(r494, s336, i656), mc(s336, i656), Promise.all(n933._invokeAll(function(t) {
                return t.afterRoot && t.afterRoot(s336);
            })).then(function() {
                t335(s336);
            });
        }).catch(e1325);
    }
    _markDefs() {
        const t = this.json.nodes || [], e1328 = this.json.skins || [], n936 = this.json.meshes || [];
        for(let n934 = 0, i658 = e1328.length; n934 < i658; n934++){
            const i659 = e1328[n934].joints;
            for(let e1329 = 0, n935 = i659.length; e1329 < n935; e1329++)t[i659[e1329]].isBone = !0;
        }
        for(let e1327 = 0, i657 = t.length; e1327 < i657; e1327++){
            const i660 = t[e1327];
            void 0 !== i660.mesh && (this._addNodeRef(this.meshCache, i660.mesh), void 0 !== i660.skin && (n936[i660.mesh].isSkinnedMesh = !0)), void 0 !== i660.camera && this._addNodeRef(this.cameraCache, i660.camera);
        }
    }
    _addNodeRef(t, e1330) {
        void 0 !== e1330 && (void 0 === t.refs[e1330] && (t.refs[e1330] = t.uses[e1330] = 0), t.refs[e1330]++);
    }
    _getNodeRef(t336, e1331, n937) {
        if (t336.refs[e1331] <= 1) return n937;
        const i661 = n937.clone(), r495 = (t, e1332)=>{
            const n939 = this.associations.get(t);
            null != n939 && this.associations.set(e1332, n939);
            for (const [n938, i662] of t.children.entries())r495(i662, e1332.children[n938]);
        };
        return r495(n937, i661), i661.name += "_instance_" + t336.uses[e1331]++, i661;
    }
    _invokeOne(t) {
        const e1333 = Object.values(this.plugins);
        e1333.push(this);
        for(let n940 = 0; n940 < e1333.length; n940++){
            const i663 = t(e1333[n940]);
            if (i663) return i663;
        }
        return null;
    }
    _invokeAll(t) {
        const e1334 = Object.values(this.plugins);
        e1334.unshift(this);
        const n941 = [];
        for(let i664 = 0; i664 < e1334.length; i664++){
            const r496 = t(e1334[i664]);
            r496 && n941.push(r496);
        }
        return n941;
    }
    getDependency(t337, e1335) {
        const n942 = t337 + ":" + e1335;
        let i665 = this.cache.get(n942);
        if (!i665) {
            switch(t337){
                case "scene":
                    i665 = this.loadScene(e1335);
                    break;
                case "node":
                    i665 = this.loadNode(e1335);
                    break;
                case "mesh":
                    i665 = this._invokeOne(function(t) {
                        return t.loadMesh && t.loadMesh(e1335);
                    });
                    break;
                case "accessor":
                    i665 = this.loadAccessor(e1335);
                    break;
                case "bufferView":
                    i665 = this._invokeOne(function(t) {
                        return t.loadBufferView && t.loadBufferView(e1335);
                    });
                    break;
                case "buffer":
                    i665 = this.loadBuffer(e1335);
                    break;
                case "material":
                    i665 = this._invokeOne(function(t) {
                        return t.loadMaterial && t.loadMaterial(e1335);
                    });
                    break;
                case "texture":
                    i665 = this._invokeOne(function(t) {
                        return t.loadTexture && t.loadTexture(e1335);
                    });
                    break;
                case "skin":
                    i665 = this.loadSkin(e1335);
                    break;
                case "animation":
                    i665 = this.loadAnimation(e1335);
                    break;
                case "camera":
                    i665 = this.loadCamera(e1335);
                    break;
                default:
                    throw new Error("Unknown type: " + t337);
            }
            this.cache.add(n942, i665);
        }
        return i665;
    }
    getDependencies(t) {
        let e1336 = this.cache.get(t);
        if (!e1336) {
            const n943 = this, i666 = this.json[t + ("mesh" === t ? "es" : "s")] || [];
            e1336 = Promise.all(i666.map(function(e, i667) {
                return n943.getDependency(t, i667);
            })), this.cache.add(t, e1336);
        }
        return e1336;
    }
    loadBuffer(t338) {
        const e1337 = this.json.buffers[t338], n944 = this.fileLoader;
        if (e1337.type && "arraybuffer" !== e1337.type) throw new Error("THREE.GLTFLoader: " + e1337.type + " buffer type is not supported.");
        if (void 0 === e1337.uri && 0 === t338) return Promise.resolve(this.extensions[Th.KHR_BINARY_GLTF].body);
        const i668 = this.options;
        return new Promise(function(t, r497) {
            n944.load(Do.resolveURL(e1337.uri, i668.path), t, void 0, function() {
                r497(new Error('THREE.GLTFLoader: Failed to load buffer "' + e1337.uri + '".'));
            });
        });
    }
    loadBufferView(t339) {
        const e1338 = this.json.bufferViews[t339];
        return this.getDependency("buffer", e1338.buffer).then(function(t) {
            const n945 = e1338.byteLength || 0, i669 = e1338.byteOffset || 0;
            return t.slice(i669, i669 + n945);
        });
    }
    loadAccessor(t340) {
        const e1339 = this, n946 = this.json, i670 = this.json.accessors[t340];
        if (void 0 === i670.bufferView && void 0 === i670.sparse) return Promise.resolve(null);
        const r498 = [];
        return void 0 !== i670.bufferView ? r498.push(this.getDependency("bufferView", i670.bufferView)) : r498.push(null), void 0 !== i670.sparse && (r498.push(this.getDependency("bufferView", i670.sparse.indices.bufferView)), r498.push(this.getDependency("bufferView", i670.sparse.values.bufferView))), Promise.all(r498).then(function(t) {
            const r499 = t[0], s337 = sc[i670.type], a262 = nc[i670.componentType], o203 = a262.BYTES_PER_ELEMENT, l171 = o203 * s337, h132 = i670.byteOffset || 0, c95 = void 0 !== i670.bufferView ? n946.bufferViews[i670.bufferView].byteStride : void 0, u85 = !0 === i670.normalized;
            let d68, p61;
            if (c95 && c95 !== l171) {
                const t = Math.floor(h132 / c95), n947 = "InterleavedBuffer:" + i670.bufferView + ":" + i670.componentType + ":" + t + ":" + i670.count;
                let l172 = e1339.cache.get(n947);
                l172 || (d68 = new a262(r499, t * c95, i670.count * c95 / o203), l172 = new Fr(d68, c95 / o203), e1339.cache.add(n947, l172)), p61 = new kr(l172, s337, h132 % c95 / o203, u85);
            } else d68 = null === r499 ? new a262(i670.count * s337) : new a262(r499, h132, i670.count * s337), p61 = new oe(d68, s337, u85);
            if (void 0 !== i670.sparse) {
                const e1341 = sc.SCALAR, n948 = nc[i670.sparse.indices.componentType], o204 = i670.sparse.indices.byteOffset || 0, l173 = i670.sparse.values.byteOffset || 0, h133 = new n948(t[1], o204, i670.sparse.count * e1341), c96 = new a262(t[2], l173, i670.sparse.count * s337);
                null !== r499 && (p61 = new oe(p61.array.slice(), p61.itemSize, p61.normalized));
                for(let t341 = 0, e1340 = h133.length; t341 < e1340; t341++){
                    const e1342 = h133[t341];
                    if (p61.setX(e1342, c96[t341 * s337]), s337 >= 2 && p61.setY(e1342, c96[t341 * s337 + 1]), s337 >= 3 && p61.setZ(e1342, c96[t341 * s337 + 2]), s337 >= 4 && p61.setW(e1342, c96[t341 * s337 + 3]), s337 >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                }
            }
            return p61;
        });
    }
    loadTexture(t) {
        const e1343 = this.json, n949 = this.options, i671 = e1343.textures[t].source, r500 = e1343.images[i671];
        let s338 = this.textureLoader;
        if (r500.uri) {
            const t = n949.manager.getHandler(r500.uri);
            null !== t && (s338 = t);
        }
        return this.loadTextureImage(t, i671, s338);
    }
    loadTextureImage(t, e1344, n950) {
        const i672 = this, r501 = this.json, s339 = r501.textures[t], a263 = r501.images[e1344], o205 = (a263.uri || a263.bufferView) + ":" + s339.sampler;
        if (this.textureCache[o205]) return this.textureCache[o205];
        const l174 = this.loadImageSource(e1344, n950).then(function(e1345) {
            e1345.flipY = !1, s339.name && (e1345.name = s339.name);
            const n951 = (r501.samplers || {})[s339.sampler] || {};
            return e1345.magFilter = ic[n951.magFilter] || 1006, e1345.minFilter = ic[n951.minFilter] || 1008, e1345.wrapS = rc[n951.wrapS] || 1e3, e1345.wrapT = rc[n951.wrapT] || 1e3, i672.associations.set(e1345, {
                textures: t
            }), e1345;
        }).catch(function() {
            return null;
        });
        return this.textureCache[o205] = l174, l174;
    }
    loadImageSource(t342, e1346) {
        const n952 = this, i673 = this.json, r502 = this.options;
        if (void 0 !== this.sourceCache[t342]) return this.sourceCache[t342].then((t)=>t.clone());
        const s340 = i673.images[t342], a264 = self.URL || self.webkitURL;
        let o206 = s340.uri || "", l175 = !1;
        if (void 0 !== s340.bufferView) o206 = n952.getDependency("bufferView", s340.bufferView).then(function(t) {
            l175 = !0;
            const e1347 = new Blob([
                t
            ], {
                type: s340.mimeType
            });
            return o206 = a264.createObjectURL(e1347), o206;
        });
        else if (void 0 === s340.uri) throw new Error("THREE.GLTFLoader: Image " + t342 + " is missing URI and bufferView");
        const h134 = Promise.resolve(o206).then(function(t343) {
            return new Promise(function(n953, i674) {
                let s341 = n953;
                !0 === e1346.isImageBitmapLoader && (s341 = function(t) {
                    const e1348 = new F(t);
                    e1348.needsUpdate = !0, n953(e1348);
                }), e1346.load(Do.resolveURL(t343, r502.path), s341, void 0, i674);
            });
        }).then(function(t) {
            var e1349;
            return !0 === l175 && a264.revokeObjectURL(o206), t.userData.mimeType = s340.mimeType || ((e1349 = s340.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === e1349.search(/^data\:image\/jpeg/) ? "image/jpeg" : e1349.search(/\.webp($|\?)/i) > 0 || 0 === e1349.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), t;
        }).catch(function(t) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", o206), t;
        });
        return this.sourceCache[t342] = h134, h134;
    }
    assignTexture(t344, e1350, n954, i675) {
        const r503 = this;
        return this.getDependency("texture", n954.index).then(function(s342) {
            if (void 0 === n954.texCoord || 0 == n954.texCoord || "aoMap" === e1350 && 1 == n954.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n954.texCoord + " for texture " + e1350 + " not yet supported."), r503.extensions[Th.KHR_TEXTURE_TRANSFORM]) {
                const t = void 0 !== n954.extensions ? n954.extensions[Th.KHR_TEXTURE_TRANSFORM] : void 0;
                if (t) {
                    const e1351 = r503.associations.get(s342);
                    s342 = r503.extensions[Th.KHR_TEXTURE_TRANSFORM].extendTexture(s342, t), r503.associations.set(s342, e1351);
                }
            }
            return void 0 !== i675 && (s342.encoding = i675), t344[e1350] = s342, s342;
        });
    }
    assignFinalMaterial(t) {
        const e1352 = t.geometry;
        let n955 = t.material;
        const i676 = void 0 === e1352.attributes.tangent, r504 = void 0 !== e1352.attributes.color, s343 = void 0 === e1352.attributes.normal;
        if (t.isPoints) {
            const t = "PointsMaterial:" + n955.uuid;
            let e1353 = this.cache.get(t);
            e1353 || (e1353 = new As, ie.prototype.copy.call(e1353, n955), e1353.color.copy(n955.color), e1353.map = n955.map, e1353.sizeAttenuation = !1, this.cache.add(t, e1353)), n955 = e1353;
        } else if (t.isLine) {
            const t = "LineBasicMaterial:" + n955.uuid;
            let e1354 = this.cache.get(t);
            e1354 || (e1354 = new gs, ie.prototype.copy.call(e1354, n955), e1354.color.copy(n955.color), this.cache.add(t, e1354)), n955 = e1354;
        }
        if (i676 || r504 || s343) {
            let t = "ClonedMaterial:" + n955.uuid + ":";
            n955.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"), i676 && (t += "derivative-tangents:"), r504 && (t += "vertex-colors:"), s343 && (t += "flat-shading:");
            let e1355 = this.cache.get(t);
            e1355 || (e1355 = n955.clone(), r504 && (e1355.vertexColors = !0), s343 && (e1355.flatShading = !0), i676 && (e1355.normalScale && (e1355.normalScale.y *= -1), e1355.clearcoatNormalScale && (e1355.clearcoatNormalScale.y *= -1)), this.cache.add(t, e1355), this.associations.set(e1355, this.associations.get(n955))), n955 = e1355;
        }
        n955.aoMap && void 0 === e1352.attributes.uv2 && void 0 !== e1352.attributes.uv && e1352.setAttribute("uv2", e1352.attributes.uv), t.material = n955;
    }
    getMaterialType() {
        return Fa;
    }
    loadMaterial(t) {
        const e1356 = this, n956 = this.json, i677 = this.extensions, r505 = n956.materials[t];
        let s344;
        const a265 = {}, o207 = r505.extensions || {}, l176 = [];
        if (o207[Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const t = i677[Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            s344 = t.getMaterialType(), l176.push(t.extendParams(a265, r505, e1356));
        } else if (o207[Th.KHR_MATERIALS_UNLIT]) {
            const t = i677[Th.KHR_MATERIALS_UNLIT];
            s344 = t.getMaterialType(), l176.push(t.extendParams(a265, r505, e1356));
        } else {
            const n957 = r505.pbrMetallicRoughness || {};
            if (a265.color = new L(1, 1, 1), a265.opacity = 1, Array.isArray(n957.baseColorFactor)) {
                const t = n957.baseColorFactor;
                a265.color.fromArray(t), a265.opacity = t[3];
            }
            void 0 !== n957.baseColorTexture && l176.push(e1356.assignTexture(a265, "map", n957.baseColorTexture, 3001)), a265.metalness = void 0 !== n957.metallicFactor ? n957.metallicFactor : 1, a265.roughness = void 0 !== n957.roughnessFactor ? n957.roughnessFactor : 1, void 0 !== n957.metallicRoughnessTexture && (l176.push(e1356.assignTexture(a265, "metalnessMap", n957.metallicRoughnessTexture)), l176.push(e1356.assignTexture(a265, "roughnessMap", n957.metallicRoughnessTexture))), s344 = this._invokeOne(function(e1357) {
                return e1357.getMaterialType && e1357.getMaterialType(t);
            }), l176.push(Promise.all(this._invokeAll(function(e1358) {
                return e1358.extendMaterialParams && e1358.extendMaterialParams(t, a265);
            })));
        }
        !0 === r505.doubleSided && (a265.side = 2);
        const h135 = r505.alphaMode || hc;
        if (h135 === uc ? (a265.transparent = !0, a265.depthWrite = !1) : (a265.transparent = !1, h135 === cc && (a265.alphaTest = void 0 !== r505.alphaCutoff ? r505.alphaCutoff : .5)), void 0 !== r505.normalTexture && s344 !== re && (l176.push(e1356.assignTexture(a265, "normalMap", r505.normalTexture)), a265.normalScale = new g(1, 1), void 0 !== r505.normalTexture.scale)) {
            const t = r505.normalTexture.scale;
            a265.normalScale.set(t, t);
        }
        return void 0 !== r505.occlusionTexture && s344 !== re && (l176.push(e1356.assignTexture(a265, "aoMap", r505.occlusionTexture)), void 0 !== r505.occlusionTexture.strength && (a265.aoMapIntensity = r505.occlusionTexture.strength)), void 0 !== r505.emissiveFactor && s344 !== re && (a265.emissive = (new L).fromArray(r505.emissiveFactor)), void 0 !== r505.emissiveTexture && s344 !== re && l176.push(e1356.assignTexture(a265, "emissiveMap", r505.emissiveTexture, 3001)), Promise.all(l176).then(function() {
            let n958;
            return n958 = s344 === Gh ? i677[Th.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a265) : new s344(a265), r505.name && (n958.name = r505.name), mc(n958, r505), e1356.associations.set(n958, {
                materials: t
            }), r505.extensions && pc(i677, n958, r505), n958;
        });
    }
    createUniqueName(t) {
        const e1359 = qo.sanitizeNodeName(t || "");
        let n959 = e1359;
        for(let t345 = 1; this.nodeNamesUsed[n959]; ++t345)n959 = e1359 + "_" + t345;
        return this.nodeNamesUsed[n959] = !0, n959;
    }
    loadGeometries(t346) {
        const e1360 = this, n961 = this.extensions, i678 = this.primitiveCache;
        function r506(t) {
            return n961[Th.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e1360).then(function(n962) {
                return _c(n962, t, e1360);
            });
        }
        const s345 = [];
        for(let n960 = 0, a266 = t346.length; n960 < a266; n960++){
            const a267 = t346[n960], o208 = gc(a267), l177 = i678[o208];
            if (l177) s345.push(l177.promise);
            else {
                let t;
                t = a267.extensions && a267.extensions[Th.KHR_DRACO_MESH_COMPRESSION] ? r506(a267) : _c(new ye, a267, e1360), i678[o208] = {
                    primitive: a267,
                    promise: t
                }, s345.push(t);
            }
        }
        return Promise.all(s345);
    }
    loadMesh(t) {
        const e1363 = this, n963 = this.json, i680 = this.extensions, r507 = n963.meshes[t], s346 = r507.primitives, a268 = [];
        for(let t347 = 0, e1361 = s346.length; t347 < e1361; t347++){
            const e1362 = void 0 === s346[t347].material ? dc(this.cache) : this.getDependency("material", s346[t347].material);
            a268.push(e1362);
        }
        return a268.push(e1363.loadGeometries(s346)), Promise.all(a268).then(function(n966) {
            const a269 = n966.slice(0, n966.length - 1), o209 = n966[n966.length - 1], l178 = [];
            for(let n964 = 0, h137 = o209.length; n964 < h137; n964++){
                const h138 = o209[n964], c97 = s346[n964];
                let u86;
                const d69 = a269[n964];
                if (c97.mode === Qh || c97.mode === tc || c97.mode === ec || void 0 === c97.mode) u86 = !0 === r507.isSkinnedMesh ? new ss(h138, d69) : new Fe(h138, d69), !0 !== u86.isSkinnedMesh || u86.geometry.attributes.skinWeight.normalized || u86.normalizeSkinWeights(), c97.mode === tc ? u86.geometry = wc(u86.geometry, 1) : c97.mode === ec && (u86.geometry = wc(u86.geometry, 2));
                else if (c97.mode === Jh) u86 = new Ts(h138, d69);
                else if (c97.mode === Zh) u86 = new ws(h138, d69);
                else if (c97.mode === Kh) u86 = new Es(h138, d69);
                else {
                    if (c97.mode !== Yh) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + c97.mode);
                    u86 = new Ds(h138, d69);
                }
                Object.keys(u86.geometry.morphAttributes).length > 0 && fc(u86, r507), u86.name = e1363.createUniqueName(r507.name || "mesh_" + t), mc(u86, r507), c97.extensions && pc(i680, u86, c97), e1363.assignFinalMaterial(u86), l178.push(u86);
            }
            for(let n965 = 0, i679 = l178.length; n965 < i679; n965++)e1363.associations.set(l178[n965], {
                meshes: t,
                primitives: n965
            });
            if (1 === l178.length) return l178[0];
            const h136 = new Rr;
            e1363.associations.set(h136, {
                meshes: t
            });
            for(let t348 = 0, e1364 = l178.length; t348 < e1364; t348++)h136.add(l178[t348]);
            return h136;
        });
    }
    loadCamera(t) {
        let e1365;
        const n967 = this.json.cameras[t], i681 = n967[n967.type];
        if (i681) return "perspective" === n967.type ? e1365 = new We(f.radToDeg(i681.yfov), i681.aspectRatio || 1, i681.znear || 1, i681.zfar || 2e6) : "orthographic" === n967.type && (e1365 = new mn(-i681.xmag, i681.xmag, i681.ymag, -i681.ymag, i681.znear, i681.zfar)), n967.name && (e1365.name = this.createUniqueName(n967.name)), mc(e1365, n967), Promise.resolve(e1365);
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(t349) {
        const e1366 = this.json.skins[t349], n968 = {
            joints: e1366.joints
        };
        return void 0 === e1366.inverseBindMatrices ? Promise.resolve(n968) : this.getDependency("accessor", e1366.inverseBindMatrices).then(function(t) {
            return n968.inverseBindMatrices = t, n968;
        });
    }
    loadAnimation(t351) {
        const e1367 = this.json.animations[t351], n969 = [], i682 = [], r508 = [], s347 = [], a270 = [];
        for(let t350 = 0, o210 = e1367.channels.length; t350 < o210; t350++){
            const o211 = e1367.channels[t350], l179 = e1367.samplers[o211.sampler], h139 = o211.target, c98 = void 0 !== h139.node ? h139.node : h139.id, u87 = void 0 !== e1367.parameters ? e1367.parameters[l179.input] : l179.input, d70 = void 0 !== e1367.parameters ? e1367.parameters[l179.output] : l179.output;
            n969.push(this.getDependency("node", c98)), i682.push(this.getDependency("accessor", u87)), r508.push(this.getDependency("accessor", d70)), s347.push(l179), a270.push(h139);
        }
        return Promise.all([
            Promise.all(n969),
            Promise.all(i682),
            Promise.all(r508),
            Promise.all(s347),
            Promise.all(a270)
        ]).then(function(n970) {
            const i683 = n970[0], r509 = n970[1], s348 = n970[2], a271 = n970[3], o212 = n970[4], l180 = [];
            for(let t353 = 0, e1368 = i683.length; t353 < e1368; t353++){
                const e1370 = i683[t353], n972 = r509[t353], h140 = s348[t353], c99 = a271[t353], u88 = o212[t353];
                if (void 0 === e1370) continue;
                let d71;
                switch(e1370.updateMatrix(), e1370.matrixAutoUpdate = !0, oc[u88.path]){
                    case oc.weights:
                        d71 = Qa;
                        break;
                    case oc.rotation:
                        d71 = eo;
                        break;
                    default:
                        d71 = io;
                }
                const p62 = e1370.name ? e1370.name : e1370.uuid, m44 = void 0 !== c99.interpolation ? lc[c99.interpolation] : 2301, f37 = [];
                oc[u88.path] === oc.weights ? e1370.traverse(function(t) {
                    t.morphTargetInfluences && f37.push(t.name ? t.name : t.uuid);
                }) : f37.push(p62);
                let g29 = h140.array;
                if (h140.normalized) {
                    const t = yc(g29.constructor), e1371 = new Float32Array(g29.length);
                    for(let n971 = 0, i684 = g29.length; n971 < i684; n971++)e1371[n971] = g29[n971] * t;
                    g29 = e1371;
                }
                for(let t352 = 0, e1369 = f37.length; t352 < e1369; t352++){
                    const e1372 = new d71(f37[t352] + "." + oc[u88.path], n972.array, g29, m44);
                    "CUBICSPLINE" === c99.interpolation && (e1372.createInterpolant = function(t) {
                        return new (this instanceof eo ? $h : qh)(this.times, this.values, this.getValueSize() / 3, t);
                    }, e1372.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l180.push(e1372);
                }
            }
            const h141 = e1367.name ? e1367.name : "animation_" + t351;
            return new ro(h141, void 0, l180);
        });
    }
    createNodeMesh(t354) {
        const e1373 = this.json, n973 = this, i685 = e1373.nodes[t354];
        return void 0 === i685.mesh ? null : n973.getDependency("mesh", i685.mesh).then(function(t355) {
            const e1374 = n973._getNodeRef(n973.meshCache, i685.mesh, t355);
            return void 0 !== i685.weights && e1374.traverse(function(t) {
                if (t.isMesh) for(let e1375 = 0, n974 = i685.weights.length; e1375 < n974; e1375++)t.morphTargetInfluences[e1375] = i685.weights[e1375];
            }), e1374;
        });
    }
    loadNode(t356) {
        const e1376 = this.json, n975 = this.extensions, i686 = this, r510 = e1376.nodes[t356], s349 = r510.name ? i686.createUniqueName(r510.name) : "";
        return (function() {
            const e1377 = [], n976 = i686._invokeOne(function(e1378) {
                return e1378.createNodeMesh && e1378.createNodeMesh(t356);
            });
            return n976 && e1377.push(n976), void 0 !== r510.camera && e1377.push(i686.getDependency("camera", r510.camera).then(function(t) {
                return i686._getNodeRef(i686.cameraCache, r510.camera, t);
            })), i686._invokeAll(function(e1379) {
                return e1379.createNodeAttachment && e1379.createNodeAttachment(t356);
            }).forEach(function(t) {
                e1377.push(t);
            }), Promise.all(e1377);
        })().then(function(e1380) {
            let a272;
            if (a272 = !0 === r510.isBone ? new as : e1380.length > 1 ? new Rr : 1 === e1380.length ? e1380[0] : new Wt, a272 !== e1380[0]) for(let t = 0, n977 = e1380.length; t < n977; t++)a272.add(e1380[t]);
            if (r510.name && (a272.userData.name = r510.name, a272.name = s349), mc(a272, r510), r510.extensions && pc(n975, a272, r510), void 0 !== r510.matrix) {
                const t = new xt;
                t.fromArray(r510.matrix), a272.applyMatrix4(t);
            } else void 0 !== r510.translation && a272.position.fromArray(r510.translation), void 0 !== r510.rotation && a272.quaternion.fromArray(r510.rotation), void 0 !== r510.scale && a272.scale.fromArray(r510.scale);
            return i686.associations.has(a272) || i686.associations.set(a272, {}), i686.associations.get(a272).nodes = t356, a272;
        });
    }
    loadScene(t359) {
        const e1381 = this.json, n979 = this.extensions, i687 = this.json.scenes[t359], r511 = this, s350 = new Rr;
        i687.name && (s350.name = r511.createUniqueName(i687.name)), mc(s350, i687), i687.extensions && pc(n979, s350, i687);
        const a273 = i687.nodes || [], o213 = [];
        for(let t357 = 0, n978 = a273.length; t357 < n978; t357++)o213.push(bc(a273[t357], s350, e1381, r511));
        return Promise.all(o213).then(function() {
            return r511.associations = ((t360)=>{
                const e1382 = new Map;
                for (const [t358, n980] of r511.associations)(t358 instanceof ie || t358 instanceof F) && e1382.set(t358, n980);
                return t360.traverse((t)=>{
                    const n981 = r511.associations.get(t);
                    null != n981 && e1382.set(t, n981);
                }), e1382;
            })(s350), s350;
        });
    }
}
function bc(t361, e1383, n982, i688) {
    const r512 = n982.nodes[t361];
    return i688.getDependency("node", t361).then(function(t363) {
        if (void 0 === r512.skin) return t363;
        let e1384;
        return i688.getDependency("skin", r512.skin).then(function(t) {
            e1384 = t;
            const n983 = [];
            for(let t362 = 0, r513 = e1384.joints.length; t362 < r513; t362++)n983.push(i688.getDependency("node", e1384.joints[t362]));
            return Promise.all(n983);
        }).then(function(n984) {
            return t363.traverse(function(t) {
                if (!t.isMesh) return;
                const i689 = [], r514 = [];
                for(let t364 = 0, s351 = n984.length; t364 < s351; t364++){
                    const s352 = n984[t364];
                    if (s352) {
                        i689.push(s352);
                        const n985 = new xt;
                        void 0 !== e1384.inverseBindMatrices && n985.fromArray(e1384.inverseBindMatrices.array, 16 * t364), r514.push(n985);
                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e1384.joints[t364]);
                }
                t.bind(new cs(i689, r514), t.matrixWorld);
            }), t363;
        });
    }).then(function(t) {
        e1383.add(t);
        const s353 = [];
        if (r512.children) {
            const e1385 = r512.children;
            for(let r515 = 0, a274 = e1385.length; r515 < a274; r515++){
                const a275 = e1385[r515];
                s353.push(bc(a275, t, n982, i688));
            }
        }
        return Promise.all(s353);
    });
}
function _c(t365, e1387, n986) {
    const i690 = e1387.attributes, r516 = [];
    function s354(e1388, i691) {
        return n986.getDependency("accessor", e1388).then(function(e1389) {
            t365.setAttribute(i691, e1389);
        });
    }
    for(const e1386 in i690){
        const n987 = ac[e1386] || e1386.toLowerCase();
        n987 in t365.attributes || r516.push(s354(i690[e1386], n987));
    }
    if (void 0 !== e1387.indices && !t365.index) {
        const i692 = n986.getDependency("accessor", e1387.indices).then(function(e1390) {
            t365.setIndex(e1390);
        });
        r516.push(i692);
    }
    return mc(t365, e1387), function(t, e1391, n988) {
        const i693 = e1391.attributes, r517 = new j;
        if (void 0 === i693.POSITION) return;
        {
            const t = n988.json.accessors[i693.POSITION], e1392 = t.min, s355 = t.max;
            if (void 0 === e1392 || void 0 === s355) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            if (r517.set(new V(e1392[0], e1392[1], e1392[2]), new V(s355[0], s355[1], s355[2])), t.normalized) {
                const e1393 = yc(nc[t.componentType]);
                r517.min.multiplyScalar(e1393), r517.max.multiplyScalar(e1393);
            }
        }
        const s356 = e1391.targets;
        if (void 0 !== s356) {
            const t = new V, e1394 = new V;
            for(let i694 = 0, r518 = s356.length; i694 < r518; i694++){
                const r519 = s356[i694];
                if (void 0 !== r519.POSITION) {
                    const i695 = n988.json.accessors[r519.POSITION], s357 = i695.min, a276 = i695.max;
                    if (void 0 !== s357 && void 0 !== a276) {
                        if (e1394.setX(Math.max(Math.abs(s357[0]), Math.abs(a276[0]))), e1394.setY(Math.max(Math.abs(s357[1]), Math.abs(a276[1]))), e1394.setZ(Math.max(Math.abs(s357[2]), Math.abs(a276[2]))), i695.normalized) {
                            const t = yc(nc[i695.componentType]);
                            e1394.multiplyScalar(t);
                        }
                        t.max(e1394);
                    } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                }
            }
            r517.expandByVector(t);
        }
        t.boundingBox = r517;
        const a277 = new ct;
        r517.getCenter(a277.center), a277.radius = r517.min.distanceTo(r517.max) / 2, t.boundingSphere = a277;
    }(t365, e1387, n986), Promise.all(r516).then(function() {
        return void 0 !== e1387.targets ? function(t, e1395, n991) {
            let i696 = !1, r520 = !1, s358 = !1;
            for(let t366 = 0, n989 = e1395.length; t366 < n989; t366++){
                const n990 = e1395[t366];
                if (void 0 !== n990.POSITION && (i696 = !0), void 0 !== n990.NORMAL && (r520 = !0), void 0 !== n990.COLOR_0 && (s358 = !0), i696 && r520 && s358) break;
            }
            if (!i696 && !r520 && !s358) return Promise.resolve(t);
            const a278 = [], o214 = [], l181 = [];
            for(let h142 = 0, c100 = e1395.length; h142 < c100; h142++){
                const c101 = e1395[h142];
                if (i696) {
                    const e1396 = void 0 !== c101.POSITION ? n991.getDependency("accessor", c101.POSITION) : t.attributes.position;
                    a278.push(e1396);
                }
                if (r520) {
                    const e1397 = void 0 !== c101.NORMAL ? n991.getDependency("accessor", c101.NORMAL) : t.attributes.normal;
                    o214.push(e1397);
                }
                if (s358) {
                    const e1398 = void 0 !== c101.COLOR_0 ? n991.getDependency("accessor", c101.COLOR_0) : t.attributes.color;
                    l181.push(e1398);
                }
            }
            return Promise.all([
                Promise.all(a278),
                Promise.all(o214),
                Promise.all(l181)
            ]).then(function(e1399) {
                const n992 = e1399[0], a279 = e1399[1], o215 = e1399[2];
                return i696 && (t.morphAttributes.position = n992), r520 && (t.morphAttributes.normal = a279), s358 && (t.morphAttributes.color = o215), t.morphTargetsRelative = !0, t;
            });
        }(t365, e1387.targets, n986) : t365;
    });
}
function wc(t, e1401) {
    let n993 = t.getIndex();
    if (null === n993) {
        const e1400 = [], i697 = t.getAttribute("position");
        if (void 0 === i697) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
        for(let t369 = 0; t369 < i697.count; t369++)e1400.push(t369);
        t.setIndex(e1400), n993 = t.getIndex();
    }
    const i698 = n993.count - 2, r521 = [];
    if (2 === e1401) for(let t367 = 1; t367 <= i698; t367++)r521.push(n993.getX(0)), r521.push(n993.getX(t367)), r521.push(n993.getX(t367 + 1));
    else for(let t368 = 0; t368 < i698; t368++)t368 % 2 == 0 ? (r521.push(n993.getX(t368)), r521.push(n993.getX(t368 + 1)), r521.push(n993.getX(t368 + 2))) : (r521.push(n993.getX(t368 + 2)), r521.push(n993.getX(t368 + 1)), r521.push(n993.getX(t368)));
    r521.length / 3 !== i698 && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s359 = t.clone();
    return s359.setIndex(r521), s359;
}
class Mc {
    constructor(t = 4){
        this.pool = t, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0;
    }
    _initWorker(t) {
        if (!this.workers[t]) {
            const e1402 = this.workerCreator();
            e1402.addEventListener("message", this._onMessage.bind(this, t)), this.workers[t] = e1402;
        }
    }
    _getIdleWorker() {
        for(let t = 0; t < this.pool; t++)if (!(this.workerStatus & 1 << t)) return t;
        return -1;
    }
    _onMessage(t, e1403) {
        const n994 = this.workersResolve[t];
        if (n994 && n994(e1403), this.queue.length) {
            const { resolve: e1404 , msg: n995 , transfer: i699  } = this.queue.shift();
            this.workersResolve[t] = e1404, this.workers[t].postMessage(n995, i699);
        } else this.workerStatus ^= 1 << t;
    }
    setWorkerCreator(t) {
        this.workerCreator = t;
    }
    setWorkerLimit(t) {
        this.pool = t;
    }
    postMessage(t, e1405) {
        return new Promise((n996)=>{
            const i700 = this._getIdleWorker();
            -1 !== i700 ? (this._initWorker(i700), this.workerStatus |= 1 << i700, this.workersResolve[i700] = n996, this.workers[i700].postMessage(t, e1405)) : this.queue.push({
                resolve: n996,
                msg: t,
                transfer: e1405
            });
        });
    }
    dispose() {
        this.workers.forEach((t)=>t.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
    }
}
const Sc = new WeakMap;
let Tc = 0;
class Ec extends lo {
    constructor(t){
        super(t), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new Mc, this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
    }
    setTranscoderPath(t) {
        return this.transcoderPath = t, this;
    }
    setWorkerLimit(t) {
        return this.workerPool.setWorkerLimit(t), this;
    }
    detectSupport(t) {
        return this.workerConfig = {
            astcSupported: t.extensions.has("WEBGL_compressed_texture_astc"),
            etc1Supported: t.extensions.has("WEBGL_compressed_texture_etc1"),
            etc2Supported: t.extensions.has("WEBGL_compressed_texture_etc"),
            dxtSupported: t.extensions.has("WEBGL_compressed_texture_s3tc"),
            bptcSupported: t.extensions.has("EXT_texture_compression_bptc"),
            pvrtcSupported: t.extensions.has("WEBGL_compressed_texture_pvrtc") || t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
        }, t.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1), this;
    }
    init() {
        if (!this.transcoderPending) {
            const t370 = new co(this.manager);
            t370.setPath(this.transcoderPath), t370.setWithCredentials(this.withCredentials);
            const e1406 = t370.loadAsync("basis_transcoder.js"), n997 = new co(this.manager);
            n997.setPath(this.transcoderPath), n997.setResponseType("arraybuffer"), n997.setWithCredentials(this.withCredentials);
            const i701 = n997.loadAsync("basis_transcoder.wasm");
            this.transcoderPending = Promise.all([
                e1406,
                i701
            ]).then(([t372, e1407])=>{
                const n998 = Ec.BasisWorker.toString(), i702 = [
                    "/* constants */",
                    "let _EngineFormat = " + JSON.stringify(Ec.EngineFormat),
                    "let _TranscoderFormat = " + JSON.stringify(Ec.TranscoderFormat),
                    "let _BasisFormat = " + JSON.stringify(Ec.BasisFormat),
                    "/* basis_transcoder.js */",
                    t372,
                    "/* worker */",
                    n998.substring(n998.indexOf("{") + 1, n998.lastIndexOf("}"))
                ].join("\n");
                this.workerSourceURL = URL.createObjectURL(new Blob([
                    i702
                ])), this.transcoderBinary = e1407, this.workerPool.setWorkerCreator(()=>{
                    const t = new Worker(this.workerSourceURL), e1408 = this.transcoderBinary.slice(0);
                    return t.postMessage({
                        type: "init",
                        config: this.workerConfig,
                        transcoderBinary: e1408
                    }, [
                        e1408
                    ]), t;
                });
            }), Tc > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), Tc++;
        }
        return this.transcoderPending;
    }
    load(t373, e1409, n999, i703) {
        if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
        const r522 = new co(this.manager);
        r522.setResponseType("arraybuffer"), r522.setWithCredentials(this.withCredentials);
        const s360 = new Os;
        return r522.load(t373, (t374)=>{
            if (Sc.has(t374)) return Sc.get(t374).promise.then(e1409).catch(i703);
            this._createTexture([
                t374
            ]).then(function(t) {
                s360.copy(t), s360.needsUpdate = !0, e1409 && e1409(s360);
            }).catch(i703);
        }, n999, i703), s360;
    }
    _createTextureFrom(t) {
        const { mipmaps: e1410 , width: n1000 , height: i704 , format: r523 , type: s361 , error: a280 , dfdTransferFn: o216 , dfdFlags: l182  } = t;
        if ("error" === s361) return Promise.reject(a280);
        const h143 = new Os(e1410, n1000, i704, r523, 1009);
        return h143.minFilter = 1 === e1410.length ? 1006 : 1008, h143.magFilter = 1006, h143.generateMipmaps = !1, h143.needsUpdate = !0, h143.encoding = 2 === o216 ? 3001 : 3e3, h143.premultiplyAlpha = !!(1 & l182), h143;
    }
    _createTexture(t375, e1411 = {}) {
        const n1001 = e1411, i705 = this.init().then(()=>this.workerPool.postMessage({
                type: "transcode",
                buffers: t375,
                taskConfig: n1001
            }, t375)).then((t)=>this._createTextureFrom(t.data));
        return Sc.set(t375[0], {
            promise: i705
        }), i705;
    }
    dispose() {
        return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), Tc--, this;
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Ac, Rc;
Ec.BasisFormat = {
    ETC1S: 0,
    UASTC_4x4: 1
}, Ec.TranscoderFormat = {
    ETC1: 0,
    ETC2: 1,
    BC1: 2,
    BC3: 3,
    BC4: 4,
    BC5: 5,
    BC7_M6_OPAQUE_ONLY: 6,
    BC7_M5: 7,
    PVRTC1_4_RGB: 8,
    PVRTC1_4_RGBA: 9,
    ASTC_4x4: 10,
    ATC_RGB: 11,
    ATC_RGBA_INTERPOLATED_ALPHA: 12,
    RGBA32: 13,
    RGB565: 14,
    BGR565: 15,
    RGBA4444: 16
}, Ec.EngineFormat = {
    RGBAFormat: 1023,
    RGBA_ASTC_4x4_Format: 37808,
    RGBA_BPTC_Format: 36492,
    RGBA_ETC2_EAC_Format: 37496,
    RGBA_PVRTC_4BPPV1_Format: 35842,
    RGBA_S3TC_DXT5_Format: 33779,
    RGB_ETC1_Format: 36196,
    RGB_ETC2_Format: 37492,
    RGB_PVRTC_4BPPV1_Format: 35840,
    RGB_S3TC_DXT1_Format: 33776
}, Ec.BasisWorker = function() {
    let t376, e1412, n1002;
    const i706 = _EngineFormat, r524 = _TranscoderFormat, s362 = _BasisFormat;
    self.addEventListener("message", function(a282) {
        const c102 = a282.data;
        switch(c102.type){
            case "init":
                t376 = c102.config, u89 = c102.transcoderBinary, e1412 = new Promise((t)=>{
                    n1002 = {
                        wasmBinary: u89,
                        onRuntimeInitialized: t
                    }, BASIS(n1002);
                }).then(()=>{
                    n1002.initializeBasis(), void 0 === n1002.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
                });
                break;
            case "transcode":
                e1412.then(()=>{
                    try {
                        const { width: e1413 , height: a283 , hasAlpha: u90 , mipmaps: d72 , format: p63 , dfdTransferFn: m45 , dfdFlags: f38  } = function(e1415) {
                            const a285 = new n1002.KTX2File(new Uint8Array(e1415));
                            function c103() {
                                a285.close(), a285.delete();
                            }
                            if (!a285.isValid()) throw c103(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
                            const u92 = a285.isUASTC() ? s362.UASTC_4x4 : s362.ETC1S, d74 = a285.getWidth(), p65 = a285.getHeight(), m47 = a285.getLevels(), f40 = a285.getHasAlpha(), g32 = a285.getDFDTransferFunc(), v31 = a285.getDFDFlags(), { transcoderFormat: y31 , engineFormat: x26  } = function(e1416, n1003, a286, c104) {
                                let u93, d75;
                                const p66 = e1416 === s362.ETC1S ? o217 : l183;
                                for(let i707 = 0; i707 < p66.length; i707++){
                                    const r525 = p66[i707];
                                    if (t376[r525.if] && r525.basisFormat.includes(e1416) && !(c104 && r525.transcoderFormat.length < 2) && (!r525.needsPowerOfTwo || h144(n1003) && h144(a286))) return u93 = r525.transcoderFormat[c104 ? 1 : 0], d75 = r525.engineFormat[c104 ? 1 : 0], {
                                        transcoderFormat: u93,
                                        engineFormat: d75
                                    };
                                }
                                return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), u93 = r524.RGBA32, d75 = i706.RGBAFormat, {
                                    transcoderFormat: u93,
                                    engineFormat: d75
                                };
                            }(u92, d74, p65, f40);
                            if (!d74 || !p65 || !m47) throw c103(), new Error("THREE.KTX2Loader:	Invalid texture");
                            if (!a285.startTranscoding()) throw c103(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                            const b23 = [];
                            for(let t = 0; t < m47; t++){
                                const e1417 = a285.getImageLevelInfo(t, 0, 0), n1004 = e1417.origWidth, i708 = e1417.origHeight, r526 = new Uint8Array(a285.getImageTranscodedSizeInBytes(t, 0, 0, y31));
                                if (!a285.transcodeImage(r526, t, 0, 0, y31, 0, -1, -1)) throw c103(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                b23.push({
                                    data: r526,
                                    width: n1004,
                                    height: i708
                                });
                            }
                            return c103(), {
                                width: d74,
                                height: p65,
                                hasAlpha: f40,
                                mipmaps: b23,
                                format: x26,
                                dfdTransferFn: g32,
                                dfdFlags: v31
                            };
                        }(c102.buffers[0]), g30 = [];
                        for(let t377 = 0; t377 < d72.length; ++t377)g30.push(d72[t377].data.buffer);
                        self.postMessage({
                            type: "transcode",
                            id: c102.id,
                            width: e1413,
                            height: a283,
                            hasAlpha: u90,
                            mipmaps: d72,
                            format: p63,
                            dfdTransferFn: m45,
                            dfdFlags: f38
                        }, g30);
                    } catch (t) {
                        console.error(t), self.postMessage({
                            type: "error",
                            id: c102.id,
                            error: t.message
                        });
                    }
                });
        }
        var u89;
    });
    const a281 = [
        {
            if: "astcSupported",
            basisFormat: [
                s362.UASTC_4x4
            ],
            transcoderFormat: [
                r524.ASTC_4x4,
                r524.ASTC_4x4
            ],
            engineFormat: [
                i706.RGBA_ASTC_4x4_Format,
                i706.RGBA_ASTC_4x4_Format
            ],
            priorityETC1S: 1 / 0,
            priorityUASTC: 1,
            needsPowerOfTwo: !1
        },
        {
            if: "bptcSupported",
            basisFormat: [
                s362.ETC1S,
                s362.UASTC_4x4
            ],
            transcoderFormat: [
                r524.BC7_M5,
                r524.BC7_M5
            ],
            engineFormat: [
                i706.RGBA_BPTC_Format,
                i706.RGBA_BPTC_Format
            ],
            priorityETC1S: 3,
            priorityUASTC: 2,
            needsPowerOfTwo: !1
        },
        {
            if: "dxtSupported",
            basisFormat: [
                s362.ETC1S,
                s362.UASTC_4x4
            ],
            transcoderFormat: [
                r524.BC1,
                r524.BC3
            ],
            engineFormat: [
                i706.RGB_S3TC_DXT1_Format,
                i706.RGBA_S3TC_DXT5_Format
            ],
            priorityETC1S: 4,
            priorityUASTC: 5,
            needsPowerOfTwo: !1
        },
        {
            if: "etc2Supported",
            basisFormat: [
                s362.ETC1S,
                s362.UASTC_4x4
            ],
            transcoderFormat: [
                r524.ETC1,
                r524.ETC2
            ],
            engineFormat: [
                i706.RGB_ETC2_Format,
                i706.RGBA_ETC2_EAC_Format
            ],
            priorityETC1S: 1,
            priorityUASTC: 3,
            needsPowerOfTwo: !1
        },
        {
            if: "etc1Supported",
            basisFormat: [
                s362.ETC1S,
                s362.UASTC_4x4
            ],
            transcoderFormat: [
                r524.ETC1
            ],
            engineFormat: [
                i706.RGB_ETC1_Format
            ],
            priorityETC1S: 2,
            priorityUASTC: 4,
            needsPowerOfTwo: !1
        },
        {
            if: "pvrtcSupported",
            basisFormat: [
                s362.ETC1S,
                s362.UASTC_4x4
            ],
            transcoderFormat: [
                r524.PVRTC1_4_RGB,
                r524.PVRTC1_4_RGBA
            ],
            engineFormat: [
                i706.RGB_PVRTC_4BPPV1_Format,
                i706.RGBA_PVRTC_4BPPV1_Format
            ],
            priorityETC1S: 5,
            priorityUASTC: 6,
            needsPowerOfTwo: !0
        }
    ], o217 = a281.sort(function(t, e1418) {
        return t.priorityETC1S - e1418.priorityETC1S;
    }), l183 = a281.sort(function(t, e1419) {
        return t.priorityUASTC - e1419.priorityUASTC;
    });
    function h144(t) {
        return t <= 2 || 0 == (t & t - 1) && 0 !== t;
    }
};
const Cc = Symbol("retainerCount"), Lc = Symbol("recentlyUsed"), Pc = Symbol("evict"), Dc = Symbol("evictionThreshold"), Ic = Symbol("cache");
class Oc {
    constructor(t, e1420 = 5){
        this[Ac] = new Map, this[Rc] = [], this[Ic] = t, this[Dc] = e1420;
    }
    set evictionThreshold(t) {
        this[Dc] = t, this[Pc]();
    }
    get evictionThreshold() {
        return this[Dc];
    }
    get cache() {
        return this[Ic];
    }
    retainerCount(t) {
        return this[Cc].get(t) || 0;
    }
    reset() {
        this[Cc].clear(), this[Lc] = [];
    }
    retain(t) {
        this[Cc].has(t) || this[Cc].set(t, 0), this[Cc].set(t, this[Cc].get(t) + 1);
        const e1421 = this[Lc].indexOf(t);
        -1 !== e1421 && this[Lc].splice(e1421, 1), this[Lc].unshift(t), this[Pc]();
    }
    release(t) {
        this[Cc].has(t) && this[Cc].set(t, Math.max(this[Cc].get(t) - 1, 0)), this[Pc]();
    }
    [(Ac = Cc, Rc = Lc, Pc)]() {
        if (!(this[Lc].length < this[Dc])) for(let t = this[Lc].length - 1; t >= this[Dc]; --t){
            const e1422 = this[Lc][t];
            0 === this[Cc].get(e1422) && (this[Ic].delete(e1422), this[Lc].splice(t, 1));
        }
    }
}
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Nc = (t)=>{
    const e1423 = new Map;
    for (const n1005 of t.mappings)for (const t379 of n1005.variants)e1423.set(t379, {
        material: null,
        gltfMaterialIndex: n1005.material
    });
    return e1423;
};
class Fc {
    constructor(t){
        this.parser = t, this.name = "KHR_materials_variants";
    }
    afterRoot(t380) {
        const e1424 = this.parser, n1006 = e1424.json;
        if (void 0 === n1006.extensions || void 0 === n1006.extensions[this.name]) return null;
        const i710 = ((t)=>{
            const e1425 = [], n1007 = new Set;
            for (const i711 of t){
                let t = i711, r527 = 0;
                for(; n1007.has(t);)t = i711 + "." + ++r527;
                n1007.add(t), e1425.push(t);
            }
            return e1425;
        })((n1006.extensions[this.name].variants || []).map((t)=>t.name));
        for (const i709 of t380.scenes)i709.traverse((t)=>{
            const i712 = t;
            if (!i712.isMesh) return;
            const r528 = e1424.associations.get(i712);
            if (null == r528 || null == r528.meshes || null == r528.primitives) return;
            const s363 = n1006.meshes[r528.meshes].primitives[r528.primitives].extensions;
            s363 && s363[this.name] && (i712.userData.variantMaterials = Nc(s363[this.name]));
        });
        return t380.userData.variants = i710, Promise.resolve();
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Uc, kc;
const Bc = new Map, zc = new Map;
let Hc;
const Vc = new class extends lo {
    constructor(t){
        super(t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        }, this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        };
    }
    setDecoderPath(t) {
        return this.decoderPath = t, this;
    }
    setDecoderConfig(t) {
        return this.decoderConfig = t, this;
    }
    setWorkerLimit(t) {
        return this.workerLimit = t, this;
    }
    load(t381, e1426, n1008, i713) {
        const r529 = new co(this.manager);
        r529.setPath(this.path), r529.setResponseType("arraybuffer"), r529.setRequestHeader(this.requestHeader), r529.setWithCredentials(this.withCredentials), r529.load(t381, (t)=>{
            const n1009 = {
                attributeIDs: this.defaultAttributeIDs,
                attributeTypes: this.defaultAttributeTypes,
                useUniqueIDs: !1
            };
            this.decodeGeometry(t, n1009).then(e1426).catch(i713);
        }, n1008, i713);
    }
    decodeDracoFile(t, e1427, n1010, i714) {
        const r530 = {
            attributeIDs: n1010 || this.defaultAttributeIDs,
            attributeTypes: i714 || this.defaultAttributeTypes,
            useUniqueIDs: !!n1010
        };
        this.decodeGeometry(t, r530).then(e1427);
    }
    decodeGeometry(t383, e1428) {
        for(const t382 in e1428.attributeTypes){
            const n1011 = e1428.attributeTypes[t382];
            void 0 !== n1011.BYTES_PER_ELEMENT && (e1428.attributeTypes[t382] = n1011.name);
        }
        const n1012 = JSON.stringify(e1428);
        if (_h.has(t383)) {
            const e1429 = _h.get(t383);
            if (e1429.key === n1012) return e1429.promise;
            if (0 === t383.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
        }
        let i715;
        const r531 = this.workerNextTaskID++, s364 = t383.byteLength, a287 = this._getWorker(r531, s364).then((n1013)=>(i715 = n1013, new Promise((n1014, s365)=>{
                i715._callbacks[r531] = {
                    resolve: n1014,
                    reject: s365
                }, i715.postMessage({
                    type: "decode",
                    id: r531,
                    taskConfig: e1428,
                    buffer: t383
                }, [
                    t383
                ]);
            }))).then((t)=>this._createGeometry(t.geometry));
        return a287.catch(()=>!0).then(()=>{
            i715 && r531 && this._releaseTask(i715, r531);
        }), _h.set(t383, {
            key: n1012,
            promise: a287
        }), a287;
    }
    _createGeometry(t) {
        const e1430 = new ye;
        t.index && e1430.setIndex(new oe(t.index.array, 1));
        for(let n1015 = 0; n1015 < t.attributes.length; n1015++){
            const i716 = t.attributes[n1015], r532 = i716.name, s366 = i716.array, a288 = i716.itemSize;
            e1430.setAttribute(r532, new oe(s366, a288));
        }
        return e1430;
    }
    _loadLibrary(t, e1431) {
        const n1016 = new co(this.manager);
        return n1016.setPath(this.decoderPath), n1016.setResponseType(e1431), n1016.setWithCredentials(this.withCredentials), new Promise((e1432, i717)=>{
            n1016.load(t, e1432, void 0, i717);
        });
    }
    preload() {
        return this._initDecoder(), this;
    }
    _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type, e1433 = [];
        return t ? e1433.push(this._loadLibrary("draco_decoder.js", "text")) : (e1433.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e1433.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e1433).then((e1434)=>{
            const n1017 = e1434[0];
            t || (this.decoderConfig.wasmBinary = e1434[1]);
            const i718 = wh.toString(), r533 = [
                "/* draco decoder */",
                n1017,
                "",
                "/* worker */",
                i718.substring(i718.indexOf("{") + 1, i718.lastIndexOf("}"))
            ].join("\n");
            this.workerSourceURL = URL.createObjectURL(new Blob([
                r533
            ]));
        }), this.decoderPending;
    }
    _getWorker(t384, e1435) {
        return this._initDecoder().then(()=>{
            if (this.workerPool.length < this.workerLimit) {
                const t = new Worker(this.workerSourceURL);
                t._callbacks = {}, t._taskCosts = {}, t._taskLoad = 0, t.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }), t.onmessage = function(e1436) {
                    const n1019 = e1436.data;
                    switch(n1019.type){
                        case "decode":
                            t._callbacks[n1019.id].resolve(n1019);
                            break;
                        case "error":
                            t._callbacks[n1019.id].reject(n1019);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + n1019.type + '"');
                    }
                }, this.workerPool.push(t);
            } else this.workerPool.sort(function(t, e1437) {
                return t._taskLoad > e1437._taskLoad ? -1 : 1;
            });
            const n1018 = this.workerPool[this.workerPool.length - 1];
            return n1018._taskCosts[t384] = e1435, n1018._taskLoad += e1435, n1018;
        });
    }
    _releaseTask(t, e1438) {
        t._taskLoad -= t._taskCosts[e1438], delete t._callbacks[e1438], delete t._taskCosts[e1438];
    }
    debug() {
        console.log("Task load: ", this.workerPool.map((t)=>t._taskLoad));
    }
    dispose() {
        for(let t = 0; t < this.workerPool.length; ++t)this.workerPool[t].terminate();
        return this.workerPool.length = 0, this;
    }
};
let Gc;
const Wc = new Ec;
let jc, qc;
const Xc = Symbol("loader"), $c = Symbol("evictionPolicy"), Yc = Symbol("GLTFInstance");
class Jc extends i {
    constructor(t385){
        super(), this[kc] = (new Mh).register((t)=>new Fc(t)), this[Yc] = t385, this[Xc].setDRACOLoader(Vc), this[Xc].setKTX2Loader(Wc);
    }
    static setDRACODecoderLocation(t) {
        Hc = t, Vc.setDecoderPath(t);
    }
    static getDRACODecoderLocation() {
        return Hc;
    }
    static setKTX2TranscoderLocation(t) {
        Gc = t, Wc.setTranscoderPath(t);
    }
    static getKTX2TranscoderLocation() {
        return Gc;
    }
    static setMeshoptDecoderLocation(t386) {
        var e1439;
        jc !== t386 && (jc = t386, qc = (e1439 = t386, new Promise((t, n1020)=>{
            const i719 = document.createElement("script");
            document.body.appendChild(i719), i719.onload = t, i719.onerror = n1020, i719.async = !0, i719.src = e1439;
        })).then(()=>MeshoptDecoder.ready).then(()=>MeshoptDecoder));
    }
    static getMeshoptDecoderLocation() {
        return jc;
    }
    static initializeKTX2Loader(t) {
        Wc.detectSupport(t);
    }
    static get cache() {
        return Bc;
    }
    static clearCache() {
        Bc.forEach((t, e1440)=>{
            this.delete(e1440);
        }), this[$c].reset();
    }
    static has(t) {
        return Bc.has(t);
    }
    static async delete(t) {
        if (!this.has(t)) return;
        const e1441 = Bc.get(t);
        zc.delete(t), Bc.delete(t);
        (await e1441).dispose();
    }
    static hasFinishedLoading(t) {
        return !!zc.get(t);
    }
    get [(Uc = $c, kc = Xc, $c)]() {
        return this.constructor[$c];
    }
    async preload(t387, e1442, n1021 = ()=>{}) {
        if (this[Xc].setWithCredentials(Jc.withCredentials), this.dispatchEvent({
            type: "preload",
            element: e1442,
            src: t387
        }), !Bc.has(t387)) {
            null != qc && this[Xc].setMeshoptDecoder(await qc);
            const e1443 = ((t388, e1445, n1022 = ()=>{})=>{
                const i722 = (t)=>{
                    const e1446 = t.loaded / t.total;
                    n1022(Math.max(0, Math.min(1, isFinite(e1446) ? e1446 : 1)));
                };
                return new Promise((n1023, r536)=>{
                    e1445.load(t388, n1023, i722, r536);
                });
            })(t387, this[Xc], (t)=>{
                n1021(.8 * t);
            }), i720 = this[Yc], r534 = e1443.then((t)=>i720.prepare(t)).then((t)=>(n1021(.9), new i720(t))).catch((t)=>(console.error(t), new i720));
            Bc.set(t387, r534);
        }
        await Bc.get(t387), zc.set(t387, !0), n1021 && n1021(1);
    }
    async load(t, e1447, n1024 = ()=>{}) {
        await this.preload(t, e1447, n1024);
        const i723 = await Bc.get(t), r537 = await i723.clone();
        return this[$c].retain(t), r537.dispose = ()=>{
            this[$c].release(t);
        }, r537;
    }
}
Jc[Uc] = new Oc(Jc);
class Kc extends Wt {
    constructor(t389 = document.createElement("div")){
        super(), this.element = t389, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.addEventListener("removed", function() {
            this.traverse(function(t) {
                t.element instanceof Element && null !== t.element.parentNode && t.element.parentNode.removeChild(t.element);
            });
        });
    }
    copy(t, e1448) {
        return super.copy(t, e1448), this.element = t.element.cloneNode(!0), this;
    }
}
Kc.prototype.isCSS2DObject = !0;
const Zc = new V, Qc = new xt, tu = new xt, eu = new V, nu = new V;
class iu {
    constructor(t390 = {}){
        const e1450 = this;
        let n1025, i724, r539, s367;
        const a289 = {
            objects: new WeakMap
        }, o218 = void 0 !== t390.element ? t390.element : document.createElement("div");
        function l184(t, n1026, i725) {
            if (t.isCSS2DObject) {
                Zc.setFromMatrixPosition(t.matrixWorld), Zc.applyMatrix4(tu);
                const l185 = !0 === t.visible && Zc.z >= -1 && Zc.z <= 1 && !0 === t.layers.test(i725.layers);
                if (t.element.style.display = !0 === l185 ? "" : "none", !0 === l185) {
                    t.onBeforeRender(e1450, n1026, i725);
                    const a290 = t.element;
                    /apple/i.test(navigator.vendor) ? a290.style.transform = "translate(-50%,-50%) translate(" + Math.round(Zc.x * r539 + r539) + "px," + Math.round(-Zc.y * s367 + s367) + "px)" : a290.style.transform = "translate(-50%,-50%) translate(" + (Zc.x * r539 + r539) + "px," + (-Zc.y * s367 + s367) + "px)", a290.parentNode !== o218 && o218.appendChild(a290), t.onAfterRender(e1450, n1026, i725);
                }
                const c105 = {
                    distanceToCameraSquared: h145(i725, t)
                };
                a289.objects.set(t, c105);
            }
            for(let e1449 = 0, r538 = t.children.length; e1449 < r538; e1449++)l184(t.children[e1449], n1026, i725);
        }
        function h145(t, e1451) {
            return eu.setFromMatrixPosition(t.matrixWorld), nu.setFromMatrixPosition(e1451.matrixWorld), eu.distanceToSquared(nu);
        }
        o218.style.overflow = "hidden", this.domElement = o218, this.getSize = function() {
            return {
                width: n1025,
                height: i724
            };
        }, this.render = function(t392, e1452) {
            !0 === t392.autoUpdate && t392.updateMatrixWorld(), null === e1452.parent && e1452.updateMatrixWorld(), Qc.copy(e1452.matrixWorldInverse), tu.multiplyMatrices(e1452.projectionMatrix, Qc), l184(t392, t392, e1452), function(t393) {
                const e1453 = (function(t394) {
                    const e1454 = [];
                    return t394.traverse(function(t) {
                        t.isCSS2DObject && e1454.push(t);
                    }), e1454;
                })(t393).sort(function(t, e1455) {
                    if (t.renderOrder !== e1455.renderOrder) return e1455.renderOrder - t.renderOrder;
                    return a289.objects.get(t).distanceToCameraSquared - a289.objects.get(e1455).distanceToCameraSquared;
                }), n1027 = e1453.length;
                for(let t391 = 0, i726 = e1453.length; t391 < i726; t391++)e1453[t391].element.style.zIndex = n1027 - t391;
            }(t392);
        }, this.setSize = function(t, e1456) {
            n1025 = t, i724 = e1456, r539 = n1025 / 2, s367 = i724 / 2, o218.style.width = t + "px", o218.style.height = e1456 + "px";
        };
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const ru = (t)=>t && "null" !== t ? au(t) : null, su = ()=>{
    if (ph) return;
    const t = [];
    throw hh || t.push("WebXR Device API"), ch || t.push("WebXR Hit Test API"), new Error(`The following APIs are required for AR, but are missing in this browser: ${t.join(", ")}`);
}, au = (t)=>new URL(t, window.location.toString()).toString(), ou = (t, e1457)=>{
    let n1028 = null;
    return (...i727)=>{
        null != n1028 && self.clearTimeout(n1028), n1028 = self.setTimeout(()=>{
            n1028 = null, t(...i727);
        }, e1457);
    };
}, lu = (t, e1458, n1029)=>Math.max(e1458, Math.min(n1029, t)), hu = (()=>{
    const t396 = (()=>{
        var t;
        if (null === (t = document.documentElement.getAttribute("itemtype")) || void 0 === t ? void 0 : t.includes("schema.org/SearchResultsPage")) return !0;
        const e1459 = null != document.head ? Array.from(document.head.querySelectorAll("meta")) : [];
        for (const t395 of e1459)if ("viewport" === t395.name) return !0;
        return !1;
    })();
    return t396 || console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'), ()=>t396 ? window.devicePixelRatio : 1;
})(), cu = (()=>{
    const t = new RegExp("[?&]model-viewer-debug-mode(&|$)");
    return ()=>self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(t);
})(), uu = (t = 0)=>new Promise((e1460)=>setTimeout(e1460, t));
class du {
    constructor(t = 50){
        this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(t);
    }
    setDecayTime(t) {
        this.naturalFrequency = 1 / Math.max(.001, t);
    }
    update(t, e1461, n1030, i728) {
        const r540 = 2e-4 * this.naturalFrequency;
        if (null == t || 0 === i728) return e1461;
        if (t === e1461 && 0 === this.velocity) return e1461;
        if (n1030 < 0) return t;
        const s368 = t - e1461, a291 = this.velocity + this.naturalFrequency * s368, o219 = s368 + n1030 * a291, l186 = Math.exp(-this.naturalFrequency * n1030), h146 = (a291 - this.naturalFrequency * o219) * l186, c106 = -this.naturalFrequency * (h146 + a291 * l186);
        return Math.abs(h146) < r540 * Math.abs(i728) && c106 * s368 >= 0 ? (this.velocity = 0, e1461) : (this.velocity = h146, e1461 + o219 * l186);
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const pu = (t, e1462)=>({
        type: "number",
        number: t,
        unit: e1462
    }), mu = (()=>{
    const t397 = {};
    return (e1463)=>{
        const n1031 = e1463;
        if (n1031 in t397) return t397[n1031];
        const i729 = [];
        let r541 = 0;
        for(; e1463;){
            if (++r541 > 1e3) {
                e1463 = "";
                break;
            }
            const t = fu(e1463), n1032 = t.nodes[0];
            if (null == n1032 || 0 === n1032.terms.length) break;
            i729.push(n1032), e1463 = t.remainingInput;
        }
        return t397[n1031] = i729;
    };
})(), fu = (()=>{
    const t398 = /^(\-\-|[a-z\u0240-\uffff])/i, e1464 = /^([\*\+\/]|[\-]\s)/i, n1033 = /^[\),]/;
    return (i730)=>{
        const r542 = [];
        for(; i730.length && (i730 = i730.trim(), !n1033.test(i730));)if ("(" === i730[0]) {
            const { nodes: t , remainingInput: e1465  } = xu(i730);
            i730 = e1465, r542.push({
                type: "function",
                name: {
                    type: "ident",
                    value: "calc"
                },
                arguments: t
            });
        } else if (t398.test(i730)) {
            const t = gu(i730), e1466 = t.nodes[0];
            if ("(" === (i730 = t.remainingInput)[0]) {
                const { nodes: t , remainingInput: n1034  } = xu(i730);
                r542.push({
                    type: "function",
                    name: e1466,
                    arguments: t
                }), i730 = n1034;
            } else r542.push(e1466);
        } else if (e1464.test(i730)) r542.push({
            type: "operator",
            value: i730[0]
        }), i730 = i730.slice(1);
        else {
            const { nodes: t , remainingInput: e1467  } = "#" === i730[0] ? yu(i730) : vu(i730);
            if (0 === t.length) break;
            r542.push(t[0]), i730 = e1467;
        }
        return {
            nodes: [
                {
                    type: "expression",
                    terms: r542
                }
            ],
            remainingInput: i730
        };
    };
})(), gu = (()=>{
    const t = /[^a-z0-9_\-\u0240-\uffff]/i;
    return (e1468)=>{
        const n1035 = e1468.match(t);
        return {
            nodes: [
                {
                    type: "ident",
                    value: null == n1035 ? e1468 : e1468.substr(0, n1035.index)
                }
            ],
            remainingInput: null == n1035 ? "" : e1468.substr(n1035.index)
        };
    };
})(), vu = (()=>{
    const t = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/, e1469 = /^[a-z%]+/i, n1036 = /^(m|mm|cm|rad|deg|[%])$/;
    return (i731)=>{
        const r543 = i731.match(t), s369 = null == r543 ? "0" : r543[0], a292 = (i731 = null == s369 ? i731 : i731.slice(s369.length)).match(e1469);
        let o220 = null != a292 && "" !== a292[0] ? a292[0] : null;
        const l187 = null == a292 ? i731 : i731.slice(o220.length);
        return null == o220 || n1036.test(o220) || (o220 = null), {
            nodes: [
                {
                    type: "number",
                    number: parseFloat(s369) || 0,
                    unit: o220
                }
            ],
            remainingInput: l187
        };
    };
})(), yu = (()=>{
    const t = /^[a-f0-9]*/i;
    return (e1470)=>{
        const n1037 = (e1470 = e1470.slice(1).trim()).match(t);
        return {
            nodes: null == n1037 ? [] : [
                {
                    type: "hex",
                    value: n1037[0]
                }
            ],
            remainingInput: null == n1037 ? e1470 : e1470.slice(n1037[0].length)
        };
    };
})(), xu = (t)=>{
    const e1471 = [];
    for(t = t.slice(1).trim(); t.length;){
        const n1038 = fu(t);
        if (e1471.push(n1038.nodes[0]), "," === (t = n1038.remainingInput.trim())[0]) t = t.slice(1).trim();
        else if (")" === t[0]) {
            t = t.slice(1);
            break;
        }
    }
    return {
        nodes: e1471,
        remainingInput: t
    };
}, bu = Symbol("visitedTypes");
class _u {
    constructor(t){
        this[bu] = t;
    }
    walk(t, e1472) {
        const n1039 = t.slice();
        for(; n1039.length;){
            const t = n1039.shift();
            switch(this[bu].indexOf(t.type) > -1 && e1472(t), t.type){
                case "expression":
                    n1039.unshift(...t.terms);
                    break;
                case "function":
                    n1039.unshift(t.name, ...t.arguments);
            }
        }
    }
}
const wu = Object.freeze({
    type: "number",
    number: 0,
    unit: null
}), Mu = (t, e1473 = 0)=>{
    let { number: n1040 , unit: i732  } = t;
    if (isFinite(n1040)) {
        if ("rad" === t.unit || null == t.unit) return t;
    } else n1040 = e1473, i732 = "rad";
    return {
        type: "number",
        number: ("deg" === i732 && null != n1040 ? n1040 : 0) * Math.PI / 180,
        unit: "rad"
    };
}, Su = (t, e1474 = 0)=>{
    let n1041, { number: i733 , unit: r544  } = t;
    if (isFinite(i733)) {
        if ("m" === t.unit) return t;
    } else i733 = e1474, r544 = "m";
    switch(r544){
        default:
            n1041 = 1;
            break;
        case "cm":
            n1041 = .01;
            break;
        case "mm":
            n1041 = .001;
    }
    return {
        type: "number",
        number: n1041 * i733,
        unit: "m"
    };
}, Tu = (()=>{
    const t399 = (t)=>t, e1475 = {
        rad: t399,
        deg: Mu,
        m: t399,
        mm: Su,
        cm: Su
    };
    return (t, n1042 = wu)=>{
        isFinite(t.number) || (t.number = n1042.number, t.unit = n1042.unit);
        const { unit: i734  } = t;
        if (null == i734) return t;
        const r545 = e1475[i734];
        return null == r545 ? n1042 : r545(t);
    };
})();
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Eu extends Kc {
    constructor(t){
        super(document.createElement("div")), this.normal = new V(0, 1, 0), this.initialized = !1, this.referenceCount = 1, this.pivot = document.createElement("div"), this.slot = document.createElement("slot"), this.element.classList.add("annotation-wrapper"), this.slot.name = t.name, this.element.appendChild(this.pivot), this.pivot.appendChild(this.slot), this.updatePosition(t.position), this.updateNormal(t.normal);
    }
    get facingCamera() {
        return !this.element.classList.contains("hide");
    }
    show() {
        this.facingCamera && this.initialized || this.updateVisibility(!0);
    }
    hide() {
        !this.facingCamera && this.initialized || this.updateVisibility(!1);
    }
    increment() {
        this.referenceCount++;
    }
    decrement() {
        return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount;
    }
    updatePosition(t) {
        if (null == t) return;
        const e1476 = mu(t)[0].terms;
        for(let t400 = 0; t400 < 3; ++t400)this.position.setComponent(t400, Tu(e1476[t400]).number);
        this.updateMatrixWorld();
    }
    updateNormal(t) {
        if (null == t) return;
        const e1477 = mu(t)[0].terms;
        for(let t401 = 0; t401 < 3; ++t401)this.normal.setComponent(t401, Tu(e1477[t401]).number);
    }
    orient(t) {
        this.pivot.style.transform = `rotate(${t}rad)`;
    }
    updateVisibility(t) {
        t ? this.element.classList.remove("hide") : this.element.classList.add("hide"), this.slot.assignedNodes().forEach((e1478)=>{
            if (e1478.nodeType !== Node.ELEMENT_NODE) return;
            const n1043 = e1478, i735 = n1043.dataset.visibilityAttribute;
            if (null != i735) {
                const e1479 = `data-${i735}`;
                t ? n1043.setAttribute(e1479, "") : n1043.removeAttribute(e1479);
            }
            n1043.dispatchEvent(new CustomEvent("hotspot-visibility", {
                detail: {
                    visible: t
                }
            }));
        }), this.initialized = !0;
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Au = (t402, e1480, n1044)=>{
    let i736 = n1044;
    const r546 = new V;
    return t402.traverseVisible((t403)=>{
        let n1045, s370;
        t403.updateWorldMatrix(!1, !1);
        const a293 = t403.geometry;
        if (void 0 !== a293) {
            if (a293.isGeometry) {
                const o221 = a293.vertices;
                for(n1045 = 0, s370 = o221.length; n1045 < s370; n1045++)r546.copy(o221[n1045]), t403.isSkinnedMesh ? t403.boneTransform(n1045, r546) : r546.applyMatrix4(t403.matrixWorld), i736 = e1480(i736, r546);
            } else if (a293.isBufferGeometry) {
                const { position: o222  } = a293.attributes;
                if (void 0 !== o222) {
                    const a294 = ((t)=>{
                        if (!t.normalized) return 1;
                        const e1481 = t.array;
                        return e1481 instanceof Int8Array ? 1 / 127 : e1481 instanceof Uint8Array ? 1 / 255 : e1481 instanceof Int16Array ? 1 / 32767 : e1481 instanceof Uint16Array ? 1 / 65535 : 1;
                    })(o222);
                    for(n1045 = 0, s370 = o222.count; n1045 < s370; n1045++)r546.fromBufferAttribute(o222, n1045), r546.multiplyScalar(a294), t403.isSkinnedMesh ? t403.boneTransform(n1045, r546) : r546.applyMatrix4(t403.matrixWorld), i736 = e1480(i736, r546);
                }
            }
        }
    }), i736;
}, Ru = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        h: {
            value: 1 / 512
        }
    },
    vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}",
    fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float h;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}"
}, Cu = {
    uniforms: {
        tDiffuse: {
            value: null
        },
        v: {
            value: 1 / 512
        }
    },
    vertexShader: "\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vUv = uv;\n			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n		}",
    fragmentShader: "\n\n		uniform sampler2D tDiffuse;\n		uniform float v;\n\n		varying vec2 vUv;\n\n		void main() {\n\n			vec4 sum = vec4( 0.0 );\n\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n			gl_FragColor = sum;\n\n		}"
}, Lu = [];
for(let t8 = 0; t8 < 256; t8++)Lu[t8] = (t8 < 16 ? "0" : "") + t8.toString(16);
function Pu(t, e1482, n1046) {
    return (1 - n1046) * t + n1046 * e1482;
}
/* @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Du extends Wt {
    constructor(t404, e1483, n1047){
        super(), this.camera = new mn, this.renderTarget = null, this.renderTargetBlur = null, this.depthMaterial = new _r, this.horizontalBlurMaterial = new Ve(Ru), this.verticalBlurMaterial = new Ve(Cu), this.intensity = 0, this.softness = 1, this.boundingBox = new j, this.size = new V, this.maxDimension = 0, this.isAnimated = !1, this.needsUpdate = !1;
        const { camera: i737  } = this;
        i737.rotation.x = Math.PI / 2, i737.left = -0.5, i737.right = .5, i737.bottom = -0.5, i737.top = .5, this.add(i737);
        const r547 = new rn, s371 = new re({
            opacity: 1,
            transparent: !0,
            side: 1
        });
        this.floor = new Fe(r547, s371), this.floor.userData.shadow = !0, i737.add(this.floor), this.blurPlane = new Fe(r547), this.blurPlane.visible = !1, i737.add(this.blurPlane), t404.target.add(this), this.depthMaterial.onBeforeCompile = function(t) {
            t.fragmentShader = t.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );");
        }, this.horizontalBlurMaterial.depthTest = !1, this.verticalBlurMaterial.depthTest = !1, this.setScene(t404, e1483, n1047);
    }
    setScene(t, e1486, n1048) {
        const { boundingBox: i738 , size: r548 , rotation: s372 , position: a295  } = this;
        if (this.isAnimated = t.animationNames.length > 0, this.boundingBox.copy(t.boundingBox), this.size.copy(t.size), this.maxDimension = Math.max(r548.x, r548.y, r548.z) * (this.isAnimated ? 2 : 1), this.boundingBox.getCenter(a295), "back" === n1048) {
            const { min: t , max: e1484  } = i738;
            [t.y, t.z] = [
                t.z,
                t.y
            ], [e1484.y, e1484.z] = [
                e1484.z,
                e1484.y
            ], [r548.y, r548.z] = [
                r548.z,
                r548.y
            ], s372.x = Math.PI / 2, s372.y = Math.PI;
        } else s372.x = 0, s372.y = 0;
        if (this.isAnimated) {
            const t = i738.min.y, e1485 = i738.max.y;
            r548.y = this.maxDimension, i738.expandByVector(r548.subScalar(this.maxDimension).multiplyScalar(-0.5)), i738.min.y = t, i738.max.y = e1485, r548.set(this.maxDimension, e1485 - t, this.maxDimension);
        }
        "bottom" === n1048 ? a295.y = i738.min.y : a295.z = i738.min.y, this.setSoftness(e1486);
    }
    setSoftness(t) {
        this.softness = t;
        const { size: e1487 , camera: n1049  } = this, i739 = this.isAnimated ? 2 : 1, r549 = i739 * Math.pow(2, 9 - 3 * t);
        this.setMapSize(r549);
        const s373 = e1487.y / 2, a296 = e1487.y * i739;
        n1049.near = 0, n1049.far = Pu(a296, s373, t), this.depthMaterial.opacity = 1 / t, n1049.updateProjectionMatrix(), this.setIntensity(this.intensity), this.setOffset(0);
    }
    setMapSize(t) {
        const { size: e1488  } = this;
        this.isAnimated && (t *= 2);
        const n1050 = Math.floor(e1488.x > e1488.z ? t : t * e1488.x / e1488.z), i740 = Math.floor(e1488.x > e1488.z ? t * e1488.z / e1488.x : t), r550 = 10 + n1050, s374 = 10 + i740;
        if (null == this.renderTarget || this.renderTarget.width === r550 && this.renderTarget.height === s374 || (this.renderTarget.dispose(), this.renderTarget = null, this.renderTargetBlur.dispose(), this.renderTargetBlur = null), null == this.renderTarget) {
            const t = {
                format: 1023
            };
            this.renderTarget = new k(r550, s374, t), this.renderTargetBlur = new k(r550, s374, t), this.floor.material.map = this.renderTarget.texture;
        }
        this.camera.scale.set(e1488.x * (1 + 10 / n1050), e1488.z * (1 + 10 / i740), 1), this.needsUpdate = !0;
    }
    setIntensity(t) {
        this.intensity = t, t > 0 ? (this.visible = !0, this.floor.visible = !0, this.floor.material.opacity = t * Pu(.3, 1, this.softness * this.softness)) : (this.visible = !1, this.floor.visible = !1);
    }
    getIntensity() {
        return this.intensity;
    }
    setOffset(t) {
        this.floor.position.z = -t + .001 * this.maxDimension;
    }
    render(t, e1489) {
        e1489.overrideMaterial = this.depthMaterial;
        const n1051 = t.getClearAlpha();
        t.setClearAlpha(0), this.floor.visible = !1;
        const i741 = t.xr.enabled;
        t.xr.enabled = !1;
        const r551 = t.getRenderTarget();
        t.setRenderTarget(this.renderTarget), t.render(e1489, this.camera), e1489.overrideMaterial = null, this.floor.visible = !0, this.blurShadow(t), t.xr.enabled = i741, t.setRenderTarget(r551), t.setClearAlpha(n1051);
    }
    blurShadow(t) {
        const { camera: e1490 , horizontalBlurMaterial: n1052 , verticalBlurMaterial: i742 , renderTarget: r552 , renderTargetBlur: s375 , blurPlane: a297  } = this;
        a297.visible = !0, a297.material = n1052, n1052.uniforms.h.value = 1 / this.renderTarget.width, n1052.uniforms.tDiffuse.value = this.renderTarget.texture, t.setRenderTarget(s375), t.render(a297, e1490), a297.material = i742, i742.uniforms.v.value = 1 / this.renderTarget.height, i742.uniforms.tDiffuse.value = this.renderTargetBlur.texture, t.setRenderTarget(r552), t.render(a297, e1490), a297.visible = !1;
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Iu = new V, Ou = new V, Nu = new V, Fu = new class {
    constructor(t, e1491, n1053 = 0, i743 = 1 / 0){
        this.ray = new yt(t, e1491), this.near = n1053, this.far = i743, this.camera = null, this.layers = new Lt, this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        };
    }
    set(t, e1492) {
        this.ray.set(t, e1492);
    }
    setFromCamera(t, e1493) {
        e1493.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e1493.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e1493).sub(this.ray.origin).normalize(), this.camera = e1493) : e1493.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e1493.near + e1493.far) / (e1493.near - e1493.far)).unproject(e1493), this.ray.direction.set(0, 0, -1).transformDirection(e1493.matrixWorld), this.camera = e1493) : console.error("THREE.Raycaster: Unsupported camera type: " + e1493.type);
    }
    intersectObject(t, e1494 = !0, n1054 = []) {
        return Jo(t, this, n1054, e1494), n1054.sort(Yo), n1054;
    }
    intersectObjects(t, e1495 = !0, n1055 = []) {
        for(let i744 = 0, r553 = t.length; i744 < r553; i744++)Jo(t[i744], this, n1055, e1495);
        return n1055.sort(Yo), n1055;
    }
}, Uu = new V, ku = new g;
class Bu extends Nr {
    constructor({ canvas: t , element: e1496 , width: n1056 , height: i745  }){
        super(), this.context = null, this.annotationRenderer = new iu, this.schemaElement = document.createElement("script"), this.width = 1, this.height = 1, this.aspect = 1, this.renderCount = 0, this.externalRenderer = null, this.camera = new We(45, 1, .1, 100), this.xrCamera = null, this.url = null, this.target = new Wt, this.modelContainer = new Wt, this.animationNames = [], this.boundingBox = new j, this.boundingSphere = new ct, this.size = new V, this.idealAspect = 0, this.framedFoVDeg = 0, this.shadow = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.bakedShadows = new Set, this.exposure = 1, this.canScale = !0, this.tightBounds = !1, this.isDirty = !1, this.goalTarget = new V, this.targetDamperX = new du, this.targetDamperY = new du, this.targetDamperZ = new du, this._currentGLTF = null, this.cancelPendingSourceChange = null, this.animationsByName = new Map, this.currentAnimationAction = null, this.name = "ModelScene", this.element = e1496, this.canvas = t, this.camera = new We(45, 1, .1, 100), this.camera.name = "MainCamera", this.add(this.target), this.setSize(n1056, i745), this.target.name = "Target", this.modelContainer.name = "ModelContainer", this.target.add(this.modelContainer), this.mixer = new $o(this.modelContainer);
        const { domElement: r554  } = this.annotationRenderer, { style: s376  } = r554;
        s376.display = "none", s376.pointerEvents = "none", s376.position = "absolute", s376.top = "0", this.element.shadowRoot.querySelector(".default").appendChild(r554), this.schemaElement.setAttribute("type", "application/ld+json");
    }
    createContext() {
        this.context = this.canvas.getContext("2d");
    }
    getCamera() {
        return null != this.xrCamera ? this.xrCamera : this.camera;
    }
    queueRender() {
        this.isDirty = !0;
    }
    shouldRender() {
        return this.isDirty;
    }
    hasRendered() {
        this.isDirty = !1;
    }
    async setObject(t) {
        this.reset(), this.modelContainer.add(t), await this.setupScene();
    }
    async setSource(t406, e1497 = ()=>{}) {
        if (!t406 || t406 === this.url) return void e1497(1);
        if (this.reset(), this.url = t406, null != this.externalRenderer) {
            const t = await this.externalRenderer.load(e1497);
            return this.boundingSphere.radius = t.framedRadius, this.idealAspect = t.fieldOfViewAspect, void this.dispatchEvent({
                type: "model-load",
                url: this.url
            });
        }
        let n1057;
        null != this.cancelPendingSourceChange && (this.cancelPendingSourceChange(), this.cancelPendingSourceChange = null);
        try {
            n1057 = await new Promise(async (n1058, i747)=>{
                this.cancelPendingSourceChange = ()=>i747();
                try {
                    n1058(await this.element[Ep].loader.load(t406, this.element, e1497));
                } catch (t) {
                    i747(t);
                }
            });
        } catch (t) {
            if (null == t) return;
            throw t;
        }
        this.reset(), this.url = t406, this._currentGLTF = n1057, null != n1057 && this.modelContainer.add(n1057.scene);
        const { animations: i746  } = n1057, r555 = new Map, s377 = [];
        for (const t405 of i746)r555.set(t405.name, t405), s377.push(t405.name);
        this.animations = i746, this.animationsByName = r555, this.animationNames = s377, await this.setupScene();
    }
    async setupScene() {
        this.updateBoundingBox(), await this.updateFraming(), this.updateShadow(), this.setShadowIntensity(this.shadowIntensity), this.dispatchEvent({
            type: "model-load",
            url: this.url
        });
    }
    reset() {
        this.url = null, this.queueRender(), null != this.shadow && this.shadow.setIntensity(0), this.bakedShadows.clear();
        const t = this._currentGLTF;
        if (null != t) {
            for (const t407 of this.modelContainer.children)this.modelContainer.remove(t407);
            t.dispose(), this._currentGLTF = null;
        }
        null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction = null), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this);
    }
    get currentGLTF() {
        return this._currentGLTF;
    }
    setSize(t, e1498) {
        if (this.width !== t || this.height !== e1498) {
            if (this.width = Math.max(t, 1), this.height = Math.max(e1498, 1), this.annotationRenderer.setSize(t, e1498), this.aspect = this.width / this.height, null != this.externalRenderer) {
                const n1059 = hu();
                this.externalRenderer.resize(t * n1059, e1498 * n1059);
            }
            this.queueRender();
        }
    }
    markBakedShadow(t) {
        t.userData.shadow = !0, this.bakedShadows.add(t);
    }
    unmarkBakedShadow(t) {
        t.userData.shadow = !1, t.visible = !0, this.bakedShadows.delete(t), this.boundingBox.expandByObject(t);
    }
    findBakedShadows(t408) {
        const e1499 = new j;
        t408.traverse((t)=>{
            const n1060 = t;
            if (!n1060.isMesh) return;
            if (!n1060.material.transparent) return;
            e1499.setFromObject(n1060);
            const i748 = e1499.getSize(Uu), r556 = Math.min(i748.x, i748.y, i748.z);
            Math.max(i748.x, i748.y, i748.z) < 100 * r556 || this.markBakedShadow(n1060);
        });
    }
    checkBakedShadows() {
        const { min: t , max: e1500  } = this.boundingBox, n1061 = new j;
        this.boundingBox.getSize(this.size);
        for (const i749 of this.bakedShadows)n1061.setFromObject(i749), n1061.min.y < t.y + this.size.y / 100 && n1061.min.x <= t.x && n1061.max.x >= e1500.x && n1061.min.z <= t.z && n1061.max.z >= e1500.z || n1061.min.z < t.z + this.size.z / 100 && n1061.min.x <= t.x && n1061.max.x >= e1500.x && n1061.min.y <= t.y && n1061.max.y >= e1500.y || this.unmarkBakedShadow(i749);
    }
    updateBoundingBox() {
        if (this.target.remove(this.modelContainer), this.findBakedShadows(this.modelContainer), !0 === this.tightBounds) {
            const t409 = (t, e1501)=>t.expandByPoint(e1501);
            this.setBakedShadowVisibility(!1), this.boundingBox = Au(this.modelContainer, t409, new j), this.boundingBox.isEmpty() && (this.setBakedShadowVisibility(!0), this.bakedShadows.forEach((t)=>this.unmarkBakedShadow(t)), this.boundingBox = Au(this.modelContainer, t409, new j)), this.checkBakedShadows(), this.setBakedShadowVisibility();
        } else this.boundingBox.setFromObject(this.modelContainer);
        this.boundingBox.getSize(this.size), this.target.add(this.modelContainer);
    }
    async updateFraming() {
        this.target.remove(this.modelContainer), this.setBakedShadowVisibility(!1);
        const { center: t  } = this.boundingSphere;
        !0 === this.tightBounds ? (this.element.requestUpdate("cameraTarget"), await this.element.updateComplete, t.copy(this.getTarget())) : this.boundingBox.getCenter(t);
        this.boundingSphere.radius = Math.sqrt(Au(this.modelContainer, (e1502, n1062)=>Math.max(e1502, t.distanceToSquared(n1062)), 0));
        this.idealAspect = Au(this.modelContainer, (e1503, n1063)=>{
            n1063.sub(t);
            const i750 = Math.sqrt(n1063.x * n1063.x + n1063.z * n1063.z);
            return Math.max(e1503, i750 / (this.idealCameraDistance() - Math.abs(n1063.y)));
        }, 0) / Math.tan(this.framedFoVDeg / 2 * Math.PI / 180), this.setBakedShadowVisibility(), this.target.add(this.modelContainer);
    }
    setBakedShadowVisibility(t = this.shadowIntensity <= 0) {
        for (const e1504 of this.bakedShadows)e1504.visible = t;
    }
    idealCameraDistance() {
        const t = this.framedFoVDeg / 2 * Math.PI / 180;
        return this.boundingSphere.radius / Math.sin(t);
    }
    adjustedFoV(t) {
        const e1505 = Math.tan(t / 2 * Math.PI / 180) * Math.max(1, this.idealAspect / this.aspect);
        return 2 * Math.atan(e1505) * 180 / Math.PI;
    }
    getNDC(t, e1506) {
        if (null != this.xrCamera) ku.set(t / window.screen.width, e1506 / window.screen.height);
        else {
            const n1064 = this.element.getBoundingClientRect();
            ku.set((t - n1064.x) / this.width, (e1506 - n1064.y) / this.height);
        }
        return ku.multiplyScalar(2).subScalar(1), ku.y *= -1, ku;
    }
    getSize() {
        return {
            width: this.width,
            height: this.height
        };
    }
    setTarget(t, e1507, n1065) {
        this.goalTarget.set(-t, -e1507, -n1065);
    }
    setTargetDamperDecayTime(t) {
        this.targetDamperX.setDecayTime(t), this.targetDamperY.setDecayTime(t), this.targetDamperZ.setDecayTime(t);
    }
    getTarget() {
        return Uu.copy(this.goalTarget).multiplyScalar(-1);
    }
    jumpToGoal() {
        this.updateTarget(1e4);
    }
    updateTarget(t) {
        const e1508 = this.goalTarget, n1066 = this.target.position;
        if (e1508.equals(n1066)) return !1;
        {
            const i751 = this.boundingSphere.radius / 10;
            let { x: r557 , y: s378 , z: a298  } = n1066;
            return r557 = this.targetDamperX.update(r557, e1508.x, t, i751), s378 = this.targetDamperY.update(s378, e1508.y, t, i751), a298 = this.targetDamperZ.update(a298, e1508.z, t, i751), this.target.position.set(r557, s378, a298), this.target.updateMatrixWorld(), this.queueRender(), !0;
        }
    }
    pointTowards(t, e1509) {
        const { x: n1067 , z: i752  } = this.position;
        this.yaw = Math.atan2(t - n1067, e1509 - i752);
    }
    set yaw(t) {
        this.rotation.y = t, this.queueRender();
    }
    get yaw() {
        return this.rotation.y;
    }
    set animationTime(t) {
        this.mixer.setTime(t), this.queueShadowRender();
    }
    get animationTime() {
        if (null != this.currentAnimationAction) {
            const t = Math.max(this.currentAnimationAction._loopCount, 0);
            return 2202 === this.currentAnimationAction.loop && 1 == (1 & t) ? this.duration - this.currentAnimationAction.time : this.currentAnimationAction.time;
        }
        return 0;
    }
    set animationTimeScale(t) {
        this.mixer.timeScale = t;
    }
    get animationTimeScale() {
        return this.mixer.timeScale;
    }
    get duration() {
        return null != this.currentAnimationAction && this.currentAnimationAction.getClip() ? this.currentAnimationAction.getClip().duration : 0;
    }
    get hasActiveAnimation() {
        return null != this.currentAnimationAction;
    }
    playAnimation(t = null, e1511 = 0, n1068 = 2201, i753 = 1 / 0) {
        if (null == this._currentGLTF) return;
        const { animations: r558  } = this;
        if (null == r558 || 0 === r558.length) return void console.warn("Cannot play animation (model does not have any animations)");
        let s379 = null;
        if (null != t && (s379 = this.animationsByName.get(t), null == s379)) {
            const e1510 = parseInt(t);
            !isNaN(e1510) && e1510 >= 0 && e1510 < r558.length && (s379 = r558[e1510]);
        }
        null == s379 && (s379 = r558[0]);
        try {
            const { currentAnimationAction: t  } = this, r559 = this.mixer.clipAction(s379, this);
            this.currentAnimationAction = r559, this.element.paused ? this.mixer.stopAllAction() : (r559.paused = !1, null != t && r559 !== t ? r559.crossFadeFrom(t, e1511, !1) : this.animationTimeScale > 0 && this.animationTime == this.duration && (this.animationTime = 0)), r559.setLoop(n1068, i753), r559.enabled = !0, r559.clampWhenFinished = !0, r559.play();
        } catch (t411) {
            console.error(t411);
        }
    }
    stopAnimation() {
        this.currentAnimationAction = null, this.mixer.stopAllAction();
    }
    updateAnimation(t) {
        this.mixer.update(t), this.queueShadowRender();
    }
    subscribeMixerEvent(t, e1512) {
        this.mixer.addEventListener(t, e1512);
    }
    updateShadow() {
        const t = this.shadow;
        if (null != t) {
            const e1513 = "wall" === this.element.arPlacement ? "back" : "bottom";
            t.setScene(this, this.shadowSoftness, e1513), t.needsUpdate = !0;
        }
    }
    renderShadow(t) {
        const e1514 = this.shadow;
        null != e1514 && 1 == e1514.needsUpdate && (e1514.render(t, this), e1514.needsUpdate = !1);
    }
    queueShadowRender() {
        null != this.shadow && (this.shadow.needsUpdate = !0);
    }
    setShadowIntensity(t) {
        if (this.shadowIntensity = t, null != this._currentGLTF && (this.setBakedShadowVisibility(), !(t <= 0 && null == this.shadow))) {
            if (null == this.shadow) {
                const t = "wall" === this.element.arPlacement ? "back" : "bottom";
                this.shadow = new Du(this, this.shadowSoftness, t);
            }
            this.shadow.setIntensity(t);
        }
    }
    setShadowSoftness(t) {
        this.shadowSoftness = t;
        const e1515 = this.shadow;
        null != e1515 && e1515.setSoftness(t);
    }
    setShadowOffset(t) {
        const e1516 = this.shadow;
        null != e1516 && e1516.setOffset(t);
    }
    get raycaster() {
        return Fu;
    }
    positionAndNormalFromPoint(t412, e1517 = this) {
        this.raycaster.setFromCamera(t412, this.getCamera());
        const n1069 = this.raycaster.intersectObject(e1517, !0).find((t)=>!t.object.userData.shadow);
        return null == n1069 || null == n1069.face ? null : null == n1069.uv ? {
            position: n1069.point,
            normal: n1069.face.normal,
            uv: null
        } : (n1069.face.normal.applyNormalMatrix((new v).getNormalMatrix(n1069.object.matrixWorld)), {
            position: n1069.point,
            normal: n1069.face.normal,
            uv: n1069.uv
        });
    }
    addHotspot(t) {
        this.target.add(t), this.annotationRenderer.domElement.appendChild(t.element);
    }
    removeHotspot(t) {
        this.target.remove(t);
    }
    forHotspots(t) {
        const { children: e1518  } = this.target;
        for(let n1070 = 0, i754 = e1518.length; n1070 < i754; n1070++){
            const i755 = e1518[n1070];
            i755 instanceof Eu && t(i755);
        }
    }
    updateHotspots(t) {
        this.forHotspots((e1519)=>{
            Iu.copy(t), Ou.setFromMatrixPosition(e1519.matrixWorld), Iu.sub(Ou), Nu.copy(e1519.normal).transformDirection(this.target.matrixWorld), Iu.dot(Nu) < 0 ? e1519.hide() : e1519.show();
        });
    }
    orientHotspots(t) {
        this.forHotspots((e1520)=>{
            e1520.orient(t);
        });
    }
    setHotspotsVisibility(t) {
        this.forHotspots((e1521)=>{
            e1521.visible = t;
        });
    }
    updateSchema(t) {
        var e1522;
        const { schemaElement: n1071 , element: i756  } = this, { alt: r560 , poster: s380 , iosSrc: a299  } = i756;
        if (null != t) {
            const i757 = [
                {
                    "@type": "MediaObject",
                    contentUrl: t,
                    encodingFormat: "gltf" === (null === (e1522 = t.split(".").pop()) || void 0 === e1522 ? void 0 : e1522.toLowerCase()) ? "model/gltf+json" : "model/gltf-binary"
                }
            ];
            a299 && i757.push({
                "@type": "MediaObject",
                contentUrl: a299,
                encodingFormat: "model/vnd.usdz+zip"
            });
            const o223 = {
                "@context": "http://schema.org/",
                "@type": "3DModel",
                image: null != s380 ? s380 : void 0,
                name: null != r560 ? r560 : void 0,
                encoding: i757
            };
            n1071.textContent = JSON.stringify(o223), document.head.appendChild(n1071);
        } else null != n1071.parentElement && n1071.parentElement.removeChild(n1071);
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var zu = function(t, e1523, n1072, i758) {
    for(var r561, s381 = arguments.length, a300 = s381 < 3 ? e1523 : null === i758 ? i758 = Object.getOwnPropertyDescriptor(e1523, n1072) : i758, o224 = t.length - 1; o224 >= 0; o224--)(r561 = t[o224]) && (a300 = (s381 < 3 ? r561(a300) : s381 > 3 ? r561(e1523, n1072, a300) : r561(e1523, n1072)) || a300);
    return s381 > 3 && a300 && Object.defineProperty(e1523, n1072, a300), a300;
};
const Hu = Symbol("currentEnvironmentMap"), Vu = Symbol("applyEnvironmentMap"), Gu = Symbol("updateEnvironment"), Wu = Symbol("cancelEnvironmentUpdate"), ju = Symbol("onPreload");
class qu {
    constructor(t, e1524, n1073, i759, r562){
        this.xrLight = t, this.renderer = e1524, this.lightProbe = n1073, this.xrWebGLBinding = null, this.estimationStartCallback = r562, this.frameCallback = this.onXRFrame.bind(this);
        const s382 = e1524.xr.getSession();
        if (i759 && "XRWebGLBinding" in window) {
            const n1074 = new Xe(16);
            t.environment = n1074.texture;
            const i760 = e1524.getContext();
            switch(s382.preferredReflectionFormat){
                case "srgba8":
                    i760.getExtension("EXT_sRGB");
                    break;
                case "rgba16f":
                    i760.getExtension("OES_texture_half_float");
            }
            this.xrWebGLBinding = new XRWebGLBinding(s382, i760), this.lightProbe.addEventListener("reflectionchange", ()=>{
                this.updateReflection();
            });
        }
        s382.requestAnimationFrame(this.frameCallback);
    }
    updateReflection() {
        const t = this.renderer.properties.get(this.xrLight.environment);
        if (t) {
            const e1525 = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
            e1525 && (t.__webglTexture = e1525, this.xrLight.environment.needsPMREMUpdate = !0);
        }
    }
    onXRFrame(t, e1526) {
        if (!this.xrLight) return;
        e1526.session.requestAnimationFrame(this.frameCallback);
        const n1075 = e1526.getLightEstimate(this.lightProbe);
        if (n1075) {
            this.xrLight.lightProbe.sh.fromArray(n1075.sphericalHarmonicsCoefficients), this.xrLight.lightProbe.intensity = 1;
            const t = Math.max(1, Math.max(n1075.primaryLightIntensity.x, Math.max(n1075.primaryLightIntensity.y, n1075.primaryLightIntensity.z)));
            this.xrLight.directionalLight.color.setRGB(n1075.primaryLightIntensity.x / t, n1075.primaryLightIntensity.y / t, n1075.primaryLightIntensity.z / t), this.xrLight.directionalLight.intensity = t, this.xrLight.directionalLight.position.copy(n1075.primaryLightDirection), this.estimationStartCallback && (this.estimationStartCallback(), this.estimationStartCallback = null);
        }
    }
    dispose() {
        this.xrLight = null, this.renderer = null, this.lightProbe = null, this.xrWebGLBinding = null;
    }
}
class Xu extends Rr {
    constructor(t, e1527 = !0){
        super(), this.lightProbe = new Po, this.lightProbe.intensity = 0, this.add(this.lightProbe), this.directionalLight = new Co, this.directionalLight.intensity = 0, this.add(this.directionalLight), this.environment = null;
        let n1076 = null, i761 = !1;
        t.xr.addEventListener("sessionstart", ()=>{
            const r563 = t.xr.getSession();
            "requestLightProbe" in r563 && r563.requestLightProbe({
                reflectionFormat: r563.preferredReflectionFormat
            }).then((r564)=>{
                n1076 = new qu(this, t, r564, e1527, ()=>{
                    i761 = !0, this.dispatchEvent({
                        type: "estimationstart"
                    });
                });
            });
        }), t.xr.addEventListener("sessionend", ()=>{
            n1076 && (n1076.dispose(), n1076 = null), i761 && this.dispatchEvent({
                type: "estimationend"
            });
        }), this.dispose = ()=>{
            n1076 && (n1076.dispose(), n1076 = null), this.remove(this.lightProbe), this.lightProbe = null, this.remove(this.directionalLight), this.directionalLight = null, this.environment = null;
        };
    }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const $u = Math.PI / 24, Yu = new g, Ju = (t, e1528, n1077)=>{
    let i762 = e1528 > 0 ? n1077 > 0 ? 0 : -Math.PI / 2 : n1077 > 0 ? Math.PI / 2 : Math.PI;
    for(let r565 = 0; r565 <= 12; ++r565)t.push(e1528 + .17 * Math.cos(i762), n1077 + .17 * Math.sin(i762), 0, e1528 + .2 * Math.cos(i762), n1077 + .2 * Math.sin(i762), 0), i762 += $u;
};
class Ku extends Fe {
    constructor(t, e1529){
        const n1078 = new ye, i763 = [], r566 = [], { size: s383 , boundingBox: a301  } = t, o225 = s383.x / 2, l188 = ("back" === e1529 ? s383.y : s383.z) / 2;
        Ju(r566, o225, l188), Ju(r566, -o225, l188), Ju(r566, -o225, -l188), Ju(r566, o225, -l188);
        const h147 = r566.length / 3;
        for(let t413 = 0; t413 < h147 - 2; t413 += 2)i763.push(t413, t413 + 1, t413 + 3, t413, t413 + 3, t413 + 2);
        const c107 = h147 - 2;
        i763.push(c107, c107 + 1, 1, c107, 1, 0), n1078.setAttribute("position", new ce(r566, 3)), n1078.setIndex(i763), super(n1078), this.side = e1529;
        const u94 = this.material;
        switch(u94.side = 0, u94.transparent = !0, u94.opacity = 0, this.goalOpacity = 0, this.opacityDamper = new du, this.hitPlane = new Fe(new rn(2 * (o225 + .2), 2 * (l188 + .2))), this.hitPlane.visible = !1, this.add(this.hitPlane), a301.getCenter(this.position), e1529){
            case "bottom":
                this.rotateX(-Math.PI / 2), this.shadowHeight = a301.min.y, this.position.y = this.shadowHeight;
                break;
            case "back":
                this.shadowHeight = a301.min.z, this.position.z = this.shadowHeight;
        }
        t.target.add(this), this.offsetHeight = 0;
    }
    getHit(t, e1530, n1079) {
        Yu.set(e1530, -n1079), this.hitPlane.visible = !0;
        const i764 = t.positionAndNormalFromPoint(Yu, this.hitPlane);
        return this.hitPlane.visible = !1, null == i764 ? null : i764.position;
    }
    getExpandedHit(t, e1531, n1080) {
        this.hitPlane.scale.set(1e3, 1e3, 1e3);
        const i765 = this.getHit(t, e1531, n1080);
        return this.hitPlane.scale.set(1, 1, 1), i765;
    }
    set offsetHeight(t) {
        t -= .001, "back" === this.side ? this.position.z = this.shadowHeight + t : this.position.y = this.shadowHeight + t;
    }
    get offsetHeight() {
        return "back" === this.side ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
    }
    set show(t) {
        this.goalOpacity = t ? .75 : 0;
    }
    updateOpacity(t) {
        const e1532 = this.material;
        e1532.opacity = this.opacityDamper.update(e1532.opacity, this.goalOpacity, t, 1), this.visible = e1532.opacity > 0;
    }
    dispose() {
        var t;
        const { geometry: e1533 , material: n1081  } = this.hitPlane;
        e1533.dispose(), n1081.dispose(), this.geometry.dispose(), this.material.dispose(), null === (t = this.parent) || void 0 === t || t.remove(this);
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Zu = "not-presenting", Qu = "session-started", td = "object-placed", ed = "failed", nd = "tracking", id = "not-tracking", rd = new V, sd = new xt, ad = new V, od = new We(45, 1, .1, 100);
class ld extends i {
    constructor(t414){
        super(), this.renderer = t414, this.currentSession = null, this.placeOnWall = !1, this.placementBox = null, this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.oldBackground = null, this.oldEnvironment = null, this.frame = null, this.initialHitSource = null, this.transientHitTestSource = null, this.inputSource = null, this._presentedScene = null, this.resolveCleanup = null, this.exitWebXRButtonContainer = null, this.overlay = null, this.xrLight = null, this.tracking = !0, this.frames = 0, this.initialized = !1, this.oldTarget = new V, this.placementComplete = !1, this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.lastDragPosition = new V, this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new V, this.goalYaw = 0, this.goalScale = 1, this.xDamper = new du, this.yDamper = new du, this.zDamper = new du, this.yawDamper = new du, this.scaleDamper = new du, this.onExitWebXRButtonContainerClick = ()=>this.stopPresenting(), this.onUpdateScene = ()=>{
            null != this.placementBox && this.isPresenting && (this.placementBox.dispose(), this.placementBox = new Ku(this.presentedScene, this.placeOnWall ? "back" : "bottom"));
        }, this.onSelectStart = (t)=>{
            const e1534 = this.transientHitTestSource;
            if (null == e1534) return;
            const n1082 = this.frame.getHitTestResultsForTransientInput(e1534), i766 = this.presentedScene, r567 = this.placementBox;
            if (1 === n1082.length) {
                this.inputSource = t.inputSource;
                const { axes: e1535  } = this.inputSource.gamepad, n1083 = r567.getHit(this.presentedScene, e1535[0], e1535[1]);
                r567.show = !0, null != n1083 ? (this.isTranslating = !0, this.lastDragPosition.copy(n1083)) : !1 === this.placeOnWall && (this.isRotating = !0, this.lastAngle = 1.5 * e1535[0]);
            } else if (2 === n1082.length) {
                r567.show = !0, this.isTwoFingering = !0;
                const { separation: t  } = this.fingerPolar(n1082);
                this.firstRatio = t / i766.scale.x;
            }
        }, this.onSelectEnd = ()=>{
            this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = !1;
        }, this.threeRenderer = t414.threeRenderer, this.threeRenderer.xr.enabled = !0;
    }
    async resolveARSession() {
        su();
        const t = await navigator.xr.requestSession("immersive-ar", {
            requiredFeatures: [
                "hit-test"
            ],
            optionalFeatures: [
                "dom-overlay",
                "light-estimation"
            ],
            domOverlay: {
                root: this.overlay
            }
        });
        return this.threeRenderer.xr.setReferenceSpaceType("local"), await this.threeRenderer.xr.setSession(t), this.threeRenderer.xr.cameraAutoUpdate = !1, t;
    }
    get presentedScene() {
        return this._presentedScene;
    }
    async supportsPresentation() {
        try {
            return su(), await navigator.xr.isSessionSupported("immersive-ar");
        } catch (t) {
            return console.warn("Request to present in WebXR denied:"), console.warn(t), console.warn("Falling back to next ar-mode"), !1;
        }
    }
    async present(t415, e1536 = !1) {
        this.isPresenting && console.warn("Cannot present while a model is already presenting");
        let n1084 = new Promise((t, e)=>{
            requestAnimationFrame(()=>t());
        });
        t415.setHotspotsVisibility(!1), t415.queueRender(), await n1084, this._presentedScene = t415, this.overlay = t415.element.shadowRoot.querySelector("div.default"), !0 === e1536 && (this.xrLight = new Xu(this.threeRenderer), this.xrLight.addEventListener("estimationstart", ()=>{
            if (!this.isPresenting || null == this.xrLight) return;
            const t = this.presentedScene;
            t.add(this.xrLight), this.oldEnvironment = t.environment, t.environment = this.xrLight.environment;
        }));
        const i767 = await this.resolveARSession();
        i767.addEventListener("end", ()=>{
            this.postSessionCleanup();
        }, {
            once: !0
        });
        const r568 = t415.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");
        r568.classList.add("enabled"), r568.addEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = r568;
        const s384 = await i767.requestReferenceSpace("viewer");
        this.tracking = !0, this.frames = 0, this.initialized = !1, this.turntableRotation = t415.yaw, this.goalYaw = t415.yaw, this.goalScale = 1, this.oldBackground = t415.background, t415.background = null, this.oldShadowIntensity = t415.shadowIntensity, t415.setShadowIntensity(.01), this.oldTarget.copy(t415.getTarget()), t415.addEventListener("model-load", this.onUpdateScene);
        const a302 = 20 * Math.PI / 180, o226 = !0 === this.placeOnWall ? void 0 : new XRRay(new DOMPoint(0, 0, 0), {
            x: 0,
            y: -Math.sin(a302),
            z: -Math.cos(a302)
        });
        i767.requestHitTestSource({
            space: s384,
            offsetRay: o226
        }).then((t)=>{
            this.initialHitSource = t;
        }), this.currentSession = i767, this.placementBox = new Ku(t415, this.placeOnWall ? "back" : "bottom"), this.placementComplete = !1, this.lastTick = performance.now(), this.dispatchEvent({
            type: "status",
            status: Qu
        });
    }
    async stopPresenting() {
        if (!this.isPresenting) return;
        const t416 = new Promise((t)=>{
            this.resolveCleanup = t;
        });
        try {
            await this.currentSession.end(), await t416;
        } catch (t) {
            console.warn("Error while trying to end WebXR AR session"), console.warn(t), this.postSessionCleanup();
        }
    }
    get isPresenting() {
        return null != this.presentedScene;
    }
    get target() {
        return this.oldTarget;
    }
    updateTarget() {
        const t = this.presentedScene;
        if (null != t) {
            const e1537 = t.getTarget();
            this.oldTarget.copy(e1537), this.placeOnWall ? e1537.z = t.boundingBox.min.z : e1537.y = t.boundingBox.min.y, t.setTarget(e1537.x, e1537.y, e1537.z);
        }
    }
    postSessionCleanup() {
        const t = this.currentSession;
        null != t && (t.removeEventListener("selectstart", this.onSelectStart), t.removeEventListener("selectend", this.onSelectEnd), this.currentSession = null);
        const e1538 = this.presentedScene;
        if (null != e1538) {
            const { element: t  } = e1538;
            null != this.xrLight && (e1538.remove(this.xrLight), null != this.oldEnvironment && (e1538.environment = this.oldEnvironment, this.oldEnvironment = null), this.xrLight.dispose(), this.xrLight = null), e1538.position.set(0, 0, 0), e1538.scale.set(1, 1, 1), e1538.setShadowOffset(0);
            const n1085 = this.turntableRotation;
            null != n1085 && (e1538.yaw = n1085);
            const i768 = this.oldShadowIntensity;
            null != i768 && e1538.setShadowIntensity(i768);
            const r569 = this.oldBackground;
            null != r569 && (e1538.background = r569);
            const s385 = this.oldTarget;
            e1538.setTarget(s385.x, s385.y, s385.z), e1538.xrCamera = null, e1538.removeEventListener("model-load", this.onUpdateScene), e1538.orientHotspots(0), t.requestUpdate("cameraTarget"), t.requestUpdate("maxCameraOrbit"), t[Tp](t.getBoundingClientRect());
        }
        this.renderer.height = 0;
        const n1086 = this.exitWebXRButtonContainer;
        null != n1086 && (n1086.classList.remove("enabled"), n1086.removeEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = null);
        const i769 = this.transientHitTestSource;
        null != i769 && (i769.cancel(), this.transientHitTestSource = null);
        const r570 = this.initialHitSource;
        null != r570 && (r570.cancel(), this.initialHitSource = null), null != this.placementBox && (this.placementBox.dispose(), this.placementBox = null), this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.oldBackground = null, this._presentedScene = null, this.frame = null, this.inputSource = null, this.overlay = null, null != this.resolveCleanup && this.resolveCleanup(), this.dispatchEvent({
            type: "status",
            status: Zu
        });
    }
    updateView(t) {
        const e1539 = this.presentedScene, n1087 = this.threeRenderer.xr;
        n1087.updateCamera(od), e1539.xrCamera = n1087.getCamera();
        const { elements: i770  } = e1539.getCamera().matrixWorld;
        if (e1539.orientHotspots(Math.atan2(i770[1], i770[5])), this.initialized || (this.placeInitially(), this.initialized = !0), t.requestViewportScale && t.recommendedViewportScale) {
            const e1540 = t.recommendedViewportScale;
            t.requestViewportScale(Math.max(e1540, .25));
        }
        const r571 = this.currentSession.renderState.baseLayer.getViewport(t);
        this.threeRenderer.setViewport(r571.x, r571.y, r571.width, r571.height);
    }
    placeInitially() {
        const t417 = this.presentedScene, { position: e1541 , element: n1088  } = t417, i771 = t417.getCamera(), { width: r572 , height: s386  } = this.overlay.getBoundingClientRect();
        t417.setSize(r572, s386), i771.projectionMatrixInverse.copy(i771.projectionMatrix).invert();
        const { theta: a303 , radius: o227  } = n1088.getCameraOrbit(), l189 = i771.getWorldDirection(rd);
        t417.yaw = Math.atan2(-l189.x, -l189.z) - a303, this.goalYaw = t417.yaw, e1541.copy(i771.position).add(l189.multiplyScalar(o227)), this.updateTarget();
        const h148 = t417.getTarget();
        e1541.add(h148).sub(this.oldTarget), this.goalPosition.copy(e1541), t417.setHotspotsVisibility(!0);
        const { session: c108  } = this.frame;
        c108.addEventListener("selectstart", this.onSelectStart), c108.addEventListener("selectend", this.onSelectEnd), c108.requestHitTestSourceForTransientInput({
            profile: "generic-touchscreen"
        }).then((t)=>{
            this.transientHitTestSource = t;
        });
    }
    getTouchLocation() {
        const { axes: t  } = this.inputSource.gamepad;
        let e1542 = this.placementBox.getExpandedHit(this.presentedScene, t[0], t[1]);
        return null != e1542 && (rd.copy(e1542).sub(this.presentedScene.getCamera().position), rd.length() > 10) ? null : e1542;
    }
    getHitPoint(t) {
        const e1543 = this.threeRenderer.xr.getReferenceSpace(), n1089 = t.getPose(e1543);
        if (null == n1089) return null;
        const i772 = sd.fromArray(n1089.transform.matrix);
        return !0 === this.placeOnWall && (this.goalYaw = Math.atan2(i772.elements[4], i772.elements[6])), i772.elements[5] > .75 !== this.placeOnWall ? ad.setFromMatrixPosition(i772) : null;
    }
    moveToFloor(t) {
        const e1544 = this.initialHitSource;
        if (null == e1544) return;
        const n1090 = t.getHitTestResults(e1544);
        if (0 == n1090.length) return;
        const i773 = n1090[0], r573 = this.getHitPoint(i773);
        null != r573 && (this.placementBox.show = !0, this.isTranslating || (this.placeOnWall ? this.goalPosition.copy(r573) : this.goalPosition.y = r573.y), e1544.cancel(), this.initialHitSource = null, this.dispatchEvent({
            type: "status",
            status: td
        }));
    }
    fingerPolar(t) {
        const e1545 = t[0].inputSource.gamepad.axes, n1091 = t[1].inputSource.gamepad.axes, i774 = n1091[0] - e1545[0], r574 = n1091[1] - e1545[1], s387 = Math.atan2(r574, i774);
        let a304 = this.lastAngle - s387;
        return a304 > Math.PI ? a304 -= 2 * Math.PI : a304 < -Math.PI && (a304 += 2 * Math.PI), this.lastAngle = s387, {
            separation: Math.sqrt(i774 * i774 + r574 * r574),
            deltaYaw: a304
        };
    }
    processInput(t418) {
        const e1546 = this.transientHitTestSource;
        if (null == e1546) return;
        if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) return;
        const n1092 = t418.getHitTestResultsForTransientInput(e1546), i775 = this.presentedScene, r575 = i775.scale.x;
        if (this.isTwoFingering) {
            if (n1092.length < 2) this.isTwoFingering = !1;
            else {
                const { separation: t , deltaYaw: e1547  } = this.fingerPolar(n1092);
                if (!1 === this.placeOnWall && (this.goalYaw += e1547), i775.canScale) {
                    const e1548 = t / this.firstRatio;
                    this.goalScale = e1548 < 1.3 && e1548 > .7692307692307692 ? 1 : e1548;
                }
            }
        } else if (2 !== n1092.length) {
            if (this.isRotating) {
                const t = 1.5 * this.inputSource.gamepad.axes[0];
                this.goalYaw += t - this.lastAngle, this.lastAngle = t;
            } else this.isTranslating && n1092.forEach((t)=>{
                if (t.inputSource !== this.inputSource) return;
                let e1549 = null;
                if (t.results.length > 0 && (e1549 = this.getHitPoint(t.results[0])), null == e1549 && (e1549 = this.getTouchLocation()), null != e1549) {
                    if (this.goalPosition.sub(this.lastDragPosition), !1 === this.placeOnWall) {
                        const t = e1549.y - this.lastDragPosition.y;
                        if (t < 0) {
                            this.placementBox.offsetHeight = t / r575, this.presentedScene.setShadowOffset(t);
                            const n1093 = rd.copy(i775.getCamera().position), s388 = -t / (n1093.y - e1549.y);
                            n1093.multiplyScalar(s388), e1549.multiplyScalar(1 - s388).add(n1093);
                        }
                    }
                    this.goalPosition.add(e1549), this.lastDragPosition.copy(e1549);
                }
            });
        } else {
            this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !0;
            const { separation: t  } = this.fingerPolar(n1092);
            this.firstRatio = t / r575;
        }
    }
    moveScene(t) {
        const e1550 = this.presentedScene, { position: n1094 , yaw: i777  } = e1550, r576 = e1550.boundingSphere.radius, s389 = this.goalPosition, a305 = e1550.scale.x, o228 = this.placementBox;
        if (!s389.equals(n1094) || this.goalScale !== a305) {
            let { x: i776 , y: l190 , z: h149  } = n1094;
            i776 = this.xDamper.update(i776, s389.x, t, r576), l190 = this.yDamper.update(l190, s389.y, t, r576), h149 = this.zDamper.update(h149, s389.z, t, r576), n1094.set(i776, l190, h149);
            const c109 = this.scaleDamper.update(a305, this.goalScale, t, 1);
            if (e1550.scale.set(c109, c109, c109), !this.isTranslating) {
                const t = s389.y - l190;
                this.placementComplete && !1 === this.placeOnWall ? (o228.offsetHeight = t / c109, e1550.setShadowOffset(t)) : 0 === t && (this.placementComplete = !0, o228.show = !1, e1550.setShadowIntensity(.8));
            }
        }
        o228.updateOpacity(t), e1550.updateTarget(t), e1550.yaw = this.yawDamper.update(i777, this.goalYaw, t, Math.PI);
    }
    onWebXRFrame(t, e1551) {
        this.frame = e1551, ++this.frames;
        const n1096 = this.threeRenderer.xr.getReferenceSpace(), i778 = e1551.getViewerPose(n1096);
        null == i778 && !0 === this.tracking && this.frames > 30 && (this.tracking = !1, this.dispatchEvent({
            type: "tracking",
            status: id
        }));
        const r577 = this.presentedScene;
        if (null == i778 || null == r577 || !r577.element[Pp]()) return void this.threeRenderer.clear();
        !1 === this.tracking && (this.tracking = !0, this.dispatchEvent({
            type: "tracking",
            status: nd
        }));
        let s390 = !0;
        for (const n1095 of i778.views){
            if (this.updateView(n1095), s390) {
                this.moveToFloor(e1551), this.processInput(e1551);
                const n1097 = t - this.lastTick;
                this.moveScene(n1097), this.renderer.preRender(r577, t, n1097), this.lastTick = t, r577.renderShadow(this.threeRenderer);
            }
            this.threeRenderer.render(r577, r577.getCamera()), s390 = !1;
        }
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class hd {
    constructor(t){
        t.threeRenderer.debug = {
            checkShaderErrors: !0
        }, Promise.resolve().then(()=>{
            self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug", {
                detail: {
                    renderer: t,
                    THREE: {
                        ShaderMaterial: Ve,
                        Texture: F,
                        Mesh: Fe,
                        Scene: Nr,
                        PlaneBufferGeometry: rn,
                        OrthographicCamera: mn,
                        WebGLRenderTarget: k
                    }
                }
            }));
        });
    }
    addScene(t) {
        self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug", {
            detail: {
                scene: t
            }
        }));
    }
    removeScene(t) {
        self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug", {
            detail: {
                scene: t
            }
        }));
    }
}
function cd(t419) {
    const e1552 = new Map, n1098 = new Map, i779 = t419.clone();
    return ud(t419, i779, function(t, i780) {
        e1552.set(i780, t), n1098.set(t, i780);
    }), i779.traverse(function(t420) {
        if (!t420.isSkinnedMesh) return;
        const i781 = t420, r578 = e1552.get(t420), s391 = r578.skeleton.bones;
        i781.skeleton = r578.skeleton.clone(), i781.bindMatrix.copy(r578.bindMatrix), i781.skeleton.bones = s391.map(function(t) {
            return n1098.get(t);
        }), i781.bind(i781.skeleton, i781.bindMatrix);
    }), i779;
}
function ud(t, e1553, n1099) {
    n1099(t, e1553);
    for(let i782 = 0; i782 < t.children.length; i782++)ud(t.children[i782], e1553.children[i782], n1099);
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const dd = Symbol("prepared"), pd = Symbol("prepare"), md = Symbol("preparedGLTF"), fd = Symbol("clone");
class gd {
    constructor(t){
        this[md] = t;
    }
    static prepare(t) {
        if (null == t.scene) throw new Error("Model does not have a scene");
        if (t[dd]) return t;
        const e1554 = this[pd](t);
        return e1554[dd] = !0, e1554;
    }
    static [pd](t) {
        const { scene: e1555  } = t, n1100 = [
            e1555
        ];
        return Object.assign(Object.assign({}, t), {
            scene: e1555,
            scenes: n1100
        });
    }
    get parser() {
        return this[md].parser;
    }
    get animations() {
        return this[md].animations;
    }
    get scene() {
        return this[md].scene;
    }
    get scenes() {
        return this[md].scenes;
    }
    get cameras() {
        return this[md].cameras;
    }
    get asset() {
        return this[md].asset;
    }
    get userData() {
        return this[md].userData;
    }
    clone() {
        return new this.constructor(this[fd]());
    }
    dispose() {
        this.scenes.forEach((t421)=>{
            t421.traverse((t422)=>{
                if (!t422.isMesh) return;
                const e1556 = t422;
                (Array.isArray(e1556.material) ? e1556.material : [
                    e1556.material
                ]).forEach((t)=>{
                    for(const e1557 in t){
                        const n1101 = t[e1557];
                        if (n1101 instanceof F) {
                            const t = n1101.source.data;
                            t instanceof ImageBitmap && t.close(), n1101.dispose();
                        }
                    }
                    t.dispose();
                }), e1556.geometry.dispose();
            });
        });
    }
    [fd]() {
        const t = this[md], e1558 = cd(this.scene);
        vd(e1558, this.scene);
        const n1102 = [
            e1558
        ], i783 = t.userData ? Object.assign({}, t.userData) : {};
        return Object.assign(Object.assign({}, t), {
            scene: e1558,
            scenes: n1102,
            userData: i783
        });
    }
}
const vd = (t423, e1559)=>{
    yd(t423, e1559, (t, e1560)=>{
        void 0 !== e1560.userData.variantMaterials && (t.userData.variantMaterials = new Map(e1560.userData.variantMaterials)), void 0 !== e1560.userData.variantData && (t.userData.variantData = e1560.userData.variantData), void 0 !== e1560.userData.originalMaterial && (t.userData.originalMaterial = e1560.userData.originalMaterial);
    });
}, yd = (t, e1561, n1103)=>{
    n1103(t, e1561);
    for(let i784 = 0; i784 < t.children.length; i784++)yd(t.children[i784], e1561.children[i784], n1103);
}, xd = Symbol("threeGLTF"), bd = Symbol("gltf"), _d = Symbol("gltfElementMap"), wd = Symbol("threeObjectMap"), Md = Symbol("parallelTraverseThreeScene"), Sd = Symbol("correlateOriginalThreeGLTF"), Td = Symbol("correlateCloneThreeGLTF");
class Ed {
    constructor(t, e1562, n1104, i785){
        this[xd] = t, this[bd] = e1562, this[_d] = i785, this[wd] = n1104;
    }
    static from(t, e1563) {
        return null != e1563 ? this[Td](t, e1563) : this[Sd](t);
    }
    static [Sd](t) {
        const e1564 = t.parser.json, n1105 = t.parser.associations, i786 = new Map, r580 = {
            name: "Default"
        }, s392 = {
            type: "materials",
            index: -1
        };
        for (const t424 of n1105.keys())t424 instanceof ie && null == n1105.get(t424) && (s392.index < 0 && (null == e1564.materials && (e1564.materials = []), s392.index = e1564.materials.length, e1564.materials.push(r580)), t424.name = r580.name, n1105.set(t424, {
            materials: s392.index
        }));
        for (const [t425, r579] of n1105){
            if (r579) {
                const e1565 = t425;
                e1565.userData = e1565.userData || {}, e1565.userData.associations = r579;
            }
            for(const n1106 in r579)if (null != n1106 && "primitives" !== n1106) {
                const s393 = n1106, a306 = (e1564[s393] || [])[r579[s393]];
                if (null == a306) continue;
                let o229 = i786.get(a306);
                null == o229 && (o229 = new Set, i786.set(a306, o229)), o229.add(t425);
            }
        }
        return new Ed(t, e1564, n1105, i786);
    }
    static [Td](t426, e1566) {
        const n1107 = e1566.threeGLTF, i788 = e1566.gltf, r581 = JSON.parse(JSON.stringify(i788)), s394 = new Map, a307 = new Map;
        for(let i787 = 0; i787 < n1107.scenes.length; i787++)this[Md](n1107.scenes[i787], t426.scenes[i787], (t, n1108)=>{
            const i789 = e1566.threeObjectMap.get(t);
            if (null != i789) {
                for(const t in i789)if (null != t && "primitives" !== t) {
                    const e1567 = t, o230 = i789[e1567], l191 = r581[e1567][o230], h150 = s394.get(n1108) || {};
                    h150[e1567] = o230, s394.set(n1108, h150);
                    const c110 = a307.get(l191) || new Set;
                    c110.add(n1108), a307.set(l191, c110);
                }
            }
        });
        return new Ed(t426, r581, s394, a307);
    }
    static [Md](t427, e1568, n1109) {
        const i790 = (t, e1569)=>{
            if (n1109(t, e1569), t.isObject3D) {
                if (t.isMesh) {
                    if (Array.isArray(t.material)) for(let n1110 = 0; n1110 < t.material.length; ++n1110)i790(t.material[n1110], e1569.material[n1110]);
                    else i790(t.material, e1569.material);
                }
                for(let n1111 = 0; n1111 < t.children.length; ++n1111)i790(t.children[n1111], e1569.children[n1111]);
            }
        };
        i790(t427, e1568);
    }
    get threeGLTF() {
        return this[xd];
    }
    get gltf() {
        return this[bd];
    }
    get gltfElementMap() {
        return this[_d];
    }
    get threeObjectMap() {
        return this[wd];
    }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Ad = Symbol("correlatedSceneGraph");
class Rd extends gd {
    static [pd](t428) {
        const e1570 = super[pd](t428);
        null == e1570[Ad] && (e1570[Ad] = Ed.from(e1570));
        const { scene: n1112  } = e1570, i791 = new ct(void 0, 1 / 0);
        return n1112.traverse((t)=>{
            t.renderOrder = 1e3, t.frustumCulled = !1, t.name || (t.name = t.uuid);
            const n1113 = t;
            if (n1113.isMesh) {
                const { geometry: t  } = n1113;
                n1113.castShadow = !0, n1113.isSkinnedMesh && (t.boundingSphere = i791, t.boundingBox = null);
                const r582 = n1113.material;
                if (!0 === r582.isMeshBasicMaterial && (r582.toneMapped = !1), r582.shadowSide = 0, r582.aoMap) {
                    const { gltf: n1114 , threeObjectMap: i792  } = e1570[Ad], s395 = i792.get(r582);
                    if (null != n1114.materials && null != s395 && null != s395.materials) {
                        const e1571 = n1114.materials[s395.materials];
                        e1571.occlusionTexture && 0 === e1571.occlusionTexture.texCoord && null != t.attributes.uv && t.setAttribute("uv2", t.attributes.uv);
                    }
                }
            }
        }), e1570;
    }
    get correlatedSceneGraph() {
        return this[md][Ad];
    }
    [fd]() {
        const t429 = super[fd](), e1572 = new Map;
        return t429.scene.traverse((t)=>{
            if (t.isMesh) {
                const n1115 = t, i793 = n1115.material;
                if (null != i793) {
                    if (e1572.has(i793.uuid)) return void (n1115.material = e1572.get(i793.uuid));
                    n1115.material = i793.clone(), e1572.set(i793.uuid, n1115.material);
                }
            }
        }), t429[Ad] = Ed.from(t429, this.correlatedSceneGraph), t429;
    }
}
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Cd extends Nr {
    constructor(){
        super(), this.position.y = -3.5;
        const t = new ke;
        t.deleteAttribute("uv");
        const e1573 = new Fa({
            metalness: 0,
            side: 1
        }), n1116 = new Fa({
            metalness: 0
        }), i794 = new Ao(16777215, 500, 28, 2);
        i794.position.set(.418, 16.199, .3), this.add(i794);
        const r583 = new Fe(t, e1573);
        r583.position.set(-0.757, 13.219, .717), r583.scale.set(31.713, 28.305, 28.591), this.add(r583);
        const s396 = new Fe(t, n1116);
        s396.position.set(-10.906, 2.009, 1.846), s396.rotation.set(0, -0.195, 0), s396.scale.set(2.328, 7.905, 4.651), this.add(s396);
        const a308 = new Fe(t, n1116);
        a308.position.set(-5.607, -0.754, -0.758), a308.rotation.set(0, .994, 0), a308.scale.set(1.97, 1.534, 3.955), this.add(a308);
        const o231 = new Fe(t, n1116);
        o231.position.set(6.167, .857, 7.803), o231.rotation.set(0, .561, 0), o231.scale.set(3.927, 6.285, 3.687), this.add(o231);
        const l192 = new Fe(t, n1116);
        l192.position.set(-2.017, .018, 6.124), l192.rotation.set(0, .333, 0), l192.scale.set(2.002, 4.566, 2.064), this.add(l192);
        const h151 = new Fe(t, n1116);
        h151.position.set(2.291, -0.756, -2.621), h151.rotation.set(0, -0.286, 0), h151.scale.set(1.546, 1.552, 1.496), this.add(h151);
        const c111 = new Fe(t, n1116);
        c111.position.set(-2.193, -0.369, -5.547), c111.rotation.set(0, .516, 0), c111.scale.set(3.875, 3.487, 2.986), this.add(c111);
        const u95 = new Fe(t, this.createAreaLightMaterial(50));
        u95.position.set(-16.116, 14.37, 8.208), u95.scale.set(.1, 2.428, 2.739), this.add(u95);
        const d76 = new Fe(t, this.createAreaLightMaterial(50));
        d76.position.set(-16.109, 18.021, -8.207), d76.scale.set(.1, 2.425, 2.751), this.add(d76);
        const p67 = new Fe(t, this.createAreaLightMaterial(17));
        p67.position.set(14.904, 12.198, -1.832), p67.scale.set(.15, 4.265, 6.331), this.add(p67);
        const m48 = new Fe(t, this.createAreaLightMaterial(43));
        m48.position.set(-0.462, 8.89, 14.52), m48.scale.set(4.38, 5.441, .088), this.add(m48);
        const f41 = new Fe(t, this.createAreaLightMaterial(20));
        f41.position.set(3.235, 11.486, -12.541), f41.scale.set(2.5, 2, .1), this.add(f41);
        const g33 = new Fe(t, this.createAreaLightMaterial(100));
        g33.position.set(0, 20, 0), g33.scale.set(1, .1, 1), this.add(g33);
    }
    createAreaLightMaterial(t) {
        const e1574 = new re;
        return e1574.color.setScalar(t), e1574;
    }
}
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ld extends Nr {
    constructor(){
        super(), this.position.y = -3.5;
        const t = new ke;
        t.deleteAttribute("uv");
        const e1575 = new Fa({
            metalness: 0,
            side: 1
        }), n1117 = new Fa({
            metalness: 0
        }), i795 = new Ao(16777215, 400, 28, 2);
        i795.position.set(.5, 14, .5), this.add(i795);
        const r584 = new Fe(t, e1575);
        r584.position.set(0, 13.2, 0), r584.scale.set(31.5, 28.5, 31.5), this.add(r584);
        const s397 = new Fe(t, n1117);
        s397.position.set(-10.906, -1, 1.846), s397.rotation.set(0, -0.195, 0), s397.scale.set(2.328, 7.905, 4.651), this.add(s397);
        const a309 = new Fe(t, n1117);
        a309.position.set(-5.607, -0.754, -0.758), a309.rotation.set(0, .994, 0), a309.scale.set(1.97, 1.534, 3.955), this.add(a309);
        const o232 = new Fe(t, n1117);
        o232.position.set(6.167, -0.16, 7.803), o232.rotation.set(0, .561, 0), o232.scale.set(3.927, 6.285, 3.687), this.add(o232);
        const l193 = new Fe(t, n1117);
        l193.position.set(-2.017, .018, 6.124), l193.rotation.set(0, .333, 0), l193.scale.set(2.002, 4.566, 2.064), this.add(l193);
        const h152 = new Fe(t, n1117);
        h152.position.set(2.291, -0.756, -2.621), h152.rotation.set(0, -0.286, 0), h152.scale.set(1.546, 1.552, 1.496), this.add(h152);
        const c112 = new Fe(t, n1117);
        c112.position.set(-2.193, -0.369, -5.547), c112.rotation.set(0, .516, 0), c112.scale.set(3.875, 3.487, 2.986), this.add(c112);
        const u96 = new Fe(t, this.createAreaLightMaterial(80));
        u96.position.set(-14, 10, 8), u96.scale.set(.1, 2.5, 2.5), this.add(u96);
        const d77 = new Fe(t, this.createAreaLightMaterial(80));
        d77.position.set(-14, 14, -4), d77.scale.set(.1, 2.5, 2.5), this.add(d77);
        const p68 = new Fe(t, this.createAreaLightMaterial(23));
        p68.position.set(14, 12, 0), p68.scale.set(.1, 5, 5), this.add(p68);
        const m49 = new Fe(t, this.createAreaLightMaterial(16));
        m49.position.set(0, 9, 14), m49.scale.set(5, 5, .1), this.add(m49);
        const f42 = new Fe(t, this.createAreaLightMaterial(80));
        f42.position.set(7, 8, -14), f42.scale.set(2.5, 2.5, .1), this.add(f42);
        const g34 = new Fe(t, this.createAreaLightMaterial(80));
        g34.position.set(-7, 16, -14), g34.scale.set(2.5, 2.5, .1), this.add(g34);
        const v32 = new Fe(t, this.createAreaLightMaterial(1));
        v32.position.set(0, 20, 0), v32.scale.set(.1, .1, .1), this.add(v32);
    }
    createAreaLightMaterial(t) {
        const e1576 = new re;
        return e1576.color.setScalar(t), e1576;
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Pd = /\.hdr(\.js)?$/, Dd = new fo, Id = new class extends mo {
    constructor(t){
        super(t), this.type = 1016;
    }
    parse(t430) {
        const e1577 = function(t, e1578) {
            switch(t){
                case 1:
                    console.error("THREE.RGBELoader Read Error: " + (e1578 || ""));
                    break;
                case 2:
                    console.error("THREE.RGBELoader Write Error: " + (e1578 || ""));
                    break;
                case 3:
                    console.error("THREE.RGBELoader Bad File Format: " + (e1578 || ""));
                    break;
                default:
                    console.error("THREE.RGBELoader: Error: " + (e1578 || ""));
            }
            return -1;
        }, n1118 = function(t, e1579, n1119) {
            e1579 = e1579 || 1024;
            let i797 = t.pos, r586 = -1, s399 = 0, a311 = "", o233 = String.fromCharCode.apply(null, new Uint16Array(t.subarray(i797, i797 + 128)));
            for(; 0 > (r586 = o233.indexOf("\n")) && s399 < e1579 && i797 < t.byteLength;)a311 += o233, s399 += o233.length, i797 += 128, o233 += String.fromCharCode.apply(null, new Uint16Array(t.subarray(i797, i797 + 128)));
            return -1 < r586 && (!1 !== n1119 && (t.pos += s399 + r586 + 1), a311 + o233.slice(0, r586));
        }, i796 = function(t, e1580, n1120, i798) {
            const r587 = t[e1580 + 3], s400 = Math.pow(2, r587 - 128) / 255;
            n1120[i798 + 0] = t[e1580 + 0] * s400, n1120[i798 + 1] = t[e1580 + 1] * s400, n1120[i798 + 2] = t[e1580 + 2] * s400, n1120[i798 + 3] = 1;
        }, r585 = function(t, e1581, n1121, i799) {
            const r588 = t[e1581 + 3], s401 = Math.pow(2, r588 - 128) / 255;
            n1121[i799 + 0] = nl.toHalfFloat(Math.min(t[e1581 + 0] * s401, 65504)), n1121[i799 + 1] = nl.toHalfFloat(Math.min(t[e1581 + 1] * s401, 65504)), n1121[i799 + 2] = nl.toHalfFloat(Math.min(t[e1581 + 2] * s401, 65504)), n1121[i799 + 3] = nl.toHalfFloat(1);
        }, s398 = new Uint8Array(t430);
        s398.pos = 0;
        const a310 = function(t) {
            const i800 = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, r589 = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, s402 = /^\s*FORMAT=(\S+)\s*$/, a312 = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, o234 = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let l194, h153;
            if (t.pos >= t.byteLength || !(l194 = n1118(t))) return e1577(1, "no header found");
            if (!(h153 = l194.match(/^#\?(\S+)/))) return e1577(3, "bad initial token");
            for(o234.valid |= 1, o234.programtype = h153[1], o234.string += l194 + "\n"; l194 = n1118(t), !1 !== l194;)if (o234.string += l194 + "\n", "#" !== l194.charAt(0)) {
                if ((h153 = l194.match(i800)) && (o234.gamma = parseFloat(h153[1])), (h153 = l194.match(r589)) && (o234.exposure = parseFloat(h153[1])), (h153 = l194.match(s402)) && (o234.valid |= 2, o234.format = h153[1]), (h153 = l194.match(a312)) && (o234.valid |= 4, o234.height = parseInt(h153[1], 10), o234.width = parseInt(h153[2], 10)), 2 & o234.valid && 4 & o234.valid) break;
            } else o234.comments += l194 + "\n";
            return 2 & o234.valid ? 4 & o234.valid ? o234 : e1577(3, "missing image size specifier") : e1577(3, "missing format specifier");
        }(s398);
        if (-1 !== a310) {
            const t431 = a310.width, n1122 = a310.height, o235 = function(t, n1124, i801) {
                const r590 = n1124;
                if (r590 < 8 || r590 > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2]) return new Uint8Array(t);
                if (r590 !== (t[2] << 8 | t[3])) return e1577(3, "wrong scanline width");
                const s403 = new Uint8Array(4 * n1124 * i801);
                if (!s403.length) return e1577(4, "unable to allocate buffer space");
                let a313 = 0, o237 = 0;
                const l195 = 4 * r590, h154 = new Uint8Array(4), c113 = new Uint8Array(l195);
                let u97 = i801;
                for(; u97 > 0 && o237 < t.byteLength;){
                    if (o237 + 4 > t.byteLength) return e1577(1);
                    if (h154[0] = t[o237++], h154[1] = t[o237++], h154[2] = t[o237++], h154[3] = t[o237++], 2 != h154[0] || 2 != h154[1] || (h154[2] << 8 | h154[3]) != r590) return e1577(3, "bad rgbe scanline format");
                    let n1125, i802 = 0;
                    for(; i802 < l195 && o237 < t.byteLength;){
                        n1125 = t[o237++];
                        const r591 = n1125 > 128;
                        if (r591 && (n1125 -= 128), 0 === n1125 || i802 + n1125 > l195) return e1577(3, "bad scanline data");
                        if (r591) {
                            const e1582 = t[o237++];
                            for(let t434 = 0; t434 < n1125; t434++)c113[i802++] = e1582;
                        } else c113.set(t.subarray(o237, o237 + n1125), i802), i802 += n1125, o237 += n1125;
                    }
                    const d78 = r590;
                    for(let t433 = 0; t433 < d78; t433++){
                        let e1583 = 0;
                        s403[a313] = c113[t433 + e1583], e1583 += r590, s403[a313 + 1] = c113[t433 + e1583], e1583 += r590, s403[a313 + 2] = c113[t433 + e1583], e1583 += r590, s403[a313 + 3] = c113[t433 + e1583], a313 += 4;
                    }
                    u97--;
                }
                return s403;
            }(s398.subarray(s398.pos), t431, n1122);
            if (-1 !== o235) {
                let e1585, s404, l196, h155;
                switch(this.type){
                    case 1015:
                        h155 = o235.length / 4;
                        const t = new Float32Array(4 * h155);
                        for(let e1584 = 0; e1584 < h155; e1584++)i796(o235, 4 * e1584, t, 4 * e1584);
                        e1585 = t, l196 = 1015;
                        break;
                    case 1016:
                        h155 = o235.length / 4;
                        const n1126 = new Uint16Array(4 * h155);
                        for(let t437 = 0; t437 < h155; t437++)r585(o235, 4 * t437, n1126, 4 * t437);
                        e1585 = n1126, l196 = 1016;
                        break;
                    default:
                        console.error("THREE.RGBELoader: unsupported type: ", this.type);
                }
                return {
                    width: t431,
                    height: n1122,
                    data: e1585,
                    header: a310.string,
                    gamma: a310.gamma,
                    exposure: a310.exposure,
                    format: s404,
                    type: l196
                };
            }
        }
        return null;
    }
    setDataType(t) {
        return this.type = t, this;
    }
    load(t438, e1586, n1127, i803) {
        return super.load(t438, function(t, n1128) {
            switch(t.type){
                case 1015:
                case 1016:
                    t.encoding = 3e3, t.minFilter = 1006, t.magFilter = 1006, t.generateMipmaps = !1, t.flipY = !0;
            }
            e1586 && e1586(t, n1128);
        }, n1127, i803);
    }
};
Id.setDataType(1016);
class Od extends i {
    constructor(t){
        super(), this.threeRenderer = t, this.generatedEnvironmentMap = null, this.generatedEnvironmentMapAlt = null, this.skyboxCache = new Map, this.blurMaterial = null, this.blurScene = null;
    }
    async load(t439, e1587 = ()=>{}) {
        try {
            const n1129 = Pd.test(t439), i804 = n1129 ? Id : Dd, r592 = await new Promise((n1130, r594)=>i804.load(t439, n1130, (t)=>{
                    e1587(t.loaded / t.total * .9);
                }, r594));
            return e1587(1), r592.name = t439, r592.mapping = 303, n1129 || (r592.encoding = 3001), r592;
        } finally{
            e1587 && e1587(1);
        }
    }
    async generateEnvironmentMapAndSkybox(t = null, e1588 = null, n1131 = {}) {
        const { progressTracker: i805  } = n1131, r595 = "neutral" === e1588;
        !0 === r595 && (e1588 = null), e1588 = ru(e1588);
        let s405, a314 = Promise.resolve(null);
        t && (a314 = this.loadEquirectFromUrl(t, i805)), s405 = e1588 ? this.loadEquirectFromUrl(e1588, i805) : t ? this.loadEquirectFromUrl(t, i805) : !0 === r595 ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();
        let [o238, l197] = await Promise.all([
            s405,
            a314
        ]);
        if (null == o238) throw new Error("Failed to load environment map.");
        return {
            environmentMap: o238,
            skybox: l197
        };
    }
    async loadEquirectFromUrl(t, e1589) {
        if (!this.skyboxCache.has(t)) {
            const n1132 = e1589 ? e1589.beginActivity() : ()=>{}, i806 = this.load(t, n1132);
            this.skyboxCache.set(t, i806);
        }
        return this.skyboxCache.get(t);
    }
    async GenerateEnvironmentMap(t, e1590) {
        await uu();
        const n1133 = this.threeRenderer, i807 = new Xe(256, {
            generateMipmaps: !1,
            type: 1016,
            format: 1023,
            encoding: 3e3,
            depthBuffer: !0
        }), r596 = new je(.1, 100, i807), s406 = r596.renderTarget.texture;
        s406.name = e1590;
        const a315 = n1133.outputEncoding, o239 = n1133.toneMapping;
        return n1133.toneMapping = 0, n1133.outputEncoding = 3e3, r596.update(n1133, t), this.blurCubemap(i807, .04), n1133.toneMapping = o239, n1133.outputEncoding = a315, s406;
    }
    async loadGeneratedEnvironmentMap() {
        return null == this.generatedEnvironmentMap && (this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new Cd, "default")), this.generatedEnvironmentMap;
    }
    async loadGeneratedEnvironmentMapAlt() {
        return null == this.generatedEnvironmentMapAlt && (this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new Ld, "neutral")), this.generatedEnvironmentMapAlt;
    }
    blurCubemap(t, e1592) {
        if (null == this.blurMaterial) {
            this.blurMaterial = this.getBlurShader(20);
            const t = new ke, e1591 = new Fe(t, this.blurMaterial);
            this.blurScene = new Nr, this.blurScene.add(e1591);
        }
        const n1134 = t.clone();
        this.halfblur(t, n1134, e1592, "latitudinal"), this.halfblur(n1134, t, e1592, "longitudinal");
    }
    halfblur(t, e1594, n1135, i808) {
        const r597 = t.width, s407 = isFinite(n1135) ? Math.PI / (2 * r597) : 2 * Math.PI / 39, a316 = n1135 / s407, o240 = isFinite(n1135) ? 1 + Math.floor(3 * a316) : 20;
        o240 > 20 && console.warn(`sigmaRadians, ${n1135}, is too large and will clip, as it requested ${o240} samples when the maximum is set to 20`);
        const l198 = [];
        let h156 = 0;
        for(let t440 = 0; t440 < 20; ++t440){
            const e1593 = t440 / a316, n1136 = Math.exp(-e1593 * e1593 / 2);
            l198.push(n1136), 0 == t440 ? h156 += n1136 : t440 < o240 && (h156 += 2 * n1136);
        }
        for(let t441 = 0; t441 < l198.length; t441++)l198[t441] = l198[t441] / h156;
        const c114 = this.blurMaterial.uniforms;
        c114.envMap.value = t.texture, c114.samples.value = o240, c114.weights.value = l198, c114.latitudinal.value = "latitudinal" === i808, c114.dTheta.value = s407;
        new je(.1, 100, e1594).update(this.threeRenderer, this.blurScene);
    }
    getBlurShader(t) {
        const e1595 = new Float32Array(t), n1137 = new V(0, 1, 0);
        return new Ve({
            name: "SphericalGaussianBlur",
            defines: {
                n: t
            },
            uniforms: {
                envMap: {
                    value: null
                },
                samples: {
                    value: 1
                },
                weights: {
                    value: e1595
                },
                latitudinal: {
                    value: !1
                },
                dTheta: {
                    value: 0
                },
                poleAxis: {
                    value: n1137
                }
            },
            vertexShader: "\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    ",
            fragmentShader: "\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      ",
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
            side: 1
        });
    }
    async dispose() {
        for (const [, t] of this.skyboxCache)(await t).dispose();
        null != this.generatedEnvironmentMap && ((await this.generatedEnvironmentMap).dispose(), this.generatedEnvironmentMap = null), null != this.generatedEnvironmentMapAlt && ((await this.generatedEnvironmentMapAlt).dispose(), this.generatedEnvironmentMapAlt = null), null != this.blurMaterial && this.blurMaterial.dispose();
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Nd = [
    1,
    .79,
    .62,
    .5,
    .4,
    .31,
    .25
];
class Fd extends i {
    constructor(t442){
        super(), this.loader = new Jc(Rd), this.width = 0, this.height = 0, this.dpr = 1, this.debugger = null, this.scenes = new Set, this.multipleScenesVisible = !1, this.scaleStep = 0, this.lastStep = 3, this.avgFrameDuration = 22, this.onWebGLContextLost = (t)=>{
            this.dispatchEvent({
                type: "contextlost",
                sourceEvent: t
            });
        }, this.onWebGLContextRestored = ()=>{
            var t;
            null === (t = this.textureUtils) || void 0 === t || t.dispose(), this.textureUtils = new Od(this.threeRenderer);
            for (const t443 of this.scenes)t443.element[Gu]();
        }, this.dpr = hu(), this.canvas3D = document.createElement("canvas"), this.canvas3D.id = "webgl-canvas";
        try {
            this.threeRenderer = new Or({
                canvas: this.canvas3D,
                alpha: !0,
                antialias: !0,
                powerPreference: t442.powerPreference,
                preserveDrawingBuffer: !0
            }), this.threeRenderer.autoClear = !0, this.threeRenderer.outputEncoding = 3001, this.threeRenderer.physicallyCorrectLights = !0, this.threeRenderer.setPixelRatio(1), this.debugger = t442.debug ? new hd(this) : null, this.threeRenderer.debug = {
                checkShaderErrors: !!this.debugger
            }, this.threeRenderer.toneMapping = 4;
        } catch (t) {
            console.warn(t);
        }
        this.arRenderer = new ld(this), this.textureUtils = this.canRender ? new Od(this.threeRenderer) : null, Jc.initializeKTX2Loader(this.threeRenderer), this.canvas3D.addEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.addEventListener("webglcontextrestored", this.onWebGLContextRestored), this.updateRendererSize(), this.lastTick = performance.now(), this.avgFrameDuration = 0;
    }
    static get singleton() {
        return this._singleton;
    }
    static resetSingleton() {
        const t = this._singleton.dispose();
        for (const e1597 of t)e1597.disconnectedCallback();
        this._singleton = new Fd({
            powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance",
            debug: cu()
        });
        for (const e1596 of t)e1596.connectedCallback();
    }
    get canRender() {
        return null != this.threeRenderer;
    }
    get scaleFactor() {
        return Nd[this.scaleStep];
    }
    set minScale(t) {
        let e1598 = 1;
        for(; e1598 < Nd.length && !(Nd[e1598] < t);)++e1598;
        this.lastStep = e1598 - 1;
    }
    updateRendererSize() {
        const t = hu();
        if (t !== this.dpr) for (const t444 of this.scenes){
            const { element: e1599  } = t444;
            e1599[op](e1599.getBoundingClientRect());
        }
        let e1600 = 0, n1138 = 0;
        for (const t445 of this.scenes)e1600 = Math.max(e1600, t445.width), n1138 = Math.max(n1138, t445.height);
        if (e1600 === this.width && n1138 === this.height && t === this.dpr) return;
        this.width = e1600, this.height = n1138, this.dpr = t, this.canRender && this.threeRenderer.setSize(e1600 * t, n1138 * t, !1);
        const i810 = this.scaleFactor, r598 = e1600 / i810, s408 = n1138 / i810;
        this.canvas3D.style.width = `${r598}px`, this.canvas3D.style.height = `${s408}px`;
        for (const i809 of this.scenes){
            const { canvas: a317  } = i809;
            a317.width = Math.round(e1600 * t), a317.height = Math.round(n1138 * t), a317.style.width = `${r598}px`, a317.style.height = `${s408}px`, i809.queueRender();
        }
    }
    updateRendererScale() {
        const t = this.scaleStep;
        if (this.avgFrameDuration > 26 ? ++this.scaleStep : this.avgFrameDuration < 18 && this.scaleStep > 0 && --this.scaleStep, this.scaleStep = Math.min(this.scaleStep, this.lastStep), t == this.scaleStep) return;
        const e1601 = this.scaleFactor;
        this.avgFrameDuration = 22;
        const n1139 = this.width / e1601, i811 = this.height / e1601;
        this.canvas3D.style.width = `${n1139}px`, this.canvas3D.style.height = `${i811}px`;
        for (const t446 of this.scenes){
            const { style: e1602  } = t446.canvas;
            e1602.width = `${n1139}px`, e1602.height = `${i811}px`, t446.queueRender(), this.dispatchRenderScale(t446);
        }
    }
    dispatchRenderScale(t) {
        const e1603 = this.scaleFactor, n1140 = this.dpr * e1603, i812 = e1603 < 1 ? "GPU throttling" : this.dpr !== window.devicePixelRatio ? "No meta viewport tag" : "";
        t.element.dispatchEvent(new CustomEvent("render-scale", {
            detail: {
                reportedDpr: window.devicePixelRatio,
                renderedDpr: n1140,
                minimumDpr: this.dpr * Nd[this.lastStep],
                pixelWidth: Math.ceil(t.width * n1140),
                pixelHeight: Math.ceil(t.height * n1140),
                reason: i812
            }
        }));
    }
    registerScene(t447) {
        this.scenes.add(t447);
        const { canvas: e1604  } = t447, n1141 = this.scaleFactor;
        e1604.width = Math.round(this.width * this.dpr), e1604.height = Math.round(this.height * this.dpr), e1604.style.width = this.width / n1141 + "px", e1604.style.height = this.height / n1141 + "px", this.multipleScenesVisible && e1604.classList.add("show"), t447.queueRender(), this.dispatchRenderScale(t447), this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop((t, e1605)=>this.render(t, e1605)), null != this.debugger && this.debugger.addScene(t447);
    }
    unregisterScene(t) {
        this.scenes.delete(t), this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null), null != this.debugger && this.debugger.removeScene(t);
    }
    displayCanvas(t) {
        return this.multipleScenesVisible ? t.element[bp] : this.canvas3D;
    }
    selectCanvas() {
        let t = 0, e1606 = null;
        for (const n1143 of this.scenes){
            const { element: i813  } = n1143;
            i813.modelIsVisible && null == n1143.externalRenderer && (++t, e1606 = n1143.canvas);
        }
        if (null == e1606) return;
        const n1142 = t > 1, { canvas3D: i814  } = this;
        if (n1142 !== this.multipleScenesVisible || !n1142 && i814.parentElement !== e1606.parentElement) {
            this.multipleScenesVisible = n1142, n1142 && i814.classList.remove("show");
            for (const t of this.scenes){
                if (null != t.externalRenderer) continue;
                const r599 = t.element[bp];
                n1142 ? (r599.classList.add("show"), t.queueRender()) : t.canvas === e1606 && (t.canvas.parentElement.appendChild(i814), i814.classList.add("show"), r599.classList.remove("show"), t.queueRender());
            }
        }
    }
    orderedScenes() {
        const t = [];
        for (const e1607 of [
            !1,
            !0
        ])for (const n1144 of this.scenes)n1144.element.modelIsVisible === e1607 && t.push(n1144);
        return t;
    }
    get isPresenting() {
        return this.arRenderer.isPresenting;
    }
    preRender(t, e1608, n1145) {
        const { element: i815 , exposure: r600  } = t;
        i815[Mp](e1608, n1145);
        const s409 = "number" == typeof r600 && !self.isNaN(r600);
        this.threeRenderer.toneMappingExposure = s409 ? r600 : 1;
    }
    render(t, e1610) {
        if (null != e1610) return void this.arRenderer.onWebXRFrame(t, e1610);
        const n1146 = t - this.lastTick;
        if (this.lastTick = t, !this.canRender || this.isPresenting) return;
        this.avgFrameDuration += lu(.2 * (n1146 - this.avgFrameDuration), -2, 2), this.selectCanvas(), this.updateRendererSize(), this.updateRendererScale();
        const { dpr: i817 , scaleFactor: r602  } = this;
        for (const e1609 of this.orderedScenes()){
            const { element: s410  } = e1609;
            if (!s410.modelIsVisible && e1609.renderCount > 0) continue;
            if (this.preRender(e1609, t, n1146), !e1609.shouldRender()) continue;
            if (null != e1609.externalRenderer) {
                const t = e1609.getCamera();
                t.updateMatrix();
                const { matrix: n1147 , projectionMatrix: i816  } = t, r601 = n1147.elements.slice(), s411 = e1609.getTarget();
                r601[12] += s411.x, r601[13] += s411.y, r601[14] += s411.z, e1609.externalRenderer.render({
                    viewMatrix: r601,
                    projectionMatrix: i816.elements
                });
                continue;
            }
            if (!s410.modelIsVisible && !this.multipleScenesVisible) for (const t448 of this.scenes)t448.element.modelIsVisible && t448.queueRender();
            const a318 = Math.min(Math.ceil(e1609.width * r602 * i817), this.canvas3D.width), o241 = Math.min(Math.ceil(e1609.height * r602 * i817), this.canvas3D.height);
            if (e1609.renderShadow(this.threeRenderer), this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.floor(this.height * i817) - o241, a318, o241), this.threeRenderer.render(e1609, e1609.camera), this.multipleScenesVisible) {
                null == e1609.context && e1609.createContext();
                const t = e1609.context;
                t.clearRect(0, 0, a318, o241), t.drawImage(this.canvas3D, 0, 0, a318, o241, 0, 0, a318, o241);
            }
            e1609.hasRendered(), s410.loaded && ++e1609.renderCount;
        }
    }
    dispose() {
        null != this.textureUtils && this.textureUtils.dispose(), null != this.threeRenderer && this.threeRenderer.dispose(), this.textureUtils = null, this.threeRenderer = null;
        const t = [];
        for (const e1611 of this.scenes)t.push(e1611.element);
        return this.canvas3D.removeEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.removeEventListener("webglcontextrestored", this.onWebGLContextRestored), t;
    }
}
Fd._singleton = new Fd({
    powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance",
    debug: cu()
});
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class Ud extends EventTarget {
    constructor(){
        super(...arguments), this.ongoingActivities = new Set, this.totalProgress = 0;
    }
    get ongoingActivityCount() {
        return this.ongoingActivities.size;
    }
    beginActivity() {
        const t = {
            progress: 0,
            completed: !1
        };
        return this.ongoingActivities.add(t), 1 === this.ongoingActivityCount && this.announceTotalProgress(t, 0), (e1612)=>{
            let n1148;
            return n1148 = Math.max(lu(e1612, 0, 1), t.progress), n1148 !== t.progress && this.announceTotalProgress(t, n1148), t.progress;
        };
    }
    announceTotalProgress(t, e1613) {
        let n1149 = 0, i818 = 0;
        1 == e1613 && (t.completed = !0);
        for (const t449 of this.ongoingActivities){
            const { progress: e1614  } = t449;
            n1149 += 1 - e1614, !0 === t449.completed && i818++;
        }
        const r603 = t.progress;
        t.progress = e1613, this.totalProgress += (e1613 - r603) * (1 - this.totalProgress) / n1149;
        const s412 = i818 === this.ongoingActivityCount ? 1 : this.totalProgress;
        this.dispatchEvent(new CustomEvent("progress", {
            detail: {
                totalProgress: s412
            }
        })), i818 === this.ongoingActivityCount && (this.totalProgress = 0, this.ongoingActivities.clear());
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var kd, Bd, zd, Hd, Vd, Gd, Wd, jd, qd, Xd, $d, Yd, Jd = function(t, e1615, n1150, i819) {
    for(var r604, s413 = arguments.length, a319 = s413 < 3 ? e1615 : null === i819 ? i819 = Object.getOwnPropertyDescriptor(e1615, n1150) : i819, o242 = t.length - 1; o242 >= 0; o242--)(r604 = t[o242]) && (a319 = (s413 < 3 ? r604(a319) : s413 > 3 ? r604(e1615, n1150, a319) : r604(e1615, n1150)) || a319);
    return s413 > 3 && a319 && Object.defineProperty(e1615, n1150, a319), a319;
};
const Kd = document.createElement("canvas"), Zd = Symbol("fallbackResizeHandler"), Qd = Symbol("defaultAriaLabel"), tp = Symbol("resizeObserver"), ep = Symbol("clearModelTimeout"), np = Symbol("onContextLost"), ip = Symbol("loaded"), rp = Symbol("status"), sp = Symbol("onFocus"), ap = Symbol("onBlur"), op = Symbol("updateSize"), lp = Symbol("intersectionObserver"), hp = Symbol("isElementInViewport"), cp = Symbol("announceModelVisibility"), up = Symbol("ariaLabel"), dp = Symbol("altDefaulted"), pp = Symbol("statusElement"), mp = Symbol("updateStatus"), fp = Symbol("loadedTime"), gp = Symbol("updateSource"), vp = Symbol("markLoaded"), yp = Symbol("container"), xp = Symbol("input"), bp = Symbol("canvas"), _p = Symbol("scene"), wp = Symbol("needsRender"), Mp = Symbol("tick"), Sp = Symbol("onModelLoad"), Tp = Symbol("onResize"), Ep = Symbol("renderer"), Ap = Symbol("progressTracker"), Rp = Symbol("getLoaded"), Cp = Symbol("getModelIsVisible"), Lp = Symbol("shouldAttemptPreload"), Pp = Symbol("sceneIsReady"), Dp = Symbol("hasTransitioned"), Ip = (t)=>({
        x: t.x,
        y: t.y,
        z: t.z,
        toString () {
            return `${this.x}m ${this.y}m ${this.z}m`;
        }
    }), Op = (t)=>({
        u: t.x,
        v: t.y,
        toString () {
            return `${this.u} ${this.v}`;
        }
    });
class Np extends Ml {
    constructor(){
        super(), this.alt = null, this.src = null, this.withCredentials = !1, this[kd] = !1, this[Bd] = !1, this[zd] = 0, this[Hd] = null, this[Vd] = ou(()=>{
            const t = this.getBoundingClientRect();
            this[op](t);
        }, 50), this[Gd] = ou((t)=>{
            const e1617 = this.modelIsVisible;
            e1617 !== t && this.dispatchEvent(new CustomEvent("model-visibility", {
                detail: {
                    visible: e1617
                }
            }));
        }, 0), this[Wd] = null, this[jd] = null, this[qd] = new Ud, this[Xd] = ()=>{
            this[pp].textContent = this[rp];
        }, this[$d] = ()=>{
            this[pp].textContent = "";
        }, this[Yd] = (t)=>{
            this.dispatchEvent(new CustomEvent("error", {
                detail: {
                    type: "webglcontextlost",
                    sourceError: t.sourceEvent
                }
            }));
        }, this.attachShadow({
            mode: "open"
        });
        const t450 = this.shadowRoot;
        let e1616, n1151;
        if (((t)=>{
            jl(bh, t);
        })(t450), this[yp] = t450.querySelector(".container"), this[xp] = t450.querySelector(".userInput"), this[bp] = t450.querySelector("canvas"), this[pp] = t450.querySelector("#status"), this[Qd] = this[xp].getAttribute("aria-label"), this.isConnected) {
            const t = this.getBoundingClientRect();
            e1616 = t.width, n1151 = t.height;
        } else e1616 = 300, n1151 = 150;
        this[_p] = new Bu({
            canvas: this[bp],
            element: this,
            width: e1616,
            height: n1151
        }), this[_p].addEventListener("model-load", async (t)=>{
            this[vp](), this[Sp](), await uu(), this.dispatchEvent(new CustomEvent("load", {
                detail: {
                    url: t.url
                }
            }));
        }), Promise.resolve().then(()=>{
            this[op](this.getBoundingClientRect());
        }), uh && (this[tp] = new ResizeObserver((t)=>{
            if (!this[Ep].isPresenting) for (let e1618 of t)e1618.target === this && this[op](e1618.contentRect);
        })), dh ? this[lp] = new IntersectionObserver((t)=>{
            for (let e1619 of t)if (e1619.target === this) {
                const t = this.modelIsVisible;
                this[hp] = e1619.isIntersecting, this[cp](t), this[hp] && !this[Pp]() && this[gp]();
            }
        }, {
            root: null,
            rootMargin: "0px",
            threshold: 0
        }) : this[hp] = !0;
    }
    static get is() {
        return "model-viewer";
    }
    static set modelCacheSize(t) {
        Jc[$c].evictionThreshold = t;
    }
    static get modelCacheSize() {
        return Jc[$c].evictionThreshold;
    }
    static set minimumRenderScale(t) {
        t > 1 && console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."), t <= 0 && console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25."), Fd.singleton.minScale = t;
    }
    static get minimumRenderScale() {
        return Fd.singleton.minScale;
    }
    get loaded() {
        return this[Rp]();
    }
    get [(kd = hp, Bd = ip, zd = fp, Hd = ep, Vd = Zd, Gd = cp, Wd = tp, jd = lp, qd = Ap, Ep)]() {
        return Fd.singleton;
    }
    get modelIsVisible() {
        return this[Cp]();
    }
    connectedCallback() {
        super.connectedCallback && super.connectedCallback(), uh ? this[tp].observe(this) : self.addEventListener("resize", this[Zd]), dh && this[lp].observe(this), this.addEventListener("focus", this[sp]), this.addEventListener("blur", this[ap]);
        const t = this[Ep];
        t.addEventListener("contextlost", this[np]), t.registerScene(this[_p]), null != this[ep] && (self.clearTimeout(this[ep]), this[ep] = null, this.requestUpdate("src", null));
    }
    disconnectedCallback() {
        super.disconnectedCallback && super.disconnectedCallback(), uh ? this[tp].unobserve(this) : self.removeEventListener("resize", this[Zd]), dh && this[lp].unobserve(this), this.removeEventListener("focus", this[sp]), this.removeEventListener("blur", this[ap]);
        const t = this[Ep];
        t.removeEventListener("contextlost", this[np]), t.unregisterScene(this[_p]), this[ep] = self.setTimeout(()=>{
            this[_p].reset();
        }, 1e3);
    }
    updated(t) {
        super.updated(t), t.has("src") && (null == this.src ? (this[ip] = !1, this[fp] = 0, this[_p].reset()) : this.src !== this[_p].url && (this[ip] = !1, this[fp] = 0, this[gp]())), t.has("alt") && this[xp].setAttribute("aria-label", this[up]), t.has("withCredentials") && (Jc.withCredentials = this.withCredentials);
    }
    toDataURL(t, e1620) {
        return this[Ep].displayCanvas(this[_p]).toDataURL(t, e1620);
    }
    async toBlob(t451) {
        const e1621 = t451 ? t451.mimeType : void 0, n1152 = t451 ? t451.qualityArgument : void 0, i820 = t451 ? t451.idealAspect : void 0, { width: r605 , height: s414 , idealAspect: a320 , aspect: o243  } = this[_p], { dpr: l199 , scaleFactor: h157  } = this[Ep];
        let c115 = r605 * h157 * l199, u98 = s414 * h157 * l199, d79 = 0, p69 = 0;
        if (!0 === i820) {
            if (a320 > o243) {
                const t = u98;
                u98 = Math.round(c115 / a320), p69 = (t - u98) / 2;
            } else {
                const t = c115;
                c115 = Math.round(u98 * a320), d79 = (t - c115) / 2;
            }
        }
        Kd.width = c115, Kd.height = u98;
        try {
            return new Promise(async (t452, i821)=>(Kd.getContext("2d").drawImage(this[Ep].displayCanvas(this[_p]), d79, p69, c115, u98, 0, 0, c115, u98), !Kd.msToBlob || e1621 && "image/png" !== e1621 ? Kd.toBlob ? void Kd.toBlob((e1622)=>{
                    if (!e1622) return i821(new Error("Unable to retrieve canvas blob"));
                    t452(e1622);
                }, e1621, n1152) : t452(await (async (t454)=>new Promise((e1624, n1153)=>{
                        const i822 = t454.match(/data:(.*);/);
                        if (!i822) return n1153(new Error(`${t454} is not a valid data Url`));
                        const r606 = i822[1], s415 = t454.replace(/data:image\/\w+;base64,/, ""), a321 = atob(s415), o244 = [];
                        for(let t453 = 0; t453 < a321.length; t453 += 512){
                            const e1623 = a321.slice(t453, t453 + 512), n1154 = new Array(e1623.length);
                            for(let t = 0; t < e1623.length; t++)n1154[t] = e1623.charCodeAt(t);
                            const i823 = new Uint8Array(n1154);
                            o244.push(i823);
                        }
                        e1624(new Blob(o244, {
                            type: r606
                        }));
                    }))(Kd.toDataURL(e1621, n1152))) : t452(Kd.msToBlob())));
        } finally{
            this[op]({
                width: r605,
                height: s414
            });
        }
    }
    registerRenderer(t) {
        this[_p].externalRenderer = t;
    }
    unregisterRenderer() {
        this[_p].externalRenderer = null;
    }
    get [up]() {
        return this[dp];
    }
    get [dp]() {
        return null == this.alt || "null" === this.alt ? this[Qd] : this.alt;
    }
    [Rp]() {
        return this[ip];
    }
    [Cp]() {
        return this.loaded && this[hp];
    }
    [Dp]() {
        return this.modelIsVisible;
    }
    [Lp]() {
        return !!this.src && this[hp];
    }
    [Pp]() {
        return this[ip];
    }
    [op]({ width: t , height: e1625  }) {
        this[yp].style.width = `${t}px`, this[yp].style.height = `${e1625}px`, this[Tp]({
            width: parseFloat(t),
            height: parseFloat(e1625)
        });
    }
    [Mp](t, e) {}
    [vp]() {
        this[ip] || (this[ip] = !0, this[fp] = performance.now());
    }
    [wp]() {
        this[_p].queueRender();
    }
    [Sp]() {}
    [mp](t) {
        this[rp] = t;
        const e1626 = this.getRootNode();
        null != e1626 && e1626.activeElement === this && this[pp].textContent != t && (this[pp].textContent = t);
    }
    [(Xd = sp, $d = ap, Tp)](t) {
        this[_p].setSize(t.width, t.height);
    }
    async [(Yd = np, gp)]() {
        if (this.loaded || !this[Lp]()) return;
        const t = this[Ap].beginActivity(), e1627 = this.src;
        try {
            await this[_p].setSource(e1627, (e1628)=>t(.95 * e1628));
            const n1155 = {
                url: e1627
            };
            this.dispatchEvent(new CustomEvent("preload", {
                detail: n1155
            }));
        } catch (t455) {
            this.dispatchEvent(new CustomEvent("error", {
                detail: t455
            }));
        } finally{
            requestAnimationFrame(()=>{
                requestAnimationFrame(()=>{
                    t(1);
                });
            });
        }
    }
}
Jd([
    e({
        type: String
    })
], Np.prototype, "alt", void 0), Jd([
    e({
        type: String
    })
], Np.prototype, "src", void 0), Jd([
    e({
        type: Boolean,
        attribute: "with-credentials"
    })
], Np.prototype, "withCredentials", void 0);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Fp = function(t, e1629, n1156, i824) {
    for(var r607, s416 = arguments.length, a322 = s416 < 3 ? e1629 : null === i824 ? i824 = Object.getOwnPropertyDescriptor(e1629, n1156) : i824, o245 = t.length - 1; o245 >= 0; o245--)(r607 = t[o245]) && (a322 = (s416 < 3 ? r607(a322) : s416 > 3 ? r607(e1629, n1156, a322) : r607(e1629, n1156)) || a322);
    return s416 > 3 && a322 && Object.defineProperty(e1629, n1156, a322), a322;
};
const Up = Symbol("changeAnimation"), kp = Symbol("paused"), Bp = {
    repetitions: 1 / 0,
    pingpong: !1
}, zp = Symbol("hotspotMap"), Hp = Symbol("mutationCallback"), Vp = Symbol("observer"), Gp = Symbol("addHotspot"), Wp = Symbol("removeHotspot"), jp = new xt, qp = new v;
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/ var Xp = function(t) {
    return URL.createObjectURL(new Blob([
        t
    ], {
        type: "text/javascript"
    }));
};
try {
    URL.revokeObjectURL(Xp(""));
} catch (Al1) {
    Xp = function(t) {
        return "data:application/javascript;charset=UTF-8," + encodeURI(t);
    };
}
var $p = Uint8Array, Yp = Uint16Array, Jp = Uint32Array, Kp = new $p([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    0,
    0,
    0
]), Zp = new $p([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    0,
    0
]), Qp = new $p([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]), tm = function(t, e1630) {
    for(var n1157 = new Yp(31), i825 = 0; i825 < 31; ++i825)n1157[i825] = e1630 += 1 << t[i825 - 1];
    var r608 = new Jp(n1157[30]);
    for(i825 = 1; i825 < 30; ++i825)for(var s417 = n1157[i825]; s417 < n1157[i825 + 1]; ++s417)r608[s417] = s417 - n1157[i825] << 5 | i825;
    return [
        n1157,
        r608
    ];
}, em = tm(Kp, 2), nm = em[0], im = em[1];
nm[28] = 258, im[258] = 28;
for(var rm = tm(Zp, 0)[1], sm = new Yp(32768), am = 0; am < 32768; ++am){
    var om = (43690 & am) >>> 1 | (21845 & am) << 1;
    om = (61680 & (om = (52428 & om) >>> 2 | (13107 & om) << 2)) >>> 4 | (3855 & om) << 4, sm[am] = ((65280 & om) >>> 8 | (255 & om) << 8) >>> 1;
}
var lm = function(t, e1631, n1158) {
    for(var i826 = t.length, r609 = 0, s418 = new Yp(e1631); r609 < i826; ++r609)++s418[t[r609] - 1];
    var a323, o246 = new Yp(e1631);
    for(r609 = 0; r609 < e1631; ++r609)o246[r609] = o246[r609 - 1] + s418[r609 - 1] << 1;
    if (n1158) {
        a323 = new Yp(1 << e1631);
        var l200 = 15 - e1631;
        for(r609 = 0; r609 < i826; ++r609)if (t[r609]) for(var h158 = r609 << 4 | t[r609], c116 = e1631 - t[r609], u99 = (o246[t[r609] - 1]++) << c116, d80 = u99 | (1 << c116) - 1; u99 <= d80; ++u99)a323[sm[u99] >>> l200] = h158;
    } else for(a323 = new Yp(i826), r609 = 0; r609 < i826; ++r609)t[r609] && (a323[r609] = sm[o246[t[r609] - 1]++] >>> 15 - t[r609]);
    return a323;
}, hm = new $p(288);
for(am = 0; am < 144; ++am)hm[am] = 8;
for(am = 144; am < 256; ++am)hm[am] = 9;
for(am = 256; am < 280; ++am)hm[am] = 7;
for(am = 280; am < 288; ++am)hm[am] = 8;
var cm = new $p(32);
for(am = 0; am < 32; ++am)cm[am] = 5;
var um = lm(hm, 9, 0), dm = lm(cm, 5, 0), pm = function(t) {
    return (t / 8 | 0) + (7 & t && 1);
}, mm = function(t, e1632, n1159) {
    (null == e1632 || e1632 < 0) && (e1632 = 0), (null == n1159 || n1159 > t.length) && (n1159 = t.length);
    var i827 = new (t instanceof Yp ? Yp : t instanceof Jp ? Jp : $p)(n1159 - e1632);
    return i827.set(t.subarray(e1632, n1159)), i827;
}, fm = function(t, e1633, n1160) {
    n1160 <<= 7 & e1633;
    var i828 = e1633 / 8 | 0;
    t[i828] |= n1160, t[i828 + 1] |= n1160 >>> 8;
}, gm = function(t, e1634, n1161) {
    n1161 <<= 7 & e1634;
    var i829 = e1634 / 8 | 0;
    t[i829] |= n1161, t[i829 + 1] |= n1161 >>> 8, t[i829 + 2] |= n1161 >>> 16;
}, vm = function(t456, e1635) {
    for(var n1162 = [], i830 = 0; i830 < t456.length; ++i830)t456[i830] && n1162.push({
        s: i830,
        f: t456[i830]
    });
    var r610 = n1162.length, s419 = n1162.slice();
    if (!r610) return [
        Sm,
        0
    ];
    if (1 == r610) {
        var a324 = new $p(n1162[0].s + 1);
        return a324[n1162[0].s] = 1, [
            a324,
            1
        ];
    }
    n1162.sort(function(t, e1636) {
        return t.f - e1636.f;
    }), n1162.push({
        s: -1,
        f: 25001
    });
    var o247 = n1162[0], l201 = n1162[1], h159 = 0, c117 = 1, u100 = 2;
    for(n1162[0] = {
        s: -1,
        f: o247.f + l201.f,
        l: o247,
        r: l201
    }; c117 != r610 - 1;)o247 = n1162[n1162[h159].f < n1162[u100].f ? h159++ : u100++], l201 = n1162[h159 != c117 && n1162[h159].f < n1162[u100].f ? h159++ : u100++], n1162[c117++] = {
        s: -1,
        f: o247.f + l201.f,
        l: o247,
        r: l201
    };
    var d81 = s419[0].s;
    for(i830 = 1; i830 < r610; ++i830)s419[i830].s > d81 && (d81 = s419[i830].s);
    var p70 = new Yp(d81 + 1), m50 = ym(n1162[c117 - 1], p70, 0);
    if (m50 > e1635) {
        i830 = 0;
        var f43 = 0, g35 = m50 - e1635, v33 = 1 << g35;
        for(s419.sort(function(t, e1637) {
            return p70[e1637.s] - p70[t.s] || t.f - e1637.f;
        }); i830 < r610; ++i830){
            var y32 = s419[i830].s;
            if (!(p70[y32] > e1635)) break;
            f43 += v33 - (1 << m50 - p70[y32]), p70[y32] = e1635;
        }
        for(f43 >>>= g35; f43 > 0;){
            var x27 = s419[i830].s;
            p70[x27] < e1635 ? f43 -= 1 << e1635 - p70[x27]++ - 1 : ++i830;
        }
        for(; i830 >= 0 && f43; --i830){
            var b24 = s419[i830].s;
            p70[b24] == e1635 && (--p70[b24], ++f43);
        }
        m50 = e1635;
    }
    return [
        new $p(p70),
        m50
    ];
}, ym = function(t, e1638, n1163) {
    return -1 == t.s ? Math.max(ym(t.l, e1638, n1163 + 1), ym(t.r, e1638, n1163 + 1)) : e1638[t.s] = n1163;
}, xm = function(t457) {
    for(var e1639 = t457.length; e1639 && !t457[--e1639];);
    for(var n1164 = new Yp(++e1639), i831 = 0, r611 = t457[0], s420 = 1, a325 = function(t) {
        n1164[i831++] = t;
    }, o248 = 1; o248 <= e1639; ++o248)if (t457[o248] == r611 && o248 != e1639) ++s420;
    else {
        if (!r611 && s420 > 2) {
            for(; s420 > 138; s420 -= 138)a325(32754);
            s420 > 2 && (a325(s420 > 10 ? s420 - 11 << 5 | 28690 : s420 - 3 << 5 | 12305), s420 = 0);
        } else if (s420 > 3) {
            for(a325(r611), --s420; s420 > 6; s420 -= 6)a325(8304);
            s420 > 2 && (a325(s420 - 3 << 5 | 8208), s420 = 0);
        }
        for(; s420--;)a325(r611);
        s420 = 1, r611 = t457[o248];
    }
    return [
        n1164.subarray(0, i831),
        e1639
    ];
}, bm = function(t, e1640) {
    for(var n1165 = 0, i832 = 0; i832 < e1640.length; ++i832)n1165 += t[i832] * e1640[i832];
    return n1165;
}, _m = function(t, e1641, n1166) {
    var i833 = n1166.length, r612 = pm(e1641 + 2);
    t[r612] = 255 & i833, t[r612 + 1] = i833 >>> 8, t[r612 + 2] = 255 ^ t[r612], t[r612 + 3] = 255 ^ t[r612 + 1];
    for(var s421 = 0; s421 < i833; ++s421)t[r612 + s421 + 4] = n1166[s421];
    return 8 * (r612 + 4 + i833);
}, wm = function(t, e1642, n1167, i834, r613, s422, a326, o249, l202, h160, c118) {
    fm(e1642, c118++, n1167), ++r613[256];
    for(var u101 = vm(r613, 15), d82 = u101[0], p71 = u101[1], m51 = vm(s422, 15), f44 = m51[0], g36 = m51[1], v34 = xm(d82), y33 = v34[0], x28 = v34[1], b25 = xm(f44), _19 = b25[0], w14 = b25[1], M11 = new Yp(19), S10 = 0; S10 < y33.length; ++S10)M11[31 & y33[S10]]++;
    for(S10 = 0; S10 < _19.length; ++S10)M11[31 & _19[S10]]++;
    for(var T12 = vm(M11, 7), E10 = T12[0], A10 = T12[1], R9 = 19; R9 > 4 && !E10[Qp[R9 - 1]]; --R9);
    var C8, L8, P8, D7, I8 = h160 + 5 << 3, O8 = bm(r613, hm) + bm(s422, cm) + a326, N8 = bm(r613, d82) + bm(s422, f44) + a326 + 14 + 3 * R9 + bm(M11, E10) + (2 * M11[16] + 3 * M11[17] + 7 * M11[18]);
    if (I8 <= O8 && I8 <= N8) return _m(e1642, c118, t.subarray(l202, l202 + h160));
    if (fm(e1642, c118, 1 + (N8 < O8)), c118 += 2, N8 < O8) {
        C8 = lm(d82, p71, 0), L8 = d82, P8 = lm(f44, g36, 0), D7 = f44;
        var F6 = lm(E10, A10, 0);
        fm(e1642, c118, x28 - 257), fm(e1642, c118 + 5, w14 - 1), fm(e1642, c118 + 10, R9 - 4), c118 += 14;
        for(S10 = 0; S10 < R9; ++S10)fm(e1642, c118 + 3 * S10, E10[Qp[S10]]);
        c118 += 3 * R9;
        for(var U3 = [
            y33,
            _19
        ], k4 = 0; k4 < 2; ++k4){
            var B5 = U3[k4];
            for(S10 = 0; S10 < B5.length; ++S10){
                var z5 = 31 & B5[S10];
                fm(e1642, c118, F6[z5]), c118 += E10[z5], z5 > 15 && (fm(e1642, c118, B5[S10] >>> 5 & 127), c118 += B5[S10] >>> 12);
            }
        }
    } else C8 = um, L8 = hm, P8 = dm, D7 = cm;
    for(S10 = 0; S10 < o249; ++S10)if (i834[S10] > 255) {
        z5 = i834[S10] >>> 18 & 31;
        gm(e1642, c118, C8[z5 + 257]), c118 += L8[z5 + 257], z5 > 7 && (fm(e1642, c118, i834[S10] >>> 23 & 31), c118 += Kp[z5]);
        var H5 = 31 & i834[S10];
        gm(e1642, c118, P8[H5]), c118 += D7[H5], H5 > 3 && (gm(e1642, c118, i834[S10] >>> 5 & 8191), c118 += Zp[H5]);
    } else gm(e1642, c118, C8[i834[S10]]), c118 += L8[i834[S10]];
    return gm(e1642, c118, C8[256]), c118 + L8[256];
}, Mm = new Jp([
    65540,
    131080,
    131088,
    131104,
    262176,
    1048704,
    1048832,
    2114560,
    2117632
]), Sm = new $p(0), Tm = function() {
    for(var t = new Jp(256), e1643 = 0; e1643 < 256; ++e1643){
        for(var n1168 = e1643, i835 = 9; --i835;)n1168 = (1 & n1168 && 3988292384) ^ n1168 >>> 1;
        t[e1643] = n1168;
    }
    return t;
}(), Em = function() {
    var t = -1;
    return {
        p: function(e1644) {
            for(var n1169 = t, i836 = 0; i836 < e1644.length; ++i836)n1169 = Tm[255 & n1169 ^ e1644[i836]] ^ n1169 >>> 8;
            t = n1169;
        },
        d: function() {
            return ~t;
        }
    };
}, Am = function(t458, e1645, n1170, i837, r614) {
    return function(t, e1646, n1171, i838, r615, s423) {
        var a327 = t.length, o250 = new $p(i838 + a327 + 5 * (1 + Math.ceil(a327 / 7e3)) + r615), l203 = o250.subarray(i838, o250.length - r615), h161 = 0;
        if (!e1646 || a327 < 8) for(var c119 = 0; c119 <= a327; c119 += 65535){
            var u102 = c119 + 65535;
            u102 < a327 ? h161 = _m(l203, h161, t.subarray(c119, u102)) : (l203[c119] = s423, h161 = _m(l203, h161, t.subarray(c119, a327)));
        }
        else {
            for(var d83 = Mm[e1646 - 1], p72 = d83 >>> 13, m52 = 8191 & d83, f45 = (1 << n1171) - 1, g37 = new Yp(32768), v35 = new Yp(f45 + 1), y34 = Math.ceil(n1171 / 3), x29 = 2 * y34, b26 = function(e1647) {
                return (t[e1647] ^ t[e1647 + 1] << y34 ^ t[e1647 + 2] << x29) & f45;
            }, _20 = new Jp(25e3), w15 = new Yp(288), M12 = new Yp(32), S11 = 0, T13 = 0, E11 = (c119 = 0, 0), A11 = 0, R10 = 0; c119 < a327; ++c119){
                var C9 = b26(c119), L9 = 32767 & c119, P9 = v35[C9];
                if (g37[L9] = P9, v35[C9] = L9, A11 <= c119) {
                    var D8 = a327 - c119;
                    if ((S11 > 7e3 || E11 > 24576) && D8 > 423) {
                        h161 = wm(t, l203, 0, _20, w15, M12, T13, E11, R10, c119 - R10, h161), E11 = S11 = T13 = 0, R10 = c119;
                        for(var I9 = 0; I9 < 286; ++I9)w15[I9] = 0;
                        for(I9 = 0; I9 < 30; ++I9)M12[I9] = 0;
                    }
                    var O9 = 2, N9 = 0, F7 = m52, U4 = L9 - P9 & 32767;
                    if (D8 > 2 && C9 == b26(c119 - U4)) for(var k5 = Math.min(p72, D8) - 1, B6 = Math.min(32767, c119), z6 = Math.min(258, D8); U4 <= B6 && --F7 && L9 != P9;){
                        if (t[c119 + O9] == t[c119 + O9 - U4]) {
                            for(var H6 = 0; H6 < z6 && t[c119 + H6] == t[c119 + H6 - U4]; ++H6);
                            if (H6 > O9) {
                                if (O9 = H6, N9 = U4, H6 > k5) break;
                                var V3 = Math.min(U4, H6 - 2), G5 = 0;
                                for(I9 = 0; I9 < V3; ++I9){
                                    var W4 = c119 - U4 + I9 + 32768 & 32767, j4 = W4 - g37[W4] + 32768 & 32767;
                                    j4 > G5 && (G5 = j4, P9 = W4);
                                }
                            }
                        }
                        U4 += (L9 = P9) - (P9 = g37[L9]) + 32768 & 32767;
                    }
                    if (N9) {
                        _20[E11++] = 268435456 | im[O9] << 18 | rm[N9];
                        var q3 = 31 & im[O9], X3 = 31 & rm[N9];
                        T13 += Kp[q3] + Zp[X3], ++w15[257 + q3], ++M12[X3], A11 = c119 + O9, ++S11;
                    } else _20[E11++] = t[c119], ++w15[t[c119]];
                }
            }
            h161 = wm(t, l203, s423, _20, w15, M12, T13, E11, R10, c119 - R10, h161), !s423 && 7 & h161 && (h161 = _m(l203, h161 + 1, Sm));
        }
        return mm(o250, 0, i838 + pm(h161) + r615);
    }(t458, null == e1645.level ? 6 : e1645.level, null == e1645.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t458.length)))) : 12 + e1645.mem, n1170, i837, !r614);
}, Rm = function(t, e1648) {
    var n1172 = {};
    for(var i839 in t)n1172[i839] = t[i839];
    for(var i839 in e1648)n1172[i839] = e1648[i839];
    return n1172;
}, Cm = function(t, e1649, n1173) {
    for(; n1173; ++e1649)t[e1649] = n1173, n1173 >>>= 8;
};
function Lm(t, e1650) {
    return Am(t, e1650 || {}, 0, 0);
}
var Pm = function(t, e1651, n1174, i840) {
    for(var r616 in t){
        var s424 = t[r616], a328 = e1651 + r616;
        s424 instanceof $p ? n1174[a328] = [
            s424,
            i840
        ] : Array.isArray(s424) ? n1174[a328] = [
            s424[0],
            Rm(i840, s424[1])
        ] : Pm(s424, a328 + "/", n1174, i840);
    }
}, Dm = "undefined" != typeof TextEncoder && new TextEncoder, Im = "undefined" != typeof TextDecoder && new TextDecoder;
try {
    Im.decode(Sm, {
        stream: !0
    });
} catch (Al2) {}
function Om(t459, e1652) {
    if (e1652) {
        for(var n1175 = new $p(t459.length), i841 = 0; i841 < t459.length; ++i841)n1175[i841] = t459.charCodeAt(i841);
        return n1175;
    }
    if (Dm) return Dm.encode(t459);
    var r617 = t459.length, s425 = new $p(t459.length + (t459.length >> 1)), a329 = 0, o251 = function(t) {
        s425[a329++] = t;
    };
    for(i841 = 0; i841 < r617; ++i841){
        if (a329 + 5 > s425.length) {
            var l204 = new $p(a329 + 8 + (r617 - i841 << 1));
            l204.set(s425), s425 = l204;
        }
        var h162 = t459.charCodeAt(i841);
        h162 < 128 || e1652 ? o251(h162) : h162 < 2048 ? (o251(192 | h162 >> 6), o251(128 | 63 & h162)) : h162 > 55295 && h162 < 57344 ? (o251(240 | (h162 = 65536 + (1047552 & h162) | 1023 & t459.charCodeAt(++i841)) >> 18), o251(128 | h162 >> 12 & 63), o251(128 | h162 >> 6 & 63), o251(128 | 63 & h162)) : (o251(224 | h162 >> 12), o251(128 | h162 >> 6 & 63), o251(128 | 63 & h162));
    }
    return mm(s425, 0, a329);
}
var Nm = function(t) {
    var e1653 = 0;
    if (t) for(var n1176 in t){
        var i842 = t[n1176].length;
        if (i842 > 65535) throw "extra field too long";
        e1653 += i842 + 4;
    }
    return e1653;
}, Fm = function(t, e1654, n1177, i843, r618, s426, a330, o252) {
    var l205 = i843.length, h163 = n1177.extra, c120 = o252 && o252.length, u103 = Nm(h163);
    Cm(t, e1654, null != a330 ? 33639248 : 67324752), e1654 += 4, null != a330 && (t[e1654++] = 20, t[e1654++] = n1177.os), t[e1654] = 20, e1654 += 2, t[e1654++] = n1177.flag << 1 | (null == s426 && 8), t[e1654++] = r618 && 8, t[e1654++] = 255 & n1177.compression, t[e1654++] = n1177.compression >> 8;
    var d84 = new Date(null == n1177.mtime ? Date.now() : n1177.mtime), p73 = d84.getFullYear() - 1980;
    if (p73 < 0 || p73 > 119) throw "date not in range 1980-2099";
    if (Cm(t, e1654, p73 << 25 | d84.getMonth() + 1 << 21 | d84.getDate() << 16 | d84.getHours() << 11 | d84.getMinutes() << 5 | d84.getSeconds() >>> 1), e1654 += 4, null != s426 && (Cm(t, e1654, n1177.crc), Cm(t, e1654 + 4, s426), Cm(t, e1654 + 8, n1177.size)), Cm(t, e1654 + 12, l205), Cm(t, e1654 + 14, u103), e1654 += 16, null != a330 && (Cm(t, e1654, c120), Cm(t, e1654 + 6, n1177.attrs), Cm(t, e1654 + 10, a330), e1654 += 14), t.set(i843, e1654), e1654 += l205, u103) for(var m53 in h163){
        var f46 = h163[m53], g38 = f46.length;
        Cm(t, e1654, +m53), Cm(t, e1654 + 2, g38), t.set(f46, e1654 + 4), e1654 += 4 + g38;
    }
    return c120 && (t.set(o252, e1654), e1654 += c120), e1654;
};
function Um(t460, e1655) {
    e1655 || (e1655 = {});
    var n1178 = {}, i844 = [];
    Pm(t460, "", n1178, e1655);
    var r619 = 0, s427 = 0;
    for(var a331 in n1178){
        var o253 = n1178[a331], l206 = o253[0], h164 = o253[1], c121 = 0 == h164.level ? 0 : 8, u104 = (M13 = Om(a331)).length, d85 = h164.comment, p74 = d85 && Om(d85), m54 = p74 && p74.length, f47 = Nm(h164.extra);
        if (u104 > 65535) throw "filename too long";
        var g39 = c121 ? Lm(l206, h164) : l206, v36 = g39.length, y35 = Em();
        y35.p(l206), i844.push(Rm(h164, {
            size: l206.length,
            crc: y35.d(),
            c: g39,
            f: M13,
            m: p74,
            u: u104 != a331.length || p74 && d85.length != m54,
            o: r619,
            compression: c121
        })), r619 += 30 + u104 + f47 + v36, s427 += 76 + 2 * (u104 + f47) + (m54 || 0) + v36;
    }
    for(var x30 = new $p(s427 + 22), b27 = r619, _21 = s427 - r619, w16 = 0; w16 < i844.length; ++w16){
        var M13 = i844[w16];
        Fm(x30, M13.o, M13, M13.f, M13.u, M13.c.length);
        var S12 = 30 + M13.f.length + Nm(M13.extra);
        x30.set(M13.c, M13.o + S12), Fm(x30, r619, M13, M13.f, M13.u, M13.c.length, M13.o, M13.m), r619 += 16 + S12 + (M13.m ? M13.m.length : 0);
    }
    return function(t, e1656, n1179, i845, r620) {
        Cm(t, e1656, 101010256), Cm(t, e1656 + 8, n1179), Cm(t, e1656 + 10, n1179), Cm(t, e1656 + 12, i845), Cm(t, e1656 + 16, r620);
    }(x30, r619, i844.length, _21, b27), x30;
}
class km {
    async parse(t463) {
        const e1657 = {};
        e1657["model.usda"] = null;
        let n1180 = zm();
        const i846 = {}, r621 = {};
        t463.traverseVisible((t468)=>{
            if (t468.isMesh) {
                if (t468.material.isMeshStandardMaterial) {
                    const r622 = t468.geometry, s429 = t468.material, a332 = "geometries/Geometry_" + r622.id + ".usd";
                    if (!(a332 in e1657)) {
                        const t464 = function(t467) {
                            return `\ndef "Geometry"\n{\n  ${function(t469) {
                                const e1658 = "Geometry", n1181 = t469.attributes, i847 = n1181.position.count;
                                return `\n    def Mesh "${e1658}"\n    {\n        int[] faceVertexCounts = [${function(t) {
                                    const e1659 = null !== t.index ? t.index.count : t.attributes.position.count;
                                    return Array(e1659 / 3).fill(3).join(", ");
                                }(t469)}]\n        int[] faceVertexIndices = [${function(t) {
                                    const e1660 = t.index, n1182 = [];
                                    if (null !== e1660) for(let t470 = 0; t470 < e1660.count; t470++)n1182.push(e1660.getX(t470));
                                    else {
                                        const e1661 = t.attributes.position.count;
                                        for(let t471 = 0; t471 < e1661; t471++)n1182.push(t471);
                                    }
                                    return n1182.join(", ");
                                }(t469)}]\n        normal3f[] normals = [${Vm(n1181.normal, i847)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${Vm(n1181.position, i847)}]\n        float2[] primvars:st = [${function(t, e1663) {
                                    if (void 0 === t) return console.warn("USDZExporter: UVs missing."), Array(e1663).fill("(0, 0)").join(", ");
                                    const n1183 = [];
                                    for(let e1662 = 0; e1662 < t.count; e1662++){
                                        const i848 = t.getX(e1662), r623 = t.getY(e1662);
                                        n1183.push(`(${i848.toPrecision(7)}, ${1 - r623.toPrecision(7)})`);
                                    }
                                    return n1183.join(", ");
                                }(n1181.uv, i847)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`;
                            }(t467)}\n}\n`;
                        }(r622);
                        e1657[a332] = function(t) {
                            let e1664 = zm();
                            return e1664 += t, Om(e1664);
                        }(t464);
                    }
                    s429.uuid in i846 || (i846[s429.uuid] = s429), n1180 += function(t472, e1665, n1184) {
                        const i849 = "Object_" + t472.id, r624 = function(t) {
                            const e1666 = t.elements;
                            return `( ${Hm(e1666, 0)}, ${Hm(e1666, 4)}, ${Hm(e1666, 8)}, ${Hm(e1666, 12)} )`;
                        }(t472.matrixWorld);
                        t472.matrixWorld.determinant() < 0 && console.warn("THREE.USDZExporter: USDZ does not support negative scales", t472);
                        return `def Xform "${i849}" (\n    prepend references = @./geometries/Geometry_${e1665.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${r624}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${n1184.id}>\n}\n\n`;
                    }(t468, r622, s429);
                } else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", t468);
            }
        }), n1180 += function(t, e1667) {
            const n1185 = [];
            for(const i850 in t){
                const r625 = t[i850];
                n1185.push(Gm(r625, e1667));
            }
            return `def "Materials"\n{\n${n1185.join("")}\n}\n\n`;
        }(i846, r621), e1657["model.usda"] = Om(n1180), n1180 = null;
        for(const t461 in r621){
            const n1186 = r621[t461], i851 = t461.split("_")[1], s430 = 1023 === n1186.format, a333 = Bm(n1186.image, i851), o254 = await new Promise((t)=>a333.toBlob(t, s430 ? "image/png" : "image/jpeg", 1));
            e1657[`textures/Texture_${t461}.${s430 ? "png" : "jpg"}`] = new Uint8Array(await o254.arrayBuffer());
        }
        let s428 = 0;
        for(const t462 in e1657){
            const n1187 = e1657[t462];
            s428 += 34 + t462.length;
            const i852 = 63 & s428;
            if (4 !== i852) {
                const r626 = new Uint8Array(64 - i852);
                e1657[t462] = [
                    n1187,
                    {
                        extra: {
                            12345: r626
                        }
                    }
                ];
            }
            s428 = n1187.length;
        }
        return Um(e1657, {
            level: 0
        });
    }
}
function Bm(t, e1668) {
    if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
        const n1188 = 1024 / Math.max(t.width, t.height), i853 = document.createElement("canvas");
        i853.width = t.width * Math.min(1, n1188), i853.height = t.height * Math.min(1, n1188);
        const r627 = i853.getContext("2d");
        if (r627.drawImage(t, 0, 0, i853.width, i853.height), void 0 !== e1668) {
            const t = parseInt(e1668, 16), n1189 = (t >> 16 & 255) / 255, s431 = (t >> 8 & 255) / 255, a334 = (255 & t) / 255, o255 = r627.getImageData(0, 0, i853.width, i853.height), l207 = o255.data;
            for(let t473 = 0; t473 < l207.length; t473 += 4)l207[t473 + 0] = l207[t473 + 0] * n1189, l207[t473 + 1] = l207[t473 + 1] * s431, l207[t473 + 2] = l207[t473 + 2] * a334;
            r627.putImageData(o255, 0, 0);
        }
        return i853;
    }
}
function zm() {
    return '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
}
function Hm(t, e1669) {
    return `(${t[e1669 + 0]}, ${t[e1669 + 1]}, ${t[e1669 + 2]}, ${t[e1669 + 3]})`;
}
function Vm(t, e1671) {
    if (void 0 === t) return console.warn("USDZExporter: Normals missing."), Array(e1671).fill("(0, 0, 0)").join(", ");
    const n1190 = [];
    for(let e1670 = 0; e1670 < t.count; e1670++){
        const i854 = t.getX(e1670), r628 = t.getY(e1670), s432 = t.getZ(e1670);
        n1190.push(`(${i854.toPrecision(7)}, ${r628.toPrecision(7)}, ${s432.toPrecision(7)})`);
    }
    return n1190.join(", ");
}
function Gm(t, e1672) {
    const n1191 = "            ", i855 = [], r629 = [];
    function s433(n1192, i856, r630) {
        const s434 = n1192.id + (r630 ? "_" + r630.getHexString() : ""), a335 = 1023 === n1192.format;
        return e1672[s434] = n1192, `\n        def Shader "Transform2d_${i856}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${t.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${jm(n1192.repeat)}\n            float2 inputs:translation = ${jm(n1192.offset)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${n1192.id}_${i856}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${s434}.${a335 ? "png" : "jpg"}@\n            float2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${i856}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n            ${t.transparent || t.alphaTest > 0 ? "float outputs:a" : ""}\n        }`;
    }
    return null !== t.map ? (i855.push(`${n1191}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`), t.transparent ? i855.push(`${n1191}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`) : t.alphaTest > 0 && (i855.push(`${n1191}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:a>`), i855.push(`${n1191}float inputs:opacityThreshold = ${t.alphaTest}`)), r629.push(s433(t.map, "diffuse", t.color))) : i855.push(`${n1191}color3f inputs:diffuseColor = ${Wm(t.color)}`), null !== t.emissiveMap ? (i855.push(`${n1191}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`), r629.push(s433(t.emissiveMap, "emissive"))) : t.emissive.getHex() > 0 && i855.push(`${n1191}color3f inputs:emissiveColor = ${Wm(t.emissive)}`), null !== t.normalMap && (i855.push(`${n1191}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`), r629.push(s433(t.normalMap, "normal"))), null !== t.aoMap && (i855.push(`${n1191}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`), r629.push(s433(t.aoMap, "occlusion"))), null !== t.roughnessMap && 1 === t.roughness ? (i855.push(`${n1191}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`), r629.push(s433(t.roughnessMap, "roughness"))) : i855.push(`${n1191}float inputs:roughness = ${t.roughness}`), null !== t.metalnessMap && 1 === t.metalness ? (i855.push(`${n1191}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`), r629.push(s433(t.metalnessMap, "metallic"))) : i855.push(`${n1191}float inputs:metallic = ${t.metalness}`), null !== t.alphaMap ? (i855.push(`${n1191}float inputs:opacity.connect = </Materials/Material_${t.id}/Texture_${t.alphaMap.id}_opacity.outputs:r>`), i855.push(`${n1191}float inputs:opacityThreshold = 0.0001`), r629.push(s433(t.alphaMap, "opacity"))) : i855.push(`${n1191}float inputs:opacity = ${t.opacity}`), t.isMeshPhysicalMaterial && (i855.push(`${n1191}float inputs:clearcoat = ${t.clearcoat}`), i855.push(`${n1191}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`), i855.push(`${n1191}float inputs:ior = ${t.ior}`)), `\n    def Material "Material_${t.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${i855.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${t.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${r629.join("\n")}\n\n    }\n`;
}
function Wm(t) {
    return `(${t.r}, ${t.g}, ${t.b})`;
}
function jm(t) {
    return `(${t.x}, ${t.y})`;
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var qm = function(t, e1673, n1193, i857) {
    for(var r631, s435 = arguments.length, a336 = s435 < 3 ? e1673 : null === i857 ? i857 = Object.getOwnPropertyDescriptor(e1673, n1193) : i857, o256 = t.length - 1; o256 >= 0; o256--)(r631 = t[o256]) && (a336 = (s435 < 3 ? r631(a336) : s435 > 3 ? r631(e1673, n1193, a336) : r631(e1673, n1193)) || a336);
    return s435 > 3 && a336 && Object.defineProperty(e1673, n1193, a336), a336;
};
let Xm = !1, $m = !1;
const Ym = (Jm = [
    "quick-look",
    "scene-viewer",
    "webxr",
    "none"
], (t475)=>{
    try {
        const e1674 = mu(t475), n1194 = (e1674.length ? e1674[0].terms : []).filter((t)=>t && "ident" === t.type).map((t)=>t.value).filter((t)=>Jm.indexOf(t) > -1), i858 = new Set;
        for (const t474 of n1194)i858.add(t474);
        return i858;
    } catch (t) {}
    return new Set;
});
var Jm;
const Km = "quick-look", Zm = "scene-viewer", Qm = "webxr", tf = "none", ef = Symbol("arButtonContainer"), nf = Symbol("enterARWithWebXR"), rf = Symbol("openSceneViewer"), sf = Symbol("openIOSARQuickLook"), af = Symbol("canActivateAR"), of = Symbol("arMode"), lf = Symbol("arModes"), hf = Symbol("arAnchor"), cf = Symbol("preload"), uf = Symbol("onARButtonContainerClick"), df = Symbol("onARStatus"), pf = Symbol("onARTracking"), mf = Symbol("onARTap"), ff = Symbol("selectARMode"), gf = Symbol("triggerLoad");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var vf, yf, xf;
const bf = Symbol("evaluate"), _f = Symbol("lastValue");
class wf {
    constructor(){
        this[vf] = null;
    }
    static evaluatableFor(t, e1675 = wu) {
        if (t instanceof wf) return t;
        if ("number" === t.type) return "%" === t.unit ? new Tf(t, e1675) : t;
        switch(t.name.value){
            case "calc":
                return new Lf(t, e1675);
            case "env":
                return new Af(t);
        }
        return wu;
    }
    static evaluate(t) {
        return t instanceof wf ? t.evaluate() : t;
    }
    static isConstant(t) {
        return !(t instanceof wf) || t.isConstant;
    }
    static applyIntrinsics(t476, e1676) {
        const { basis: n1195 , keywords: i859  } = e1676, { auto: r632  } = i859;
        return n1195.map((e1677, n1196)=>{
            const s436 = null == r632[n1196] ? e1677 : r632[n1196];
            let a337 = t476[n1196] ? t476[n1196] : s436;
            if ("ident" === a337.type) {
                const t = a337.value;
                t in i859 && (a337 = i859[t][n1196]);
            }
            return null != a337 && "ident" !== a337.type || (a337 = s436), "%" === a337.unit ? pu(a337.number / 100 * e1677.number, e1677.unit) : (a337 = Tu(a337, e1677), a337.unit !== e1677.unit ? e1677 : a337);
        });
    }
    get isConstant() {
        return !1;
    }
    evaluate() {
        return this.isConstant && null != this[_f] || (this[_f] = this[bf]()), this[_f];
    }
}
vf = _f;
const Mf = Symbol("percentage"), Sf = Symbol("basis");
class Tf extends wf {
    constructor(t, e1678){
        super(), this[Mf] = t, this[Sf] = e1678;
    }
    get isConstant() {
        return !0;
    }
    [bf]() {
        return pu(this[Mf].number / 100 * this[Sf].number, this[Sf].unit);
    }
}
const Ef = Symbol("identNode");
class Af extends wf {
    constructor(t){
        super(), this[yf] = null;
        const e1679 = t.arguments.length ? t.arguments[0].terms[0] : null;
        null != e1679 && "ident" === e1679.type && (this[Ef] = e1679);
    }
    get isConstant() {
        return !1;
    }
    [(yf = Ef, bf)]() {
        if (null != this[Ef] && "window-scroll-y" === this[Ef].value) return {
            type: "number",
            number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0,
            unit: null
        };
        return wu;
    }
}
const Rf = /[\*\/]/, Cf = Symbol("evalutor");
class Lf extends wf {
    constructor(t, e1680 = wu){
        if (super(), this[xf] = null, 1 !== t.arguments.length) return;
        const n1197 = t.arguments[0].terms.slice(), i860 = [];
        for(; n1197.length;){
            const t = n1197.shift();
            if (i860.length > 0) {
                const n1198 = i860[i860.length - 1];
                if ("operator" === n1198.type && Rf.test(n1198.value)) {
                    const n1199 = i860.pop(), r633 = i860.pop();
                    if (null == r633) return;
                    i860.push(new Of(n1199, wf.evaluatableFor(r633, e1680), wf.evaluatableFor(t, e1680)));
                    continue;
                }
            }
            i860.push("operator" === t.type ? t : wf.evaluatableFor(t, e1680));
        }
        for(; i860.length > 2;){
            const [t, n1200, r634] = i860.splice(0, 3);
            if ("operator" !== n1200.type) return;
            i860.unshift(new Of(n1200, wf.evaluatableFor(t, e1680), wf.evaluatableFor(r634, e1680)));
        }
        1 === i860.length && (this[Cf] = i860[0]);
    }
    get isConstant() {
        return null == this[Cf] || wf.isConstant(this[Cf]);
    }
    [(xf = Cf, bf)]() {
        return null != this[Cf] ? wf.evaluate(this[Cf]) : wu;
    }
}
const Pf = Symbol("operator"), Df = Symbol("left"), If = Symbol("right");
class Of extends wf {
    constructor(t, e1681, n1201){
        super(), this[Pf] = t, this[Df] = e1681, this[If] = n1201;
    }
    get isConstant() {
        return wf.isConstant(this[Df]) && wf.isConstant(this[If]);
    }
    [bf]() {
        const t = Tu(wf.evaluate(this[Df])), e1682 = Tu(wf.evaluate(this[If])), { number: n1202 , unit: i861  } = t, { number: r635 , unit: s437  } = e1682;
        if (null != s437 && null != i861 && s437 != i861) return wu;
        const a338 = i861 || s437;
        let o257;
        switch(this[Pf].value){
            case "+":
                o257 = n1202 + r635;
                break;
            case "-":
                o257 = n1202 - r635;
                break;
            case "/":
                o257 = n1202 / r635;
                break;
            case "*":
                o257 = n1202 * r635;
                break;
            default:
                return wu;
        }
        return {
            type: "number",
            number: o257,
            unit: a338
        };
    }
}
const Nf = Symbol("evaluatables"), Ff = Symbol("intrinsics");
class Uf extends wf {
    constructor(t477, e1683){
        super(), this[Ff] = e1683;
        const n1203 = t477[0], i862 = null != n1203 ? n1203.terms : [];
        this[Nf] = e1683.basis.map((t, e1684)=>{
            const n1204 = i862[e1684];
            return null == n1204 ? {
                type: "ident",
                value: "auto"
            } : "ident" === n1204.type ? n1204 : wf.evaluatableFor(n1204, t);
        });
    }
    get isConstant() {
        for (const t of this[Nf])if (!wf.isConstant(t)) return !1;
        return !0;
    }
    [bf]() {
        const t478 = this[Nf].map((t)=>wf.evaluate(t));
        return wf.applyIntrinsics(t478, this[Ff]).map((t)=>t.number);
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var kf, Bf, zf, Hf;
const Vf = Symbol("instances"), Gf = Symbol("activateListener"), Wf = Symbol("deactivateListener"), jf = Symbol("notifyInstances"), qf = Symbol("notify"), Xf = Symbol("callback");
class $f {
    constructor(t){
        this[Xf] = t;
    }
    static [jf]() {
        for (const t of $f[Vf])t[qf]();
    }
    static [(kf = Vf, Gf)]() {
        window.addEventListener("scroll", this[jf], {
            passive: !0
        });
    }
    static [Wf]() {
        window.removeEventListener("scroll", this[jf]);
    }
    observe() {
        0 === $f[Vf].size && $f[Gf](), $f[Vf].add(this);
    }
    disconnect() {
        $f[Vf].delete(this), 0 === $f[Vf].size && $f[Wf]();
    }
    [qf]() {
        this[Xf]();
    }
}
$f[kf] = new Set;
const Yf = Symbol("computeStyleCallback"), Jf = Symbol("astWalker"), Kf = Symbol("dependencies"), Zf = Symbol("onScroll");
class Qf {
    constructor(t){
        this[Bf] = {}, this[zf] = new _u([
            "function"
        ]), this[Hf] = ()=>{
            this[Yf]({
                relatedState: "window-scroll"
            });
        }, this[Yf] = t;
    }
    observeEffectsFor(t480) {
        const e1685 = {}, n1205 = this[Kf];
        this[Jf].walk(t480, (t)=>{
            const { name: i863  } = t, r636 = t.arguments[0].terms[0];
            if ("env" === i863.value && null != r636 && "ident" === r636.type && "window-scroll-y" === r636.value) {
                if (null == e1685["window-scroll"]) {
                    const t = "window-scroll" in n1205 ? n1205["window-scroll"] : new $f(this[Zf]);
                    t.observe(), delete n1205["window-scroll"], e1685["window-scroll"] = t;
                }
            }
        });
        for(const t479 in n1205)n1205[t479].disconnect();
        this[Kf] = e1685;
    }
    dispose() {
        for(const t in this[Kf])this[Kf][t].disconnect();
    }
}
Bf = Kf, zf = Jf, Hf = Zf;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const tg = (t481)=>{
    const e1686 = t481.observeEffects || !1, n1206 = t481.intrinsics instanceof Function ? t481.intrinsics : ()=>t481.intrinsics;
    return (i864, r637)=>{
        const s438 = i864.updated, a339 = i864.connectedCallback, o258 = i864.disconnectedCallback, l208 = Symbol(`${r637}StyleEffector`), h165 = Symbol(`${r637}StyleEvaluator`), c122 = Symbol(`${r637}UpdateEvaluator`), u105 = Symbol(`${r637}EvaluateAndSync`);
        Object.defineProperties(i864, {
            [l208]: {
                value: null,
                writable: !0
            },
            [h165]: {
                value: null,
                writable: !0
            },
            [c122]: {
                value: function() {
                    const t = mu(this[r637]);
                    this[h165] = new Uf(t, n1206(this)), null == this[l208] && e1686 && (this[l208] = new Qf(()=>this[u105]())), null != this[l208] && this[l208].observeEffectsFor(t);
                }
            },
            [u105]: {
                value: function() {
                    if (null == this[h165]) return;
                    const e1687 = this[h165].evaluate();
                    this[t481.updateHandler](e1687);
                }
            },
            updated: {
                value: function(t) {
                    t.has(r637) && (this[c122](), this[u105]()), s438.call(this, t);
                }
            },
            connectedCallback: {
                value: function() {
                    a339.call(this), this.requestUpdate(r637, this[r637]);
                }
            },
            disconnectedCallback: {
                value: function() {
                    o258.call(this), null != this[l208] && (this[l208].dispose(), this[l208] = null);
                }
            }
        });
    };
}, eg = new g, ng = new V, ig = Object.freeze({
    minimumRadius: 0,
    maximumRadius: 1 / 0,
    minimumPolarAngle: Math.PI / 8,
    maximumPolarAngle: Math.PI - Math.PI / 8,
    minimumAzimuthalAngle: -1 / 0,
    maximumAzimuthalAngle: 1 / 0,
    minimumFieldOfView: 10,
    maximumFieldOfView: 45,
    interactionPolicy: "always-allow",
    touchAction: "pan-y"
}), rg = Math.PI / 8, sg = 33, ag = 34, og = 37, lg = 38, hg = 39, cg = 40, ug = "user-interaction", dg = "none";
/* @license
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ class pg extends i {
    constructor(t483, e1688, n1207){
        super(), this.camera = t483, this.element = e1688, this.scene = n1207, this.sensitivity = 1, this.isUserChange = !1, this._interactionEnabled = !1, this._disableZoom = !1, this.isUserPointing = !1, this.enablePan = !0, this.panProjection = new v, this.panPerPixel = 0, this.spherical = new Ko, this.goalSpherical = new Ko, this.thetaDamper = new du, this.phiDamper = new du, this.radiusDamper = new du, this.logFov = Math.log(ig.maximumFieldOfView), this.goalLogFov = this.logFov, this.fovDamper = new du, this.touchMode = null, this.pointers = [], this.startTime = 0, this.startPointerPosition = {
            clientX: 0,
            clientY: 0
        }, this.lastSeparation = 0, this.touchDecided = !1, this.onContext = (t)=>{
            if (this.enablePan) t.preventDefault();
            else for (const t482 of this.pointers)this.onPointerUp(new PointerEvent("pointercancel", Object.assign(Object.assign({}, this.startPointerPosition), {
                pointerId: t482.id
            })));
        }, this.touchModeZoom = (t, e1690)=>{
            if (!this._disableZoom) {
                const t = this.twoTouchDistance(this.pointers[0], this.pointers[1]), e1689 = .04 * (this.lastSeparation - t) * 50 / this.scene.height;
                this.lastSeparation = t, this.userAdjustOrbit(0, 0, e1689);
            }
            this.panPerPixel > 0 && this.movePan(t, e1690);
        }, this.disableScroll = (t)=>{
            t.preventDefault();
        }, this.touchModeRotate = (t, e1691)=>{
            const { touchAction: n1208  } = this._options;
            if (!this.touchDecided && "none" !== n1208) {
                this.touchDecided = !0;
                const i865 = Math.abs(t), r638 = Math.abs(e1691);
                if (this.isUserChange && ("pan-y" === n1208 && r638 > i865 || "pan-x" === n1208 && i865 > r638)) return void (this.touchMode = null);
                this.element.addEventListener("touchmove", this.disableScroll, {
                    passive: !1
                });
            }
            this.handleSinglePointerMove(t, e1691);
        }, this.onPointerDown = (t)=>{
            if (!this.canInteract || this.pointers.length > 2) return;
            const { element: e1692  } = this;
            0 === this.pointers.length && (e1692.addEventListener("pointermove", this.onPointerMove), e1692.addEventListener("pointerup", this.onPointerUp), this.touchMode = null, this.touchDecided = !1, this.startPointerPosition.clientX = t.clientX, this.startPointerPosition.clientY = t.clientY, this.startTime = performance.now());
            try {
                e1692.setPointerCapture(t.pointerId);
            } catch (t484) {}
            this.pointers.push({
                clientX: t.clientX,
                clientY: t.clientY,
                id: t.pointerId
            }), this.isUserPointing = !1, "touch" === t.pointerType ? (this.isUserChange = !t.altKey, this.onTouchChange(t)) : (this.isUserChange = !0, this.onMouseDown(t));
        }, this.onPointerMove = (t)=>{
            const e1693 = this.pointers.find((e1694)=>e1694.id === t.pointerId);
            if (null == e1693) return;
            const n1209 = this.pointers.length, i866 = (t.clientX - e1693.clientX) / n1209, r639 = (t.clientY - e1693.clientY) / n1209;
            0 === i866 && 0 === r639 || (e1693.clientX = t.clientX, e1693.clientY = t.clientY, "touch" === t.pointerType ? (this.isUserChange = !t.altKey, null !== this.touchMode && this.touchMode(i866, r639)) : (this.isUserChange = !0, this.panPerPixel > 0 ? this.movePan(i866, r639) : this.handleSinglePointerMove(i866, r639)));
        }, this.onPointerUp = (t)=>{
            const { element: e1695  } = this, n1210 = this.pointers.findIndex((e1696)=>e1696.id === t.pointerId);
            -1 !== n1210 && this.pointers.splice(n1210, 1), this.panPerPixel > 0 && !t.altKey && this.resetRadius(), 0 === this.pointers.length ? (e1695.removeEventListener("pointermove", this.onPointerMove), e1695.removeEventListener("pointerup", this.onPointerUp), e1695.removeEventListener("touchmove", this.disableScroll), this.enablePan && this.recenter(t)) : null !== this.touchMode && this.onTouchChange(t), this.scene.element[kg].style.opacity = 0, e1695.style.cursor = "grab", this.panPerPixel = 0, this.isUserPointing && this.dispatchEvent({
                type: "pointer-change-end"
            });
        }, this.onWheel = (t)=>{
            if (!this.canInteract) return;
            this.isUserChange = !0;
            const e1697 = t.deltaY * (1 == t.deltaMode ? 18 : 1) * .04 / 30;
            this.userAdjustOrbit(0, 0, e1697), t.preventDefault();
        }, this.onKeyDown = (t)=>{
            let e1698 = !0;
            const { isUserChange: n1211  } = this;
            switch(this.isUserChange = !0, t.keyCode){
                case sg:
                    this.userAdjustOrbit(0, 0, .04);
                    break;
                case ag:
                    this.userAdjustOrbit(0, 0, -0.04);
                    break;
                case lg:
                    this.userAdjustOrbit(0, -rg, 0);
                    break;
                case cg:
                    this.userAdjustOrbit(0, rg, 0);
                    break;
                case og:
                    this.userAdjustOrbit(-rg, 0, 0);
                    break;
                case hg:
                    this.userAdjustOrbit(rg, 0, 0);
                    break;
                default:
                    e1698 = !1, this.isUserChange = n1211;
            }
            e1698 && t.preventDefault();
        }, this._options = Object.assign({}, ig), this.setOrbit(0, Math.PI / 2, 1), this.setFieldOfView(100), this.jumpToGoal();
    }
    get interactionEnabled() {
        return this._interactionEnabled;
    }
    enableInteraction() {
        if (!1 === this._interactionEnabled) {
            const { element: t  } = this;
            t.addEventListener("pointerdown", this.onPointerDown), t.addEventListener("pointercancel", this.onPointerUp), this._disableZoom || t.addEventListener("wheel", this.onWheel), t.addEventListener("keydown", this.onKeyDown), t.addEventListener("touchmove", ()=>{}, {
                passive: !1
            }), t.addEventListener("contextmenu", this.onContext), this.element.style.cursor = "grab", this._interactionEnabled = !0, this.updateTouchActionStyle();
        }
    }
    disableInteraction() {
        if (!0 === this._interactionEnabled) {
            const { element: t  } = this;
            t.removeEventListener("pointerdown", this.onPointerDown), t.removeEventListener("pointermove", this.onPointerMove), t.removeEventListener("pointerup", this.onPointerUp), t.removeEventListener("pointercancel", this.onPointerUp), t.removeEventListener("wheel", this.onWheel), t.removeEventListener("keydown", this.onKeyDown), t.removeEventListener("contextmenu", this.onContext), t.style.cursor = "", this.touchMode = null, this._interactionEnabled = !1, this.updateTouchActionStyle();
        }
    }
    get options() {
        return this._options;
    }
    set disableZoom(t) {
        this._disableZoom != t && (this._disableZoom = t, !0 === t ? this.element.removeEventListener("wheel", this.onWheel) : this.element.addEventListener("wheel", this.onWheel), this.updateTouchActionStyle());
    }
    getCameraSpherical(t = new Ko) {
        return t.copy(this.spherical);
    }
    getFieldOfView() {
        return this.camera.fov;
    }
    applyOptions(t) {
        Object.assign(this._options, t), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov));
    }
    updateNearFar(t, e1699) {
        this.camera.near = Math.max(t, e1699 / 1e3), this.camera.far = e1699, this.camera.updateProjectionMatrix();
    }
    updateAspect(t) {
        this.camera.aspect = t, this.camera.updateProjectionMatrix();
    }
    setOrbit(t = this.goalSpherical.theta, e1700 = this.goalSpherical.phi, n1212 = this.goalSpherical.radius) {
        const { minimumAzimuthalAngle: i867 , maximumAzimuthalAngle: r640 , minimumPolarAngle: s439 , maximumPolarAngle: a340 , minimumRadius: o259 , maximumRadius: l209  } = this._options, { theta: h166 , phi: c123 , radius: u106  } = this.goalSpherical, d86 = lu(t, i867, r640);
        isFinite(i867) || isFinite(r640) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d86) + d86);
        const p75 = lu(e1700, s439, a340), m55 = lu(n1212, o259, l209);
        return (d86 !== h166 || p75 !== c123 || m55 !== u106) && (this.goalSpherical.theta = d86, this.goalSpherical.phi = p75, this.goalSpherical.radius = m55, this.goalSpherical.makeSafe(), !0);
    }
    setRadius(t) {
        this.goalSpherical.radius = t, this.setOrbit();
    }
    setFieldOfView(t) {
        const { minimumFieldOfView: e1701 , maximumFieldOfView: n1213  } = this._options;
        t = lu(t, e1701, n1213), this.goalLogFov = Math.log(t);
    }
    setDamperDecayTime(t) {
        this.thetaDamper.setDecayTime(t), this.phiDamper.setDecayTime(t), this.radiusDamper.setDecayTime(t), this.fovDamper.setDecayTime(t);
    }
    adjustOrbit(t, e1702, n1214) {
        const { theta: i868 , phi: r641 , radius: s440  } = this.goalSpherical, { minimumRadius: a341 , maximumRadius: o260 , minimumFieldOfView: l210 , maximumFieldOfView: h167  } = this._options, c124 = this.spherical.theta - i868, u107 = Math.PI - .001, d87 = i868 - lu(t, -u107 - c124, u107 - c124), p76 = r641 - e1702, m56 = 0 === n1214 ? 0 : ((n1214 > 0 ? o260 : a341) - s440) / (Math.log(n1214 > 0 ? h167 : l210) - this.goalLogFov), f48 = s440 + n1214 * (isFinite(m56) ? m56 : 2 * (o260 - a341));
        if (this.setOrbit(d87, p76, f48), 0 !== n1214) {
            const t = this.goalLogFov + n1214;
            this.setFieldOfView(Math.exp(t));
        }
    }
    jumpToGoal() {
        this.update(0, 1e4);
    }
    update(t, e1703) {
        if (this.isStationary()) return;
        const { maximumPolarAngle: n1215 , maximumRadius: i869  } = this._options, r642 = this.spherical.theta - this.goalSpherical.theta;
        Math.abs(r642) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle) && (this.spherical.theta -= 2 * Math.sign(r642) * Math.PI), this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, e1703, Math.PI), this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, e1703, n1215), this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, e1703, i869), this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, e1703, 1), this.moveCamera();
    }
    updateTouchActionStyle() {
        const { style: t  } = this.element;
        if (this._interactionEnabled) {
            const { touchAction: e1704  } = this._options;
            this._disableZoom && "none" !== e1704 ? t.touchAction = "manipulation" : t.touchAction = e1704;
        } else t.touchAction = "";
    }
    isStationary() {
        return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;
    }
    dispatchChange() {
        const t = this.isUserChange ? ug : dg;
        this.dispatchEvent({
            type: "change",
            source: t
        });
    }
    moveCamera() {
        this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new Ct(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov), this.camera.updateProjectionMatrix()), this.dispatchChange();
    }
    get canInteract() {
        if ("allow-when-focused" == this._options.interactionPolicy) return this.element.getRootNode().activeElement === this.element;
        return "always-allow" === this._options.interactionPolicy;
    }
    userAdjustOrbit(t, e1705, n1216) {
        this.adjustOrbit(t * this.sensitivity, e1705 * this.sensitivity, n1216), this.dispatchChange();
    }
    wrapAngle(t) {
        const e1706 = (t + Math.PI) / (2 * Math.PI);
        return 2 * (e1706 - Math.floor(e1706)) * Math.PI - Math.PI;
    }
    pixelLengthToSphericalAngle(t) {
        return 2 * Math.PI * t / this.element.clientHeight;
    }
    twoTouchDistance(t, e1707) {
        const { clientX: n1217 , clientY: i870  } = t, { clientX: r643 , clientY: s441  } = e1707, a342 = r643 - n1217, o261 = s441 - i870;
        return Math.sqrt(a342 * a342 + o261 * o261);
    }
    handleSinglePointerMove(t, e1708) {
        const n1218 = this.pixelLengthToSphericalAngle(t), i871 = this.pixelLengthToSphericalAngle(e1708);
        !1 === this.isUserPointing && (this.isUserPointing = !0, this.dispatchEvent({
            type: "pointer-change-start"
        })), this.userAdjustOrbit(n1218, i871, 0);
    }
    initializePan() {
        const { theta: t , phi: e1709  } = this.spherical, n1219 = t - this.scene.yaw;
        this.panPerPixel = .018 / this.scene.height, this.panProjection.set(-Math.cos(n1219), -Math.cos(e1709) * Math.sin(n1219), 0, 0, Math.sin(e1709), 0, Math.sin(n1219), -Math.cos(e1709) * Math.cos(n1219), 0);
    }
    movePan(t, e1710) {
        const { scene: n1220  } = this, i872 = ng.set(t, e1710, 0), r644 = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;
        i872.multiplyScalar(r644);
        const s442 = n1220.getTarget();
        s442.add(i872.applyMatrix3(this.panProjection)), n1220.boundingSphere.clampPoint(s442, s442), n1220.setTarget(s442.x, s442.y, s442.z), this.dispatchChange();
    }
    recenter(t) {
        if (performance.now() > this.startTime + 300 || Math.abs(t.clientX - this.startPointerPosition.clientX) > 2 || Math.abs(t.clientY - this.startPointerPosition.clientY) > 2) return;
        const { scene: e1711  } = this, n1221 = e1711.positionAndNormalFromPoint(e1711.getNDC(t.clientX, t.clientY));
        if (null == n1221) {
            const { cameraTarget: t  } = e1711.element;
            e1711.element.cameraTarget = "", e1711.element.cameraTarget = t, this.userAdjustOrbit(0, 0, 1);
        } else e1711.target.worldToLocal(n1221.position), e1711.setTarget(n1221.position.x, n1221.position.y, n1221.position.z);
    }
    resetRadius() {
        const { scene: t  } = this, e1712 = t.positionAndNormalFromPoint(eg.set(0, 0));
        if (null == e1712) return;
        t.target.worldToLocal(e1712.position);
        const n1222 = t.getTarget(), { theta: i873 , phi: r645  } = this.spherical, s443 = i873 - t.yaw, a343 = ng.set(Math.sin(r645) * Math.sin(s443), Math.cos(r645), Math.sin(r645) * Math.cos(s443)), o262 = a343.dot(e1712.position.sub(n1222));
        n1222.add(a343.multiplyScalar(o262)), t.setTarget(n1222.x, n1222.y, n1222.z), this.setOrbit(void 0, void 0, this.goalSpherical.radius - o262);
    }
    onTouchChange(t) {
        if (1 === this.pointers.length) this.touchMode = this.touchModeRotate;
        else {
            if (this._disableZoom) return this.touchMode = null, void this.element.removeEventListener("touchmove", this.disableScroll);
            this.touchMode = this.touchDecided && null === this.touchMode ? null : this.touchModeZoom, this.touchDecided = !0, this.element.addEventListener("touchmove", this.disableScroll, {
                passive: !1
            }), this.lastSeparation = this.twoTouchDistance(this.pointers[0], this.pointers[1]), this.enablePan && null != this.touchMode && (this.initializePan(), t.altKey || (this.scene.element[kg].style.opacity = 1));
        }
    }
    onMouseDown(t) {
        this.panPerPixel = 0, this.enablePan && (2 === t.button || t.ctrlKey || t.metaKey || t.shiftKey) && (this.initializePan(), this.scene.element[kg].style.opacity = 1), this.element.style.cursor = "grabbing";
    }
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const mg = (t)=>t < .5 ? 2 * t * t : (4 - 2 * t) * t - 1, fg = (t, e1713, n1223 = mg)=>(i874)=>t + (e1713 - t) * n1223(i874), gg = (t485)=>{
    const e1714 = [], n1224 = [];
    let i875 = t485.initialValue;
    for(let r646 = 0; r646 < t485.keyframes.length; ++r646){
        const s444 = t485.keyframes[r646], { value: a344 , frames: o263  } = s444, l211 = s444.ease || mg, h168 = fg(i875, a344, l211);
        e1714.push(h168), n1224.push(o263), i875 = a344;
    }
    return ((t486, e1715)=>{
        const n1225 = e1715.map((i876 = 0, (t)=>i876 += t));
        var i876;
        return (e1716)=>{
            e1716 = lu(e1716, 0, 1), e1716 *= n1225[n1225.length - 1];
            const i877 = n1225.findIndex((t)=>t >= e1716), r647 = i877 < 1 ? 0 : n1225[i877 - 1], s445 = n1225[i877];
            return t486[i877]((e1716 - r647) / (s445 - r647));
        };
    })(e1714, n1224);
};
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var vg = function(t, e1717, n1226, i878) {
    for(var r648, s446 = arguments.length, a345 = s446 < 3 ? e1717 : null === i878 ? i878 = Object.getOwnPropertyDescriptor(e1717, n1226) : i878, o264 = t.length - 1; o264 >= 0; o264--)(r648 = t[o264]) && (a345 = (s446 < 3 ? r648(a345) : s446 > 3 ? r648(e1717, n1226, a345) : r648(e1717, n1226)) || a345);
    return s446 > 3 && a345 && Object.defineProperty(e1717, n1226, a345), a345;
};
const yg = gg({
    initialValue: 0,
    keyframes: [
        {
            frames: 5,
            value: -1
        },
        {
            frames: 1,
            value: -1
        },
        {
            frames: 8,
            value: 1
        },
        {
            frames: 1,
            value: 1
        },
        {
            frames: 5,
            value: 0
        },
        {
            frames: 18,
            value: 0
        }
    ]
}), xg = gg({
    initialValue: 0,
    keyframes: [
        {
            frames: 1,
            value: 1
        },
        {
            frames: 5,
            value: 1
        },
        {
            frames: 1,
            value: 0
        },
        {
            frames: 6,
            value: 0
        }
    ]
}), bg = [
    "front",
    "right",
    "back",
    "left"
], _g = [
    "upper-",
    "",
    "lower-"
], wg = "auto", Mg = "when-focused", Sg = "wiggle", Tg = "always-allow", Eg = "pan-y", Ag = (t)=>{
    const e1718 = t.enablePan ? 30 : 45;
    return {
        basis: [
            Mu(pu(e1718, "deg"))
        ],
        keywords: {
            auto: [
                null
            ]
        }
    };
}, Rg = (t)=>{
    const e1719 = t.enablePan ? 12 : 25;
    return {
        basis: [
            Mu(pu(e1719, "deg"))
        ],
        keywords: {
            auto: [
                null
            ]
        }
    };
}, Cg = (()=>{
    const t487 = mu("0deg 75deg 105%")[0].terms, e1720 = Tu(t487[0]), n1227 = Tu(t487[1]);
    return (t)=>{
        const i879 = t[_p].idealCameraDistance();
        return {
            basis: [
                e1720,
                n1227,
                pu(i879, "m")
            ],
            keywords: {
                auto: [
                    null,
                    null,
                    pu(105, "%")
                ]
            }
        };
    };
})(), Lg = (t)=>{
    const e1721 = 1.1 * t[_p].boundingSphere.radius * (t.enablePan ? 2 : 1);
    return {
        basis: [
            pu(-1 / 0, "rad"),
            pu(Math.PI / 8, "rad"),
            pu(e1721, "m")
        ],
        keywords: {
            auto: [
                null,
                null,
                null
            ]
        }
    };
}, Pg = (t)=>{
    const e1722 = Cg(t), n1228 = new Uf([], e1722).evaluate()[2];
    return {
        basis: [
            pu(1 / 0, "rad"),
            pu(Math.PI - Math.PI / 8, "rad"),
            pu(n1228, "m")
        ],
        keywords: {
            auto: [
                null,
                null,
                null
            ]
        }
    };
}, Dg = (t)=>{
    const e1723 = t[_p].boundingBox.getCenter(new V);
    return {
        basis: [
            pu(e1723.x, "m"),
            pu(e1723.y, "m"),
            pu(e1723.z, "m")
        ],
        keywords: {
            auto: [
                null,
                null,
                null
            ]
        }
    };
}, Ig = Math.PI / 2, Og = Math.PI / 3, Ng = Ig / 2, Fg = 2 * Math.PI, Ug = Symbol("controls"), kg = Symbol("panElement"), Bg = Symbol("promptElement"), zg = Symbol("promptAnimatedContainer"), Hg = Symbol("fingerAnimatedContainers"), Vg = Symbol("deferInteractionPrompt"), Gg = Symbol("updateAria"), Wg = Symbol("updateCameraForRadius"), jg = Symbol("onBlur"), qg = Symbol("onFocus"), Xg = Symbol("onChange"), $g = Symbol("onPointerChange"), Yg = Symbol("waitingToPromptUser"), Jg = Symbol("userHasInteracted"), Kg = Symbol("promptElementVisibleTime"), Zg = Symbol("lastPromptOffset"), Qg = Symbol("focusedTime"), tv = Symbol("lastSpherical"), ev = Symbol("jumpCamera"), nv = Symbol("initialized"), iv = Symbol("maintainThetaPhi"), rv = Symbol("syncCameraOrbit"), sv = Symbol("syncFieldOfView"), av = Symbol("syncCameraTarget"), ov = Symbol("syncMinCameraOrbit"), lv = Symbol("syncMaxCameraOrbit"), hv = Symbol("syncMinFieldOfView"), cv = Symbol("syncMaxFieldOfView");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var uv = function(t, e1724, n1229, i880) {
    for(var r649, s447 = arguments.length, a346 = s447 < 3 ? e1724 : null === i880 ? i880 = Object.getOwnPropertyDescriptor(e1724, n1229) : i880, o265 = t.length - 1; o265 >= 0; o265--)(r649 = t[o265]) && (a346 = (s447 < 3 ? r649(a346) : s447 > 3 ? r649(e1724, n1229, a346) : r649(e1724, n1229)) || a346);
    return s447 > 3 && a346 && Object.defineProperty(e1724, n1229, a346), a346;
};
const dv = "auto", pv = "manual", mv = "auto", fv = "eager", gv = "interaction", vv = Symbol("defaultProgressBarElement"), yv = Symbol("defaultProgressMaskElement"), xv = Symbol("posterContainerElement"), bv = Symbol("defaultPosterElement"), _v = Symbol("posterDismissalSource"), wv = Symbol("hidePoster"), Mv = Symbol("modelIsRevealed"), Sv = Symbol("updateProgressBar"), Tv = Symbol("lastReportedProgress"), Ev = Symbol("transitioned"), Av = Symbol("onTransitionEnd"), Rv = Symbol("ariaLabelCallToAction"), Cv = Symbol("onClick"), Lv = Symbol("onKeydown"), Pv = Symbol("onProgress");
class Dv {
    constructor(){
        this.pluginCallbacks = [], this.register(function(t) {
            return new ay(t);
        }), this.register(function(t) {
            return new oy(t);
        }), this.register(function(t) {
            return new ly(t);
        }), this.register(function(t) {
            return new cy(t);
        }), this.register(function(t) {
            return new uy(t);
        }), this.register(function(t) {
            return new hy(t);
        });
    }
    register(t) {
        return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this;
    }
    unregister(t) {
        return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
    }
    parse(t, e1726, n1230, i881) {
        "object" == typeof n1230 && (console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."), i881 = n1230);
        const r650 = new sy, s448 = [];
        for(let t488 = 0, e1725 = this.pluginCallbacks.length; t488 < e1725; t488++)s448.push(this.pluginCallbacks[t488](r650));
        r650.setPlugins(s448), r650.write(t, e1726, i881).catch(n1230);
    }
    parseAsync(t, e1727) {
        const n1231 = this;
        return new Promise(function(i882, r651) {
            n1231.parse(t, i882, r651, e1727);
        });
    }
}
const Iv = 0, Ov = 1, Nv = 2, Fv = 3, Uv = 4, kv = 5121, Bv = 5123, zv = 5126, Hv = 5125, Vv = 34962, Gv = 34963, Wv = 9728, jv = 9729, qv = 9984, Xv = 9985, $v = 9986, Yv = 9987, Jv = 33071, Kv = 33648, Zv = 10497, Qv = {};
Qv[1003] = Wv, Qv[1004] = qv, Qv[1005] = $v, Qv[1006] = jv, Qv[1007] = Xv, Qv[1008] = Yv, Qv[1001] = Jv, Qv[1e3] = Zv, Qv[1002] = Kv;
const ty = {
    scale: "scale",
    position: "translation",
    quaternion: "rotation",
    morphTargetInfluences: "weights"
};
function ey(t489, e1728) {
    return t489.length === e1728.length && t489.every(function(t, n1232) {
        return t === e1728[n1232];
    });
}
function ny(t) {
    return 4 * Math.ceil(t / 4);
}
function iy(t, e1729 = 0) {
    const n1233 = ny(t.byteLength);
    if (n1233 !== t.byteLength) {
        const i883 = new Uint8Array(n1233);
        if (i883.set(new Uint8Array(t)), 0 !== e1729) for(let r652 = t.byteLength; r652 < n1233; r652++)i883[r652] = e1729;
        return i883.buffer;
    }
    return t;
}
let ry = null;
class sy {
    constructor(){
        this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map, this.skins = [], this.extensionsUsed = {}, this.uids = new Map, this.uid = 0, this.json = {
            asset: {
                version: "2.0",
                generator: "THREE.GLTFExporter"
            }
        }, this.cache = {
            meshes: new Map,
            attributes: new Map,
            attributesNormalized: new Map,
            materials: new Map,
            textures: new Map,
            images: new Map
        };
    }
    setPlugins(t) {
        this.plugins = t;
    }
    async write(t491, e1730, n1234) {
        this.options = Object.assign({}, {
            binary: !1,
            trs: !1,
            onlyVisible: !0,
            truncateDrawRange: !0,
            embedImages: !0,
            maxTextureSize: 1 / 0,
            animations: [],
            includeCustomExtensions: !1
        }, n1234), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(t491), await Promise.all(this.pending);
        const i884 = this, r653 = i884.buffers, s449 = i884.json;
        n1234 = i884.options;
        const a347 = i884.extensionsUsed, o266 = new Blob(r653, {
            type: "application/octet-stream"
        }), l212 = Object.keys(a347);
        if (l212.length > 0 && (s449.extensionsUsed = l212), s449.buffers && s449.buffers.length > 0 && (s449.buffers[0].byteLength = o266.size), !0 === n1234.binary) {
            const t490 = new window.FileReader;
            t490.readAsArrayBuffer(o266), t490.onloadend = function() {
                const n1235 = iy(t490.result), i885 = new DataView(new ArrayBuffer(8));
                i885.setUint32(0, n1235.byteLength, !0), i885.setUint32(4, 5130562, !0);
                const r654 = iy(function(t) {
                    if (void 0 !== window.TextEncoder) return (new TextEncoder).encode(t).buffer;
                    const e1731 = new Uint8Array(new ArrayBuffer(t.length));
                    for(let n1236 = 0, i886 = t.length; n1236 < i886; n1236++){
                        const i887 = t.charCodeAt(n1236);
                        e1731[n1236] = i887 > 255 ? 32 : i887;
                    }
                    return e1731.buffer;
                }(JSON.stringify(s449)), 32), a348 = new DataView(new ArrayBuffer(8));
                a348.setUint32(0, r654.byteLength, !0), a348.setUint32(4, 1313821514, !0);
                const o267 = new ArrayBuffer(12), l213 = new DataView(o267);
                l213.setUint32(0, 1179937895, !0), l213.setUint32(4, 2, !0);
                const h169 = 12 + a348.byteLength + r654.byteLength + i885.byteLength + n1235.byteLength;
                l213.setUint32(8, h169, !0);
                const c125 = new Blob([
                    o267,
                    a348,
                    r654,
                    i885,
                    n1235
                ], {
                    type: "application/octet-stream"
                }), u108 = new window.FileReader;
                u108.readAsArrayBuffer(c125), u108.onloadend = function() {
                    e1730(u108.result);
                };
            };
        } else if (s449.buffers && s449.buffers.length > 0) {
            const t = new window.FileReader;
            t.readAsDataURL(o266), t.onloadend = function() {
                const n1237 = t.result;
                s449.buffers[0].uri = n1237, e1730(s449);
            };
        } else e1730(s449);
    }
    serializeUserData(t, e1732) {
        if (0 === Object.keys(t.userData).length) return;
        const n1238 = this.options, i888 = this.extensionsUsed;
        try {
            const r655 = JSON.parse(JSON.stringify(t.userData));
            if (n1238.includeCustomExtensions && r655.gltfExtensions) {
                void 0 === e1732.extensions && (e1732.extensions = {});
                for(const t in r655.gltfExtensions)e1732.extensions[t] = r655.gltfExtensions[t], i888[t] = !0;
                delete r655.gltfExtensions;
            }
            Object.keys(r655).length > 0 && (e1732.extras = r655);
        } catch (e1733) {
            console.warn("THREE.GLTFExporter: userData of '" + t.name + "' won't be serialized because of JSON.stringify error - " + e1733.message);
        }
    }
    getUID(t) {
        return this.uids.has(t) || this.uids.set(t, this.uid++), this.uids.get(t);
    }
    isNormalizedNormalAttribute(t) {
        if (this.cache.attributesNormalized.has(t)) return !1;
        const e1734 = new V;
        for(let n1239 = 0, i889 = t.count; n1239 < i889; n1239++)if (Math.abs(e1734.fromBufferAttribute(t, n1239).length() - 1) > 5e-4) return !1;
        return !0;
    }
    createNormalizedNormalAttribute(t) {
        const e1736 = this.cache;
        if (e1736.attributesNormalized.has(t)) return e1736.attributesNormalized.get(t);
        const n1240 = t.clone(), i890 = new V;
        for(let t492 = 0, e1735 = n1240.count; t492 < e1735; t492++)i890.fromBufferAttribute(n1240, t492), 0 === i890.x && 0 === i890.y && 0 === i890.z ? i890.setX(1) : i890.normalize(), n1240.setXYZ(t492, i890.x, i890.y, i890.z);
        return e1736.attributesNormalized.set(t, n1240), n1240;
    }
    applyTextureTransform(t, e1737) {
        let n1241 = !1;
        const i891 = {};
        0 === e1737.offset.x && 0 === e1737.offset.y || (i891.offset = e1737.offset.toArray(), n1241 = !0), 0 !== e1737.rotation && (i891.rotation = e1737.rotation, n1241 = !0), 1 === e1737.repeat.x && 1 === e1737.repeat.y || (i891.scale = e1737.repeat.toArray(), n1241 = !0), n1241 && (t.extensions = t.extensions || {}, t.extensions.KHR_texture_transform = i891, this.extensionsUsed.KHR_texture_transform = !0);
    }
    buildMetalRoughTexture(t, e1738) {
        if (t === e1738) return t;
        console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");
        const n1242 = t?.image, i892 = e1738?.image, r656 = Math.max(n1242?.width || 0, i892?.width || 0), s450 = Math.max(n1242?.height || 0, i892?.height || 0), a349 = document.createElement("canvas");
        a349.width = r656, a349.height = s450;
        const o268 = a349.getContext("2d");
        o268.fillStyle = "#00ffff", o268.fillRect(0, 0, r656, s450);
        const l214 = o268.getImageData(0, 0, r656, s450);
        if (n1242) {
            o268.drawImage(n1242, 0, 0, r656, s450);
            const t = o268.getImageData(0, 0, r656, s450).data;
            for(let e1739 = 2; e1739 < t.length; e1739 += 4)l214.data[e1739] = t[e1739];
        }
        if (i892) {
            o268.drawImage(i892, 0, 0, r656, s450);
            const t = o268.getImageData(0, 0, r656, s450).data;
            for(let e1740 = 1; e1740 < t.length; e1740 += 4)l214.data[e1740] = t[e1740];
        }
        o268.putImageData(l214, 0, 0);
        const h170 = (t || e1738).clone();
        return h170.source = new I(a349), h170;
    }
    processBuffer(t) {
        const e1741 = this.json, n1243 = this.buffers;
        return e1741.buffers || (e1741.buffers = [
            {
                byteLength: 0
            }
        ]), n1243.push(t), 0;
    }
    processBufferView(t, e1742, n1245, i893, r658) {
        const s451 = this.json;
        let a350;
        s451.bufferViews || (s451.bufferViews = []), a350 = e1742 === kv ? 1 : e1742 === Bv ? 2 : 4;
        const o269 = ny(i893 * t.itemSize * a350), l215 = new DataView(new ArrayBuffer(o269));
        let h171 = 0;
        for(let r657 = n1245; r657 < n1245 + i893; r657++)for(let n1244 = 0; n1244 < t.itemSize; n1244++){
            let i894;
            t.itemSize > 4 ? i894 = t.array[r657 * t.itemSize + n1244] : 0 === n1244 ? i894 = t.getX(r657) : 1 === n1244 ? i894 = t.getY(r657) : 2 === n1244 ? i894 = t.getZ(r657) : 3 === n1244 && (i894 = t.getW(r657)), e1742 === zv ? l215.setFloat32(h171, i894, !0) : e1742 === Hv ? l215.setUint32(h171, i894, !0) : e1742 === Bv ? l215.setUint16(h171, i894, !0) : e1742 === kv && l215.setUint8(h171, i894), h171 += a350;
        }
        const c126 = {
            buffer: this.processBuffer(l215.buffer),
            byteOffset: this.byteOffset,
            byteLength: o269
        };
        void 0 !== r658 && (c126.target = r658), r658 === Vv && (c126.byteStride = t.itemSize * a350), this.byteOffset += o269, s451.bufferViews.push(c126);
        return {
            id: s451.bufferViews.length - 1,
            byteLength: 0
        };
    }
    processBufferViewImage(t493) {
        const e1743 = this, n1246 = e1743.json;
        return n1246.bufferViews || (n1246.bufferViews = []), new Promise(function(i895) {
            const r659 = new window.FileReader;
            r659.readAsArrayBuffer(t493), r659.onloadend = function() {
                const t = iy(r659.result), s452 = {
                    buffer: e1743.processBuffer(t),
                    byteOffset: e1743.byteOffset,
                    byteLength: t.byteLength
                };
                e1743.byteOffset += t.byteLength, i895(n1246.bufferViews.push(s452) - 1);
            };
        });
    }
    processAccessor(t494, e1744, n1247, i896) {
        const r660 = this.options, s454 = this.json;
        let a351;
        if (t494.array.constructor === Float32Array) a351 = zv;
        else if (t494.array.constructor === Uint32Array) a351 = Hv;
        else if (t494.array.constructor === Uint16Array) a351 = Bv;
        else {
            if (t494.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
            a351 = kv;
        }
        if (void 0 === n1247 && (n1247 = 0), void 0 === i896 && (i896 = t494.count), r660.truncateDrawRange && void 0 !== e1744 && null === e1744.index) {
            const r661 = n1247 + i896, s453 = e1744.drawRange.count === 1 / 0 ? t494.count : e1744.drawRange.start + e1744.drawRange.count;
            n1247 = Math.max(n1247, e1744.drawRange.start), (i896 = Math.min(r661, s453) - n1247) < 0 && (i896 = 0);
        }
        if (0 === i896) return null;
        const o270 = function(t, e1746, n1248) {
            const i897 = {
                min: new Array(t.itemSize).fill(Number.POSITIVE_INFINITY),
                max: new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY)
            };
            for(let r662 = e1746; r662 < e1746 + n1248; r662++)for(let e1745 = 0; e1745 < t.itemSize; e1745++){
                let n1249;
                t.itemSize > 4 ? n1249 = t.array[r662 * t.itemSize + e1745] : 0 === e1745 ? n1249 = t.getX(r662) : 1 === e1745 ? n1249 = t.getY(r662) : 2 === e1745 ? n1249 = t.getZ(r662) : 3 === e1745 && (n1249 = t.getW(r662)), i897.min[e1745] = Math.min(i897.min[e1745], n1249), i897.max[e1745] = Math.max(i897.max[e1745], n1249);
            }
            return i897;
        }(t494, n1247, i896);
        let l216;
        void 0 !== e1744 && (l216 = t494 === e1744.index ? Gv : Vv);
        const h172 = this.processBufferView(t494, a351, n1247, i896, l216), c127 = {
            bufferView: h172.id,
            byteOffset: h172.byteOffset,
            componentType: a351,
            count: i896,
            max: o270.max,
            min: o270.min,
            type: {
                1: "SCALAR",
                2: "VEC2",
                3: "VEC3",
                4: "VEC4",
                16: "MAT4"
            }[t494.itemSize]
        };
        return !0 === t494.normalized && (c127.normalized = !0), s454.accessors || (s454.accessors = []), s454.accessors.push(c127) - 1;
    }
    processImage(t495, e1749, n1250, i898 = "image/png") {
        const r663 = this, s455 = r663.cache, a352 = r663.json, o271 = r663.options, l217 = r663.pending;
        s455.images.has(t495) || s455.images.set(t495, {});
        const h173 = s455.images.get(t495), c128 = i898 + ":flipY/" + n1250.toString();
        if (void 0 !== h173[c128]) return h173[c128];
        a352.images || (a352.images = []);
        const u109 = {
            mimeType: i898
        };
        if (o271.embedImages) {
            const s456 = ry = ry || document.createElement("canvas");
            s456.width = Math.min(t495.width, o271.maxTextureSize), s456.height = Math.min(t495.height, o271.maxTextureSize);
            const a353 = s456.getContext("2d");
            if (!0 === n1250 && (a353.translate(0, s456.height), a353.scale(1, -1)), "undefined" != typeof HTMLImageElement && t495 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t495 instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && t495 instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t495 instanceof ImageBitmap) a353.drawImage(t495, 0, 0, s456.width, s456.height);
            else {
                1023 !== e1749 && console.error("GLTFExporter: Only RGBAFormat is supported."), (t495.width > o271.maxTextureSize || t495.height > o271.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", t495);
                const n1251 = new Uint8ClampedArray(t495.height * t495.width * 4);
                for(let e1747 = 0; e1747 < n1251.length; e1747 += 4)n1251[e1747 + 0] = t495.data[e1747 + 0], n1251[e1747 + 1] = t495.data[e1747 + 1], n1251[e1747 + 2] = t495.data[e1747 + 2], n1251[e1747 + 3] = t495.data[e1747 + 3];
                a353.putImageData(new ImageData(n1251, t495.width, t495.height), 0, 0);
            }
            !0 === o271.binary ? l217.push(new Promise(function(t) {
                s456.toBlob(function(e1750) {
                    r663.processBufferViewImage(e1750).then(function(e1751) {
                        u109.bufferView = e1751, t();
                    });
                }, i898);
            })) : u109.uri = s456.toDataURL(i898);
        } else u109.uri = t495.src;
        const d88 = a352.images.push(u109) - 1;
        return h173[c128] = d88, d88;
    }
    processSampler(t) {
        const e1752 = this.json;
        e1752.samplers || (e1752.samplers = []);
        const n1252 = {
            magFilter: Qv[t.magFilter],
            minFilter: Qv[t.minFilter],
            wrapS: Qv[t.wrapS],
            wrapT: Qv[t.wrapT]
        };
        return e1752.samplers.push(n1252) - 1;
    }
    processTexture(t) {
        const e1753 = this.cache, n1253 = this.json;
        if (e1753.textures.has(t)) return e1753.textures.get(t);
        n1253.textures || (n1253.textures = []);
        let i899 = t.userData.mimeType;
        "image/webp" === i899 && (i899 = "image/png");
        const r664 = {
            sampler: this.processSampler(t),
            source: this.processImage(t.image, t.format, t.flipY, i899)
        };
        t.name && (r664.name = t.name), this._invokeAll(function(e1754) {
            e1754.writeTexture && e1754.writeTexture(t, r664);
        });
        const s457 = n1253.textures.push(r664) - 1;
        return e1753.textures.set(t, s457), s457;
    }
    processMaterial(t) {
        const e1755 = this.cache, n1254 = this.json;
        if (e1755.materials.has(t)) return e1755.materials.get(t);
        if (t.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
        n1254.materials || (n1254.materials = []);
        const i900 = {
            pbrMetallicRoughness: {}
        };
        !0 !== t.isMeshStandardMaterial && !0 !== t.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
        const r665 = t.color.toArray().concat([
            t.opacity
        ]);
        if (ey(r665, [
            1,
            1,
            1,
            1
        ]) || (i900.pbrMetallicRoughness.baseColorFactor = r665), t.isMeshStandardMaterial ? (i900.pbrMetallicRoughness.metallicFactor = t.metalness, i900.pbrMetallicRoughness.roughnessFactor = t.roughness) : (i900.pbrMetallicRoughness.metallicFactor = .5, i900.pbrMetallicRoughness.roughnessFactor = .5), t.metalnessMap || t.roughnessMap) {
            const e1756 = this.buildMetalRoughTexture(t.metalnessMap, t.roughnessMap), n1255 = {
                index: this.processTexture(e1756)
            };
            this.applyTextureTransform(n1255, e1756), i900.pbrMetallicRoughness.metallicRoughnessTexture = n1255;
        }
        if (t.map) {
            const e1757 = {
                index: this.processTexture(t.map)
            };
            this.applyTextureTransform(e1757, t.map), i900.pbrMetallicRoughness.baseColorTexture = e1757;
        }
        if (t.emissive) {
            const e1758 = t.emissive.clone().multiplyScalar(t.emissiveIntensity), n1256 = Math.max(e1758.r, e1758.g, e1758.b);
            if (n1256 > 1 && (e1758.multiplyScalar(1 / n1256), console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")), n1256 > 0 && (i900.emissiveFactor = e1758.toArray()), t.emissiveMap) {
                const e1759 = {
                    index: this.processTexture(t.emissiveMap)
                };
                this.applyTextureTransform(e1759, t.emissiveMap), i900.emissiveTexture = e1759;
            }
        }
        if (t.normalMap) {
            const e1760 = {
                index: this.processTexture(t.normalMap)
            };
            t.normalScale && 1 !== t.normalScale.x && (e1760.scale = t.normalScale.x), this.applyTextureTransform(e1760, t.normalMap), i900.normalTexture = e1760;
        }
        if (t.aoMap) {
            const e1761 = {
                index: this.processTexture(t.aoMap),
                texCoord: 1
            };
            1 !== t.aoMapIntensity && (e1761.strength = t.aoMapIntensity), this.applyTextureTransform(e1761, t.aoMap), i900.occlusionTexture = e1761;
        }
        t.transparent ? i900.alphaMode = "BLEND" : t.alphaTest > 0 && (i900.alphaMode = "MASK", i900.alphaCutoff = t.alphaTest), 2 === t.side && (i900.doubleSided = !0), "" !== t.name && (i900.name = t.name), this.serializeUserData(t, i900), this._invokeAll(function(e1762) {
            e1762.writeMaterial && e1762.writeMaterial(t, i900);
        });
        const s458 = n1254.materials.push(i900) - 1;
        return e1755.materials.set(t, s458), s458;
    }
    processMesh(t) {
        const e1764 = this.cache, n1263 = this.json, i901 = [
            t.geometry.uuid
        ];
        if (Array.isArray(t.material)) for(let e1763 = 0, n1257 = t.material.length; e1763 < n1257; e1763++)i901.push(t.material[e1763].uuid);
        else i901.push(t.material.uuid);
        const r666 = i901.join(":");
        if (e1764.meshes.has(r666)) return e1764.meshes.get(r666);
        const s459 = t.geometry;
        let a354;
        if (a354 = t.isLineSegments ? Ov : t.isLineLoop ? Nv : t.isLine ? Fv : t.isPoints ? Iv : t.material.wireframe ? Ov : Uv, !0 !== s459.isBufferGeometry) throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
        const o273 = {}, l218 = {}, h175 = [], c129 = [], u110 = {
            uv: "TEXCOORD_0",
            uv2: "TEXCOORD_1",
            color: "COLOR_0",
            skinWeight: "WEIGHTS_0",
            skinIndex: "JOINTS_0"
        }, d89 = s459.getAttribute("normal");
        void 0 === d89 || this.isNormalizedNormalAttribute(d89) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), s459.setAttribute("normal", this.createNormalizedNormalAttribute(d89)));
        let p77 = null;
        for(let t496 in s459.attributes){
            if ("morph" === t496.slice(0, 5)) continue;
            const n1259 = s459.attributes[t496];
            t496 = u110[t496] || t496.toUpperCase();
            if (/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(t496) || (t496 = "_" + t496), e1764.attributes.has(this.getUID(n1259))) {
                l218[t496] = e1764.attributes.get(this.getUID(n1259));
                continue;
            }
            p77 = null;
            const i902 = n1259.array;
            "JOINTS_0" !== t496 || i902 instanceof Uint16Array || i902 instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), p77 = new oe(new Uint16Array(i902), n1259.itemSize, n1259.normalized));
            const r667 = this.processAccessor(p77 || n1259, s459);
            null !== r667 && (l218[t496] = r667, e1764.attributes.set(this.getUID(n1259), r667));
        }
        if (void 0 !== d89 && s459.setAttribute("normal", d89), 0 === Object.keys(l218).length) return null;
        if (void 0 !== t.morphTargetInfluences && t.morphTargetInfluences.length > 0) {
            const n1261 = [], i904 = [], r668 = {};
            if (void 0 !== t.morphTargetDictionary) for(const e1765 in t.morphTargetDictionary)r668[t.morphTargetDictionary[e1765]] = e1765;
            for(let a355 = 0; a355 < t.morphTargetInfluences.length; ++a355){
                const o272 = {};
                let l219 = !1;
                for(const t499 in s459.morphAttributes){
                    if ("position" !== t499 && "normal" !== t499) {
                        l219 || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), l219 = !0);
                        continue;
                    }
                    const n1260 = s459.morphAttributes[t499][a355], i903 = t499.toUpperCase(), r669 = s459.attributes[t499];
                    if (e1764.attributes.has(this.getUID(n1260))) {
                        o272[i903] = e1764.attributes.get(this.getUID(n1260));
                        continue;
                    }
                    const h174 = n1260.clone();
                    if (!s459.morphTargetsRelative) for(let t498 = 0, e1766 = n1260.count; t498 < e1766; t498++)h174.setXYZ(t498, n1260.getX(t498) - r669.getX(t498), n1260.getY(t498) - r669.getY(t498), n1260.getZ(t498) - r669.getZ(t498));
                    o272[i903] = this.processAccessor(h174, s459), e1764.attributes.set(this.getUID(r669), o272[i903]);
                }
                c129.push(o272), n1261.push(t.morphTargetInfluences[a355]), void 0 !== t.morphTargetDictionary && i904.push(r668[a355]);
            }
            o273.weights = n1261, i904.length > 0 && (o273.extras = {}, o273.extras.targetNames = i904);
        }
        const m57 = Array.isArray(t.material);
        if (m57 && 0 === s459.groups.length) return null;
        const f49 = m57 ? t.material : [
            t.material
        ], g40 = m57 ? s459.groups : [
            {
                materialIndex: 0,
                start: void 0,
                count: void 0
            }
        ];
        for(let t497 = 0, n1258 = g40.length; t497 < n1258; t497++){
            const n1262 = {
                mode: a354,
                attributes: l218
            };
            if (this.serializeUserData(s459, n1262), c129.length > 0 && (n1262.targets = c129), null !== s459.index) {
                let i905 = this.getUID(s459.index);
                void 0 === g40[t497].start && void 0 === g40[t497].count || (i905 += ":" + g40[t497].start + ":" + g40[t497].count), e1764.attributes.has(i905) ? n1262.indices = e1764.attributes.get(i905) : (n1262.indices = this.processAccessor(s459.index, s459, g40[t497].start, g40[t497].count), e1764.attributes.set(i905, n1262.indices)), null === n1262.indices && delete n1262.indices;
            }
            const i906 = this.processMaterial(f49[g40[t497].materialIndex]);
            null !== i906 && (n1262.material = i906), h175.push(n1262);
        }
        o273.primitives = h175, n1263.meshes || (n1263.meshes = []), this._invokeAll(function(e1767) {
            e1767.writeMesh && e1767.writeMesh(t, o273);
        });
        const v37 = n1263.meshes.push(o273) - 1;
        return e1764.meshes.set(r666, v37), v37;
    }
    processCamera(t) {
        const e1768 = this.json;
        e1768.cameras || (e1768.cameras = []);
        const n1264 = t.isOrthographicCamera, i907 = {
            type: n1264 ? "orthographic" : "perspective"
        };
        return n1264 ? i907.orthographic = {
            xmag: 2 * t.right,
            ymag: 2 * t.top,
            zfar: t.far <= 0 ? .001 : t.far,
            znear: t.near < 0 ? 0 : t.near
        } : i907.perspective = {
            aspectRatio: t.aspect,
            yfov: f.degToRad(t.fov),
            zfar: t.far <= 0 ? .001 : t.far,
            znear: t.near < 0 ? 0 : t.near
        }, "" !== t.name && (i907.name = t.type), e1768.cameras.push(i907) - 1;
    }
    processAnimation(t, e1769) {
        const n1265 = this.json, i908 = this.nodeMap;
        n1265.animations || (n1265.animations = []);
        const r670 = (t = Dv.Utils.mergeMorphTargetTracks(t.clone(), e1769)).tracks, s460 = [], a356 = [];
        for(let t501 = 0; t501 < r670.length; ++t501){
            const n1266 = r670[t501], o274 = qo.parseTrackName(n1266.name);
            let l220 = qo.findNode(e1769, o274.nodeName);
            const h176 = ty[o274.propertyName];
            if ("bones" === o274.objectName && (l220 = !0 === l220.isSkinnedMesh ? l220.skeleton.getBoneByName(o274.objectIndex) : void 0), !l220 || !h176) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', n1266.name), null;
            const c130 = 1;
            let u111, d90 = n1266.values.length / n1266.times.length;
            h176 === ty.morphTargetInfluences && (d90 /= l220.morphTargetInfluences.length), !0 === n1266.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (u111 = "CUBICSPLINE", d90 /= 3) : u111 = 2300 === n1266.getInterpolation() ? "STEP" : "LINEAR", a356.push({
                input: this.processAccessor(new oe(n1266.times, c130)),
                output: this.processAccessor(new oe(n1266.values, d90)),
                interpolation: u111
            }), s460.push({
                sampler: a356.length - 1,
                target: {
                    node: i908.get(l220),
                    path: h176
                }
            });
        }
        return n1265.animations.push({
            name: t.name || "clip_" + n1265.animations.length,
            samplers: a356,
            channels: s460
        }), n1265.animations.length - 1;
    }
    processSkin(t) {
        const e1771 = this.json, n1267 = this.nodeMap, i909 = e1771.nodes[n1267.get(t)], r671 = t.skeleton;
        if (void 0 === r671) return null;
        const s461 = t.skeleton.bones[0];
        if (void 0 === s461) return null;
        const a357 = [], o275 = new Float32Array(16 * r671.bones.length), l221 = new xt;
        for(let e1770 = 0; e1770 < r671.bones.length; ++e1770)a357.push(n1267.get(r671.bones[e1770])), l221.copy(r671.boneInverses[e1770]), l221.multiply(t.bindMatrix).toArray(o275, 16 * e1770);
        void 0 === e1771.skins && (e1771.skins = []), e1771.skins.push({
            inverseBindMatrices: this.processAccessor(new oe(o275, 16)),
            joints: a357,
            skeleton: n1267.get(s461)
        });
        return i909.skin = e1771.skins.length - 1;
    }
    processNode(t) {
        const e1772 = this.json, n1268 = this.options, i912 = this.nodeMap;
        e1772.nodes || (e1772.nodes = []);
        const r672 = {};
        if (n1268.trs) {
            const e1773 = t.quaternion.toArray(), n1269 = t.position.toArray(), i910 = t.scale.toArray();
            ey(e1773, [
                0,
                0,
                0,
                1
            ]) || (r672.rotation = e1773), ey(n1269, [
                0,
                0,
                0
            ]) || (r672.translation = n1269), ey(i910, [
                1,
                1,
                1
            ]) || (r672.scale = i910);
        } else t.matrixAutoUpdate && t.updateMatrix(), !1 === ey(t.matrix.elements, [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]) && (r672.matrix = t.matrix.elements);
        if ("" !== t.name && (r672.name = String(t.name)), this.serializeUserData(t, r672), t.isMesh || t.isLine || t.isPoints) {
            const e1774 = this.processMesh(t);
            null !== e1774 && (r672.mesh = e1774);
        } else t.isCamera && (r672.camera = this.processCamera(t));
        if (t.isSkinnedMesh && this.skins.push(t), t.children.length > 0) {
            const e1775 = [];
            for(let i911 = 0, r673 = t.children.length; i911 < r673; i911++){
                const r674 = t.children[i911];
                if (r674.visible || !1 === n1268.onlyVisible) {
                    const t = this.processNode(r674);
                    null !== t && e1775.push(t);
                }
            }
            e1775.length > 0 && (r672.children = e1775);
        }
        this._invokeAll(function(e1776) {
            e1776.writeNode && e1776.writeNode(t, r672);
        });
        const s462 = e1772.nodes.push(r672) - 1;
        return i912.set(t, s462), s462;
    }
    processScene(t) {
        const e1778 = this.json, n1270 = this.options;
        e1778.scenes || (e1778.scenes = [], e1778.scene = 0);
        const i914 = {};
        "" !== t.name && (i914.name = t.name), e1778.scenes.push(i914);
        const r675 = [];
        for(let e1777 = 0, i913 = t.children.length; e1777 < i913; e1777++){
            const i915 = t.children[e1777];
            if (i915.visible || !1 === n1270.onlyVisible) {
                const t = this.processNode(i915);
                null !== t && r675.push(t);
            }
        }
        r675.length > 0 && (i914.nodes = r675), this.serializeUserData(t, i914);
    }
    processObjects(t) {
        const e1779 = new Nr;
        e1779.name = "AuxScene";
        for(let n1271 = 0; n1271 < t.length; n1271++)e1779.children.push(t[n1271]);
        this.processScene(e1779);
    }
    processInput(t) {
        const e1781 = this.options;
        t = t instanceof Array ? t : [
            t
        ], this._invokeAll(function(e1782) {
            e1782.beforeParse && e1782.beforeParse(t);
        });
        const n1273 = [];
        for(let e1780 = 0; e1780 < t.length; e1780++)t[e1780] instanceof Nr ? this.processScene(t[e1780]) : n1273.push(t[e1780]);
        n1273.length > 0 && this.processObjects(n1273);
        for(let t502 = 0; t502 < this.skins.length; ++t502)this.processSkin(this.skins[t502]);
        for(let n1272 = 0; n1272 < e1781.animations.length; ++n1272)this.processAnimation(e1781.animations[n1272], t[0]);
        this._invokeAll(function(e1783) {
            e1783.afterParse && e1783.afterParse(t);
        });
    }
    _invokeAll(t) {
        for(let e1784 = 0, n1274 = this.plugins.length; e1784 < n1274; e1784++)t(this.plugins[e1784]);
    }
}
class ay {
    constructor(t){
        this.writer = t, this.name = "KHR_lights_punctual";
    }
    writeNode(t, e1785) {
        if (!t.isLight) return;
        if (!t.isDirectionalLight && !t.isPointLight && !t.isSpotLight) return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", t);
        const n1275 = this.writer, i916 = n1275.json, r676 = n1275.extensionsUsed, s463 = {};
        t.name && (s463.name = t.name), s463.color = t.color.toArray(), s463.intensity = t.intensity, t.isDirectionalLight ? s463.type = "directional" : t.isPointLight ? (s463.type = "point", t.distance > 0 && (s463.range = t.distance)) : t.isSpotLight && (s463.type = "spot", t.distance > 0 && (s463.range = t.distance), s463.spot = {}, s463.spot.innerConeAngle = (t.penumbra - 1) * t.angle * -1, s463.spot.outerConeAngle = t.angle), void 0 !== t.decay && 2 !== t.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), !t.target || t.target.parent === t && 0 === t.target.position.x && 0 === t.target.position.y && -1 === t.target.position.z || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), r676[this.name] || (i916.extensions = i916.extensions || {}, i916.extensions[this.name] = {
            lights: []
        }, r676[this.name] = !0);
        const a358 = i916.extensions[this.name].lights;
        a358.push(s463), e1785.extensions = e1785.extensions || {}, e1785.extensions[this.name] = {
            light: a358.length - 1
        };
    }
}
class oy {
    constructor(t){
        this.writer = t, this.name = "KHR_materials_unlit";
    }
    writeMaterial(t, e1786) {
        if (!t.isMeshBasicMaterial) return;
        const n1276 = this.writer.extensionsUsed;
        e1786.extensions = e1786.extensions || {}, e1786.extensions[this.name] = {}, n1276[this.name] = !0, e1786.pbrMetallicRoughness.metallicFactor = 0, e1786.pbrMetallicRoughness.roughnessFactor = .9;
    }
}
class ly {
    constructor(t){
        this.writer = t, this.name = "KHR_materials_pbrSpecularGlossiness";
    }
    writeMaterial(t, e1787) {
        if (!t.isGLTFSpecularGlossinessMaterial) return;
        const n1277 = this.writer, i917 = n1277.extensionsUsed, r677 = {};
        e1787.pbrMetallicRoughness.baseColorFactor && (r677.diffuseFactor = e1787.pbrMetallicRoughness.baseColorFactor);
        const s464 = [
            1,
            1,
            1
        ];
        if (t.specular.toArray(s464, 0), r677.specularFactor = s464, r677.glossinessFactor = t.glossiness, e1787.pbrMetallicRoughness.baseColorTexture && (r677.diffuseTexture = e1787.pbrMetallicRoughness.baseColorTexture), t.specularMap) {
            const e1788 = {
                index: n1277.processTexture(t.specularMap)
            };
            n1277.applyTextureTransform(e1788, t.specularMap), r677.specularGlossinessTexture = e1788;
        }
        e1787.extensions = e1787.extensions || {}, e1787.extensions[this.name] = r677, i917[this.name] = !0;
    }
}
class hy {
    constructor(t){
        this.writer = t, this.name = "KHR_materials_clearcoat";
    }
    writeMaterial(t, e1792) {
        if (!t.isMeshPhysicalMaterial) return;
        const n1278 = this.writer, i918 = n1278.extensionsUsed, r678 = {};
        if (r678.clearcoatFactor = t.clearcoat, t.clearcoatMap) {
            const e1789 = {
                index: n1278.processTexture(t.clearcoatMap)
            };
            n1278.applyTextureTransform(e1789, t.clearcoatMap), r678.clearcoatTexture = e1789;
        }
        if (r678.clearcoatRoughnessFactor = t.clearcoatRoughness, t.clearcoatRoughnessMap) {
            const e1790 = {
                index: n1278.processTexture(t.clearcoatRoughnessMap)
            };
            n1278.applyTextureTransform(e1790, t.clearcoatRoughnessMap), r678.clearcoatRoughnessTexture = e1790;
        }
        if (t.clearcoatNormalMap) {
            const e1791 = {
                index: n1278.processTexture(t.clearcoatNormalMap)
            };
            n1278.applyTextureTransform(e1791, t.clearcoatNormalMap), r678.clearcoatNormalTexture = e1791;
        }
        e1792.extensions = e1792.extensions || {}, e1792.extensions[this.name] = r678, i918[this.name] = !0;
    }
}
class cy {
    constructor(t){
        this.writer = t, this.name = "KHR_materials_transmission";
    }
    writeMaterial(t, e1794) {
        if (!t.isMeshPhysicalMaterial || 0 === t.transmission) return;
        const n1279 = this.writer, i919 = n1279.extensionsUsed, r679 = {};
        if (r679.transmissionFactor = t.transmission, t.transmissionMap) {
            const e1793 = {
                index: n1279.processTexture(t.transmissionMap)
            };
            n1279.applyTextureTransform(e1793, t.transmissionMap), r679.transmissionTexture = e1793;
        }
        e1794.extensions = e1794.extensions || {}, e1794.extensions[this.name] = r679, i919[this.name] = !0;
    }
}
class uy {
    constructor(t){
        this.writer = t, this.name = "KHR_materials_volume";
    }
    writeMaterial(t, e1796) {
        if (!t.isMeshPhysicalMaterial || 0 === t.transmission) return;
        const n1280 = this.writer, i920 = n1280.extensionsUsed, r680 = {};
        if (r680.thicknessFactor = t.thickness, t.thicknessMap) {
            const e1795 = {
                index: n1280.processTexture(t.thicknessMap)
            };
            n1280.applyTextureTransform(e1795, t.thicknessMap), r680.thicknessTexture = e1795;
        }
        r680.attenuationDistance = t.attenuationDistance, r680.attenuationColor = t.attenuationColor.toArray(), e1796.extensions = e1796.extensions || {}, e1796.extensions[this.name] = r680, i920[this.name] = !0;
    }
}
Dv.Utils = {
    insertKeyframe: function(t, e1797) {
        const n1281 = .001, i921 = t.getValueSize(), r681 = new t.TimeBufferType(t.times.length + 1), s465 = new t.ValueBufferType(t.values.length + i921), a359 = t.createInterpolant(new t.ValueBufferType(i921));
        let o276;
        if (0 === t.times.length) {
            r681[0] = e1797;
            for(let t = 0; t < i921; t++)s465[t] = 0;
            o276 = 0;
        } else if (e1797 < t.times[0]) {
            if (Math.abs(t.times[0] - e1797) < n1281) return 0;
            r681[0] = e1797, r681.set(t.times, 1), s465.set(a359.evaluate(e1797), 0), s465.set(t.values, i921), o276 = 0;
        } else if (e1797 > t.times[t.times.length - 1]) {
            if (Math.abs(t.times[t.times.length - 1] - e1797) < n1281) return t.times.length - 1;
            r681[r681.length - 1] = e1797, r681.set(t.times, 0), s465.set(t.values, 0), s465.set(a359.evaluate(e1797), t.values.length), o276 = r681.length - 1;
        } else for(let l222 = 0; l222 < t.times.length; l222++){
            if (Math.abs(t.times[l222] - e1797) < n1281) return l222;
            if (t.times[l222] < e1797 && t.times[l222 + 1] > e1797) {
                r681.set(t.times.slice(0, l222 + 1), 0), r681[l222 + 1] = e1797, r681.set(t.times.slice(l222 + 1), l222 + 2), s465.set(t.values.slice(0, (l222 + 1) * i921), 0), s465.set(a359.evaluate(e1797), (l222 + 1) * i921), s465.set(t.values.slice((l222 + 1) * i921), (l222 + 2) * i921), o276 = l222 + 1;
                break;
            }
        }
        return t.times = r681, t.values = s465, o276;
    },
    mergeMorphTargetTracks: function(t, e1798) {
        const n1282 = [], i922 = {}, r682 = t.tracks;
        for(let t503 = 0; t503 < r682.length; ++t503){
            let s466 = r682[t503];
            const a360 = qo.parseTrackName(s466.name), o277 = qo.findNode(e1798, a360.nodeName);
            if ("morphTargetInfluences" !== a360.propertyName || void 0 === a360.propertyIndex) {
                n1282.push(s466);
                continue;
            }
            if (s466.createInterpolant !== s466.InterpolantFactoryMethodDiscrete && s466.createInterpolant !== s466.InterpolantFactoryMethodLinear) {
                if (s466.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), s466 = s466.clone(), s466.setInterpolation(2301);
            }
            const l223 = o277.morphTargetInfluences.length, h177 = o277.morphTargetDictionary[a360.propertyIndex];
            if (void 0 === h177) throw new Error("THREE.GLTFExporter: Morph target name not found: " + a360.propertyIndex);
            let c131;
            if (void 0 === i922[o277.uuid]) {
                c131 = s466.clone();
                const t = new c131.ValueBufferType(l223 * c131.times.length);
                for(let e1799 = 0; e1799 < c131.times.length; e1799++)t[e1799 * l223 + h177] = c131.values[e1799];
                c131.name = (a360.nodeName || "") + ".morphTargetInfluences", c131.values = t, i922[o277.uuid] = c131, n1282.push(c131);
                continue;
            }
            const u112 = s466.createInterpolant(new s466.ValueBufferType(1));
            c131 = i922[o277.uuid];
            for(let t = 0; t < c131.times.length; t++)c131.values[t * l223 + h177] = u112.evaluate(c131.times[t]);
            for(let t504 = 0; t504 < s466.times.length; t504++){
                const e1800 = this.insertKeyframe(c131, s466.times[t504]);
                c131.values[e1800 * l223 + h177] = s466.values[t504];
            }
        }
        return t.tracks = n1282, t;
    }
};
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const dy = (t505)=>void 0 !== t505.material && t505.userData && t505.userData.variantMaterials && !!Array.from(t505.userData.variantMaterials.values()).filter((t)=>py(t.material)), py = (t)=>t && t.isMaterial && !Array.isArray(t);
class my {
    constructor(t){
        this.writer = t, this.name = "KHR_materials_variants", this.variantNames = [];
    }
    beforeParse(t507) {
        const e1801 = new Set;
        for (const n1283 of t507)n1283.traverse((t)=>{
            if (!dy(t)) return;
            const n1284 = t.userData.variantMaterials, i923 = t.userData.variantData;
            for (const [t506, r683] of i923){
                const i924 = n1284.get(r683.index);
                py(i924.material) && e1801.add(t506);
            }
        });
        e1801.forEach((t)=>this.variantNames.push(t));
    }
    writeMesh(t511, e1803) {
        if (!dy(t511)) return;
        const n1285 = t511.userData, i925 = n1285.variantMaterials, r684 = n1285.variantData, s467 = new Map, a361 = new Map, o278 = Array.from(r684.values()).sort((t, e1804)=>t.index - e1804.index);
        for (const [t508, e1802] of o278.entries())a361.set(e1802.index, t508);
        for (const t509 of r684.values()){
            const e1805 = i925.get(t509.index).material;
            if (!py(e1805)) continue;
            const n1286 = this.writer.processMaterial(e1805);
            s467.has(n1286) || s467.set(n1286, {
                material: n1286,
                variants: []
            }), s467.get(n1286).variants.push(a361.get(t509.index));
        }
        const l224 = Array.from(s467.values()).map((t512)=>t512.variants.sort((t, e1806)=>t - e1806) && t512).sort((t, e1807)=>t.material - e1807.material);
        if (0 === l224.length) return;
        const h178 = py(n1285.originalMaterial) ? this.writer.processMaterial(n1285.originalMaterial) : -1;
        for (const t510 of e1803.primitives)h178 >= 0 && (t510.material = h178), t510.extensions = t510.extensions || {}, t510.extensions[this.name] = {
            mappings: l224
        };
    }
    afterParse() {
        if (0 === this.variantNames.length) return;
        const t513 = this.writer.json;
        t513.extensions = t513.extensions || {};
        const e1808 = this.variantNames.map((t)=>({
                name: t
            }));
        t513.extensions[this.name] = {
            variants: e1808
        }, this.writer.extensionsUsed[this.name] = !0;
    }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const fy = Symbol("correlatedObjects"), gy = Symbol("sourceObject"), vy = Symbol("onUpdate");
class yy {
    constructor(t, e1809, n1287 = null){
        this[vy] = t, this[gy] = e1809, this[fy] = n1287;
    }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const xy = new uo, by = new re, _y = new rn(2, 2);
let wy = 0;
const My = Symbol("threeTexture");
class Sy extends yy {
    get [My]() {
        var t;
        return console.assert(null != this[fy] && this[fy].size > 0, "Image correlated object is undefined"), null === (t = this[fy]) || void 0 === t ? void 0 : t.values().next().value;
    }
    constructor(t, e1810, n1288){
        super(t, n1288 = null != n1288 ? n1288 : {
            name: e1810 && e1810.image && e1810.image.src ? e1810.image.src.split("/").pop() : "adhoc_image",
            uri: e1810 && e1810.image && e1810.image.src ? e1810.image.src : "adhoc_image" + wy++
        }, new Set(e1810 ? [
            e1810
        ] : []));
    }
    get name() {
        return this[gy].name || "";
    }
    get uri() {
        return this[gy].uri;
    }
    get bufferView() {
        return this[gy].bufferView;
    }
    get type() {
        return null != this.uri ? "external" : "embedded";
    }
    set name(t) {
        this[gy].name = t;
    }
    async setURI(t) {
        this[gy].uri = t, this[gy].name = t.split("/").pop();
        const e1811 = await new Promise((e1812, n1290)=>{
            xy.load(t, e1812, void 0, n1290);
        }), n1289 = this[My];
        n1289.image = e1811, n1289.needsUpdate = !0, this[vy]();
    }
    async createThumbnail(t514, e1813) {
        const n1291 = new Nr;
        by.map = this[My];
        const i926 = new Fe(_y, by);
        n1291.add(i926);
        const r685 = new mn(-1, 1, 1, -1, 0, 1), { threeRenderer: s468  } = Fd.singleton, a362 = new k(t514, e1813);
        s468.setRenderTarget(a362), s468.render(n1291, r685), s468.setRenderTarget(null);
        const o279 = new Uint8Array(t514 * e1813 * 4);
        s468.readRenderTargetPixels(a362, 0, 0, t514, e1813, o279), Kd.width = t514, Kd.height = e1813;
        const l225 = Kd.getContext("2d"), h179 = l225.createImageData(t514, e1813);
        return h179.data.set(o279), l225.putImageData(h179, 0, 0), new Promise(async (t, e1814)=>{
            Kd.toBlob((n1292)=>{
                if (!n1292) return e1814("Failed to capture thumbnail.");
                t(URL.createObjectURL(n1292));
            }, "image/png");
        });
    }
}
var Ty, Ey;
!function(t) {
    t[t.Nearest = 9728] = "Nearest", t[t.Linear = 9729] = "Linear", t[t.NearestMipmapNearest = 9984] = "NearestMipmapNearest", t[t.LinearMipmapNearest = 9985] = "LinearMipmapNearest", t[t.NearestMipmapLinear = 9986] = "NearestMipmapLinear", t[t.LinearMipmapLinear = 9987] = "LinearMipmapLinear";
}(Ty || (Ty = {})), function(t) {
    t[t.ClampToEdge = 33071] = "ClampToEdge", t[t.MirroredRepeat = 33648] = "MirroredRepeat", t[t.Repeat = 10497] = "Repeat";
}(Ey || (Ey = {}));
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Ay = (()=>{
    const t = [
        Ty.Nearest,
        Ty.Linear,
        Ty.NearestMipmapNearest,
        Ty.LinearMipmapLinear,
        Ty.NearestMipmapLinear,
        Ty.LinearMipmapLinear
    ];
    return (e1815)=>t.indexOf(e1815) > -1;
})(), Ry = (()=>{
    const t = [
        Ty.Nearest,
        Ty.Linear
    ];
    return (e1816)=>t.indexOf(e1816) > -1;
})(), Cy = (()=>{
    const t = [
        Ey.ClampToEdge,
        Ey.MirroredRepeat,
        Ey.Repeat
    ];
    return (e1817)=>t.indexOf(e1817) > -1;
})(), Ly = Symbol("threeTextures"), Py = Symbol("setProperty"), Dy = Symbol("sourceSampler");
class Iy extends yy {
    get [Ly]() {
        return console.assert(null != this[fy] && this[fy].size > 0, "Sampler correlated object is undefined"), this[fy];
    }
    get [Dy]() {
        return console.assert(null != this[gy], "Sampler source is undefined"), this[gy];
    }
    constructor(t, e1818, n1293){
        null == (n1293 = null != n1293 ? n1293 : {}).minFilter && (n1293.minFilter = e1818 ? e1818.minFilter : Ty.LinearMipmapLinear), null == n1293.magFilter && (n1293.magFilter = e1818 ? e1818.magFilter : Ty.Linear), null == n1293.wrapS && (n1293.wrapS = e1818 ? e1818.wrapS : Ey.Repeat), null == n1293.wrapT && (n1293.wrapT = e1818 ? e1818.wrapT : Ey.Repeat), super(t, n1293, new Set(e1818 ? [
            e1818
        ] : []));
    }
    get name() {
        return this[gy].name || "";
    }
    get minFilter() {
        return this[Dy].minFilter;
    }
    get magFilter() {
        return this[Dy].magFilter;
    }
    get wrapS() {
        return this[Dy].wrapS;
    }
    get wrapT() {
        return this[Dy].wrapT;
    }
    setMinFilter(t) {
        this[Py]("minFilter", t);
    }
    setMagFilter(t) {
        this[Py]("magFilter", t);
    }
    setWrapS(t) {
        this[Py]("wrapS", t);
    }
    setWrapT(t) {
        this[Py]("wrapT", t);
    }
    [Py](t515, e1819) {
        const n1294 = this[Dy];
        if (null != n1294) {
            if (((t, e1820)=>{
                switch(t){
                    case "minFilter":
                        return Ay(e1820);
                    case "magFilter":
                        return Ry(e1820);
                    case "wrapS":
                    case "wrapT":
                        return Cy(e1820);
                    default:
                        throw new Error(`Cannot configure property "${t}" on Sampler`);
                }
            })(t515, e1819)) {
                n1294[t515] = e1819;
                for (const n1295 of this[Ly])n1295[t515] = e1819, n1295.needsUpdate = !0;
            }
            this[vy]();
        }
    }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const Oy = Symbol("image"), Ny = Symbol("sampler");
class Fy extends yy {
    constructor(t, e1821, n1296 = null, i927 = null, r686 = null){
        super(t, n1296 || {}, new Set(e1821 ? [
            e1821
        ] : [])), this[Ny] = new Iy(t, e1821, i927), this[Oy] = new Sy(t, e1821, r686);
    }
    get name() {
        return this[gy].name || "";
    }
    set name(t) {
        this[gy].name = t;
    }
    get sampler() {
        return this[Ny];
    }
    get source() {
        return this[Oy];
    }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Uy, ky;
const By = Symbol("texture"), zy = Symbol("transform"), Hy = Symbol("materials"), Vy = Symbol("usage");
var Gy;
!function(t) {
    t[t.Base = 0] = "Base", t[t.MetallicRoughness = 1] = "MetallicRoughness", t[t.Normal = 2] = "Normal", t[t.Occlusion = 3] = "Occlusion", t[t.Emissive = 4] = "Emissive";
}(Gy || (Gy = {}));
class Wy {
    constructor(t, e1823, n1297, i929, r687, s469){
        if (this[Uy] = null, this[ky] = {
            rotation: 0,
            scale: new g(1, 1),
            offset: new g(0, 0)
        }, s469 && n1297) {
            const e1822 = r687.textures ? r687.textures[s469.index] : null, i928 = e1822 && r687.samplers ? r687.samplers[e1822.sampler] : null, a363 = e1822 && r687.images ? r687.images[e1822.source] : null;
            this[zy].rotation = n1297.rotation, this[zy].scale.copy(n1297.repeat), this[zy].offset.copy(n1297.offset), this[By] = new Fy(t, n1297, e1822, i928, a363);
        }
        this.onUpdate = t, this[Hy] = i929, this[Vy] = e1823;
    }
    get texture() {
        return this[By];
    }
    setTexture(t) {
        const e1824 = null != t ? t.source[My] : null;
        let n1298 = 3001;
        if (this[By] = t, this[Hy]) for (const t516 of this[Hy]){
            switch(this[Vy]){
                case Gy.Base:
                    t516.map = e1824;
                    break;
                case Gy.MetallicRoughness:
                    n1298 = 3e3, t516.metalnessMap = e1824, t516.roughnessMap = e1824;
                    break;
                case Gy.Normal:
                    n1298 = 3e3, t516.normalMap = e1824;
                    break;
                case Gy.Occlusion:
                    n1298 = 3e3, t516.aoMap = e1824;
                    break;
                case Gy.Emissive:
                    t516.emissiveMap = e1824;
            }
            t516.needsUpdate = !0;
        }
        e1824 && (e1824.encoding = n1298, e1824.rotation = this[zy].rotation, e1824.repeat = this[zy].scale, e1824.offset = this[zy].offset), this.onUpdate();
    }
}
Uy = By, ky = zy;
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ const jy = Symbol("threeMaterials"), qy = Symbol("baseColorTexture"), Xy = Symbol("metallicRoughnessTexture");
class $y extends yy {
    constructor(t, e1825, n1299, i930){
        super(t, n1299, i930), null == n1299.baseColorFactor && (n1299.baseColorFactor = [
            1,
            1,
            1,
            1
        ]), null == n1299.roughnessFactor && (n1299.roughnessFactor = 1), null == n1299.metallicFactor && (n1299.metallicFactor = 1);
        const { baseColorTexture: r688 , metallicRoughnessTexture: s470  } = n1299, { map: a364 , metalnessMap: o280  } = i930.values().next().value;
        this[qy] = new Wy(t, Gy.Base, a364, i930, e1825, r688 || null), this[Xy] = new Wy(t, Gy.MetallicRoughness, o280, i930, e1825, s470 || null);
    }
    get [jy]() {
        return this[fy];
    }
    get baseColorFactor() {
        return this[gy].baseColorFactor;
    }
    get metallicFactor() {
        return this[gy].metallicFactor;
    }
    get roughnessFactor() {
        return this[gy].roughnessFactor;
    }
    get baseColorTexture() {
        return this[qy];
    }
    get metallicRoughnessTexture() {
        return this[Xy];
    }
    setBaseColorFactor(t) {
        for (const e1826 of this[jy])e1826.color.fromArray(t), e1826.opacity = t[3];
        this[gy].baseColorFactor = t, this[vy]();
    }
    setMetallicFactor(t) {
        for (const e1827 of this[jy])e1827.metalness = t;
        this[gy].metallicFactor = t, this[vy]();
    }
    setRoughnessFactor(t) {
        for (const e1828 of this[jy])e1828.roughness = t;
        this[gy].roughnessFactor = t, this[vy]();
    }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Yy;
const Jy = Symbol("pbrMetallicRoughness"), Ky = Symbol("normalTexture"), Zy = Symbol("occlusionTexture"), Qy = Symbol("emissiveTexture"), tx = Symbol("backingThreeMaterial"), ex = Symbol("applyAlphaCutoff"), nx = Symbol("lazyLoadGLTFInfo"), ix = Symbol("initialize"), rx = Symbol("getLoadedMaterial"), sx = Symbol("ensureMaterialIsLoaded"), ax = Symbol("gltfIndex"), ox = Symbol("setActive"), lx = Symbol("variantIndices"), hx = Symbol("isActive"), cx = Symbol("variantSet"), ux = Symbol("modelVariants");
class dx extends yy {
    constructor(t, e1829, n1300, i931, r689, s471, a365, o281){
        super(t, n1300, a365), this[Yy] = new Set, this[ax] = i931, this[hx] = r689, this[ux] = s471, null == o281 ? this[ix](e1829) : this[nx] = o281;
    }
    get [(Yy = cx, tx)]() {
        return this[fy].values().next().value;
    }
    [ix](t) {
        const e1830 = this[vy], n1301 = this[gy], i932 = this[fy];
        n1301.extensions && n1301.extensions.KHR_materials_pbrSpecularGlossiness && console.warn(`Material ${n1301.name} uses a deprecated extension\n          "KHR_materials_pbrSpecularGlossiness", please use\n          "pbrMetallicRoughness" instead. Specular Glossiness materials are\n          currently supported for rendering, but not for our scene-graph API,\n          nor for auto-generation of USDZ for Quick Look.`), null == n1301.pbrMetallicRoughness && (n1301.pbrMetallicRoughness = {}), this[Jy] = new $y(e1830, t, n1301.pbrMetallicRoughness, i932), null == n1301.emissiveFactor && (n1301.emissiveFactor = [
            0,
            0,
            0
        ]), null == n1301.doubleSided && (n1301.doubleSided = !1), null == n1301.alphaMode && (n1301.alphaMode = "OPAQUE"), null == n1301.alphaCutoff && (n1301.alphaCutoff = .5);
        const { normalTexture: r690 , occlusionTexture: s472 , emissiveTexture: a366  } = n1301, { normalMap: o282 , aoMap: l226 , emissiveMap: h180  } = i932.values().next().value;
        this[Ky] = new Wy(e1830, Gy.Normal, o282, i932, t, r690 || null), this[Zy] = new Wy(e1830, Gy.Occlusion, l226, i932, t, s472 || null), this[Qy] = new Wy(e1830, Gy.Emissive, h180, i932, t, a366 || null);
    }
    async [rx]() {
        if (null != this[nx]) {
            const { set: t , material: e1831  } = await this[nx].doLazyLoad();
            return this[fy] = t, this[ix](this[nx].gltf), this[nx] = void 0, this.ensureLoaded = async ()=>{}, e1831;
        }
        return this[fy].values().next().value;
    }
    [sx]() {
        if (null != this[nx]) throw new Error(`Material "${this.name}" has not been loaded, call 'await\n    myMaterial.ensureLoaded()' before using an unloaded material.`);
    }
    async ensureLoaded() {
        await this[rx]();
    }
    get isLoaded() {
        return null == this[nx];
    }
    get isActive() {
        return this[hx];
    }
    [ox](t) {
        this[hx] = t;
    }
    get name() {
        return this[gy].name;
    }
    set name(t) {
        const e1833 = this[gy];
        if (null != e1833 && (e1833.name = t), null != this[fy]) for (const e1832 of this[fy])e1832.name = t;
    }
    get pbrMetallicRoughness() {
        return this[sx](), this[Jy];
    }
    get normalTexture() {
        return this[sx](), this[Ky];
    }
    get occlusionTexture() {
        return this[sx](), this[Zy];
    }
    get emissiveTexture() {
        return this[sx](), this[Qy];
    }
    get emissiveFactor() {
        return this[sx](), this[gy].emissiveFactor;
    }
    get index() {
        return this[ax];
    }
    [lx]() {
        return this[cx];
    }
    hasVariant(t) {
        const e1834 = this[ux].get(t);
        return null != e1834 && this[cx].has(e1834.index);
    }
    setEmissiveFactor(t) {
        this[sx]();
        for (const e1835 of this[fy])e1835.emissive.fromArray(t);
        this[gy].emissiveFactor = t, this[vy]();
    }
    [ex]() {
        this[sx]();
        const t = this[gy];
        for (const e1836 of this[fy])"MASK" === this[gy].alphaMode ? e1836.alphaTest = t.alphaCutoff : e1836.alphaTest = void 0, e1836.needsUpdate = !0;
    }
    setAlphaCutoff(t) {
        this[sx](), this[gy].alphaCutoff = t, this[ex](), this[vy]();
    }
    getAlphaCutoff() {
        return this[sx](), this[gy].alphaCutoff;
    }
    setDoubleSided(t) {
        this[sx]();
        for (const e1837 of this[fy])e1837.side = t ? 2 : 0, e1837.needsUpdate = !0;
        this[gy].doubleSided = t, this[vy]();
    }
    getDoubleSided() {
        return this[sx](), this[gy].doubleSided;
    }
    setAlphaMode(t517) {
        this[sx]();
        const e1838 = (t, e1839)=>{
            t.transparent = e1839, t.depthWrite = !e1839;
        };
        this[gy].alphaMode = t517;
        for (const n1302 of this[fy])e1838(n1302, "BLEND" === t517), this[ex](), n1302.needsUpdate = !0;
        this[vy]();
    }
    getAlphaMode() {
        return this[sx](), this[gy].alphaMode;
    }
}
var px, mx, fx;
const gx = Symbol("materials"), vx = Symbol("variantToMaterialMap"), yx = Symbol("modelVariants"), xx = Symbol("mesh"), bx = Symbol("children"), _x = Symbol("initialMaterialIdx"), wx = Symbol("activeMaterialIdx");
class Mx {
    constructor(t){
        this.name = "", this[px] = new Array, this.name = t;
    }
}
px = bx;
class Sx extends Mx {
    constructor(t, e1840, n1303, i933){
        super(t.name), this[mx] = new Map, this[fx] = new Map, this[xx] = t;
        const { gltf: r691 , threeGLTF: s473 , threeObjectMap: a367  } = i933;
        this[yx] = n1303, this.mesh.userData.variantData = n1303;
        const o283 = a367.get(t.material);
        null != o283.materials ? this[_x] = this[wx] = o283.materials : console.error(`Primitive (${t.name}) missing initial material reference.`);
        const l227 = t.userData.associations || {};
        if (null == l227.meshes) return void console.error("Mesh is missing primitive index association");
        const h181 = ((r691.meshes || [])[l227.meshes].primitives || [])[l227.primitives];
        if (null != h181) {
            if (null != h181.material) this[gx].set(h181.material, e1840[h181.material]);
            else {
                const t518 = e1840.findIndex((t)=>"Default" === t.name);
                t518 >= 0 ? this[gx].set(t518, e1840[t518]) : console.warn("gltfPrimitive has no material!");
            }
            if (h181.extensions && h181.extensions.KHR_materials_variants) {
                const t = h181.extensions.KHR_materials_variants, i934 = s473.parser.json.extensions.KHR_materials_variants.variants;
                for (const r692 of t.mappings){
                    const t = e1840[r692.material];
                    this[gx].set(r692.material, t);
                    for (const e1841 of r692.variants){
                        const { name: r693  } = i934[e1841];
                        this[vx].set(e1841, t), t[lx]().add(e1841), n1303.has(r693) || n1303.set(r693, {
                            name: r693,
                            index: e1841
                        });
                    }
                }
            }
        } else console.error("Mesh primitive definition is missing.");
    }
    get mesh() {
        return this[xx];
    }
    async setActiveMaterial(t) {
        const e1842 = this[gx].get(t);
        return null != e1842 && (this.mesh.material = await e1842[rx](), this[wx] = t), this.mesh.material;
    }
    getActiveMaterial() {
        return this[gx].get(this[wx]);
    }
    getMaterial(t) {
        return this[gx].get(t);
    }
    async enableVariant(t) {
        if (null == t) return this.setActiveMaterial(this[_x]);
        if (null != this[vx] && this[yx].has(t)) {
            const e1843 = this[yx].get(t);
            return this.enableVariantHelper(e1843.index);
        }
        return null;
    }
    async enableVariantHelper(t) {
        if (null != this[vx] && null != t) {
            const e1844 = this[vx].get(t);
            if (null != e1844) return this.setActiveMaterial(e1844.index);
        }
        return null;
    }
    async instantiateVariants() {
        if (null != this[vx]) for (const t of this[vx].keys()){
            if (null != this.mesh.userData.variantMaterials.get(t).material) continue;
            const e1845 = await this.enableVariantHelper(t);
            null != e1845 && (this.mesh.userData.variantMaterials.get(t).material = e1845);
        }
    }
    get variantInfo() {
        return this[vx];
    }
    addVariant(t, e1846) {
        if (!this.ensureVariantIsUnused(e1846)) return !1;
        this[yx].has(e1846) || this[yx].set(e1846, {
            name: e1846,
            index: this[yx].size
        });
        const n1304 = this[yx].get(e1846).index;
        return t[lx]().add(n1304), this[vx].set(n1304, t), this[gx].set(t.index, t), this.updateVariantUserData(n1304, t), !0;
    }
    deleteVariant(t) {
        if (this.variantInfo.has(t)) {
            this.variantInfo.delete(t);
            const e1847 = this.mesh.userData.variantMaterials;
            null != e1847 && e1847.delete(t);
        }
    }
    updateVariantUserData(t, e1848) {
        e1848[lx]().add(t), this.mesh.userData.variantData = this[yx], this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || new Map;
        this.mesh.userData.variantMaterials.set(t, {
            material: e1848[fy].values().next().value,
            gltfMaterialIndex: e1848.index
        });
    }
    ensureVariantIsUnused(t) {
        const e1849 = this[yx].get(t);
        return null == e1849 || !this.variantInfo.has(e1849.index) || (console.warn(`Primitive cannot add variant '${t}' for this material, it already exists.`), !1);
    }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Tx, Ex, Ax, Rx, Cx, Lx;
mx = gx, fx = vx;
const Px = Symbol("materials"), Dx = Symbol("hierarchy"), Ix = Symbol("roots"), Ox = Symbol("primitives"), Nx = Symbol("correlatedSceneGraph"), Fx = Symbol("prepareVariantsForExport"), Ux = Symbol("switchVariant"), kx = Symbol("threeScene"), Bx = Symbol("materialsFromPoint"), zx = Symbol("materialFromPoint"), Hx = Symbol("variantData"), Vx = Symbol("availableVariants"), Gx = Symbol("modelOnUpdate"), Wx = Symbol("cloneMaterial");
class jx {
    constructor(t, e1850, n1305, i935){
        this.gltf = t, this.gltfElementMap = e1850, this.mapKey = n1305, this.doLazyLoad = i935;
    }
}
class qx {
    constructor(t522, e1851 = ()=>{}){
        this[Tx] = new Array, this[Ex] = new Array, this[Ax] = new Array, this[Rx] = new Array, this[Cx] = ()=>{}, this[Lx] = new Map, this[Gx] = e1851, this[Nx] = t522;
        const { gltf: n1306 , threeGLTF: i936 , gltfElementMap: r694  } = t522;
        this[kx] = i936.scene;
        for (const [t520, s475] of n1306.materials.entries()){
            const a368 = r694.get(s475);
            if (null != a368) this[Px].push(new dx(e1851, n1306, s475, t520, !0, this[Hx], a368));
            else {
                const s476 = (n1306.materials || [])[t520], o284 = t520, l228 = async ()=>{
                    const t = await i936.parser.getDependency("material", o284), e1852 = new Set;
                    return r694.set(s476, e1852), e1852.add(t), {
                        set: e1852,
                        material: t
                    };
                };
                this[Px].push(new dx(e1851, n1306, s476, t520, !1, this[Hx], a368, new jx(n1306, r694, s476, l228)));
            }
        }
        const s474 = new Map, a369 = new Array;
        for (const t521 of i936.scene.children)a369.push(t521);
        for(; a369.length > 0;){
            const e1853 = a369.pop();
            let n1307 = null;
            e1853 instanceof Fe ? (n1307 = new Sx(e1853, this.materials, this[Hx], t522), this[Ox].push(n1307)) : n1307 = new Mx(e1853.name);
            const i937 = s474.get(e1853);
            null != i937 ? i937[bx].push(n1307) : this[Ix].push(n1307), this[Dx].push(n1307);
            for (const t of e1853.children)a369.push(t), s474.set(e1853, n1307);
        }
    }
    get materials() {
        return this[Px];
    }
    [(Tx = Px, Ex = Dx, Ax = Ix, Rx = Ox, Cx = Gx, Lx = Hx, Vx)]() {
        const t523 = Array.from(this[Hx].values());
        return t523.sort((t, e1854)=>t.index - e1854.index), t523.map((t)=>t.name);
    }
    getMaterialByName(t) {
        const e1855 = this[Px].filter((e1856)=>e1856.name === t);
        return e1855.length > 0 ? e1855[0] : null;
    }
    [Bx](t524) {
        return t524.intersectObject(this[kx], !0).map((t)=>{
            const e1857 = this[Dx].find((e1858)=>{
                if (e1858 instanceof Sx) {
                    if (e1858.mesh === t.object) return !0;
                }
                return !1;
            });
            return null != e1857 ? e1857.getActiveMaterial() : null;
        });
    }
    [zx](t) {
        const e1859 = this[Bx](t);
        return e1859.length > 0 ? e1859[0] : null;
    }
    async [Ux](t) {
        for (const e1860 of this[Ox])await e1860.enableVariant(t);
        for (const t525 of this.materials)t525[ox](!1);
        for (const t526 of this[Ox])this.materials[t526.getActiveMaterial().index][ox](!0);
    }
    async [Fx]() {
        const t = new Array;
        for (const e1861 of this[Ox])t.push(e1861.instantiateVariants());
        await Promise.all(t);
    }
    [Wx](t, e1862) {
        const n1309 = this.materials[t];
        n1309.isLoaded || console.error("Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.");
        const i938 = n1309[fy], r695 = JSON.parse(JSON.stringify(n1309[gy]));
        r695.name = e1862;
        this[Nx].gltf.materials.push(r695);
        const s477 = new Set;
        for (const [t527, n1308] of i938.entries()){
            const r696 = n1308.clone();
            r696.name = e1862 + (i938.size > 1 ? "_inst" + t527 : ""), s477.add(r696);
        }
        const a370 = new dx(this[Gx], this[Nx].gltf, r695, this[Px].length, !1, this[Hx], s477);
        return this[Px].push(a370), a370;
    }
    createMaterialInstanceForVariant(t, e1863, n1310, i940 = !0) {
        let r697 = null;
        for (const i939 of this[Ox]){
            const s478 = this[Hx].get(n1310);
            null != s478 && i939.variantInfo.has(s478.index) || null != i939.getMaterial(t) && (this.hasVariant(n1310) || this.createVariant(n1310), null == r697 && (r697 = this[Wx](t, e1863)), i939.addVariant(r697, n1310));
        }
        if (i940 && null != r697) {
            r697[ox](!0), this.materials[t][ox](!1);
            for (const t528 of this[Ox])t528.enableVariant(n1310);
        }
        return r697;
    }
    createVariant(t) {
        this[Hx].has(t) ? console.warn(`Variant '${t}'' already exists`) : this[Hx].set(t, {
            name: t,
            index: this[Hx].size
        });
    }
    hasVariant(t) {
        return this[Hx].has(t);
    }
    setMaterialToVariant(t529, e1864) {
        if (null != this[Vx]().find((t)=>t === e1864)) {
            if (t529 < 0 || t529 >= this.materials.length) console.error("setMaterialToVariant(): materialIndex is out of bounds.");
            else for (const n1311 of this[Ox]){
                const i941 = n1311.getMaterial(t529);
                null != i941 && n1311.addVariant(i941, e1864);
            }
        } else console.warn(`Can't add material to '${e1864}', the variant does not exist.'`);
    }
    updateVariantName(t, e1865) {
        const n1312 = this[Hx].get(t);
        null != n1312 && (n1312.name = e1865, this[Hx].set(e1865, n1312), this[Hx].delete(t));
    }
    deleteVariant(t) {
        const e1866 = this[Hx].get(t);
        if (null != e1866) {
            for (const n1313 of this.materials)n1313.hasVariant(t) && n1313[cx].delete(e1866.index);
            for (const t530 of this[Ox])t530.deleteVariant(e1866.index);
            this[Hx].delete(t);
        }
    }
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Xx = function(t, e1867, n1314, i942) {
    for(var r698, s479 = arguments.length, a371 = s479 < 3 ? e1867 : null === i942 ? i942 = Object.getOwnPropertyDescriptor(e1867, n1314) : i942, o285 = t.length - 1; o285 >= 0; o285--)(r698 = t[o285]) && (a371 = (s479 < 3 ? r698(a371) : s479 > 3 ? r698(e1867, n1314, a371) : r698(e1867, n1314)) || a371);
    return s479 > 3 && a371 && Object.defineProperty(e1867, n1314, a371), a371;
};
const $x = Symbol("currentGLTF"), Yx = Symbol("model"), Jx = Symbol("getOnUpdateMethod"), Kx = Symbol("textureLoader"), Zx = Symbol("originalGltfJson");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Qx = function(t, e1868, n1315, i943) {
    for(var r699, s480 = arguments.length, a372 = s480 < 3 ? e1868 : null === i943 ? i943 = Object.getOwnPropertyDescriptor(e1868, n1315) : i943, o286 = t.length - 1; o286 >= 0; o286--)(r699 = t[o286]) && (a372 = (s480 < 3 ? r699(a372) : s480 > 3 ? r699(e1868, n1315, a372) : r699(e1868, n1315)) || a372);
    return s480 > 3 && a372 && Object.defineProperty(e1868, n1315, a372), a372;
};
const tb = Math.PI / 32, eb = {
    basis: [
        Mu(pu(tb, "rad"))
    ],
    keywords: {
        auto: [
            null
        ]
    }
}, nb = Symbol("autoRotateStartTime"), ib = Symbol("radiansPerSecond"), rb = Symbol("syncRotationRate"), sb = Symbol("onCameraChange"), ab = ((t531)=>{
    var e1869, n1316, i944;
    class r700 extends t531 {
        constructor(){
            super(...arguments), this[e1869] = new Map, this[n1316] = (t532)=>{
                t532.forEach((t533)=>{
                    t533 instanceof MutationRecord && "childList" !== t533.type || (t533.addedNodes.forEach((t)=>{
                        this[Gp](t);
                    }), t533.removedNodes.forEach((t)=>{
                        this[Wp](t);
                    }), this[wp]());
                });
            }, this[i944] = new MutationObserver(this[Hp]);
        }
        connectedCallback() {
            super.connectedCallback();
            for(let t = 0; t < this.children.length; ++t)this[Gp](this.children[t]);
            const { ShadyDOM: t534  } = self;
            null == t534 ? this[Vp].observe(this, {
                childList: !0
            }) : this[Vp] = t534.observeChildren(this, this[Hp]);
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            const { ShadyDOM: t  } = self;
            null == t ? this[Vp].disconnect() : t.unobserveChildren(this[Vp]);
        }
        [(e1869 = zp, n1316 = Hp, i944 = Vp, Mp)](t, e1870) {
            super[Mp](t, e1870);
            const n1317 = this[_p], { annotationRenderer: i945  } = n1317, r701 = n1317.getCamera();
            n1317.shouldRender() && (n1317.updateHotspots(r701.position), i945.domElement.style.display = "", i945.render(n1317, r701));
        }
        updateHotspot(t) {
            const e1871 = this[zp].get(t.name);
            null != e1871 && (e1871.updatePosition(t.position), e1871.updateNormal(t.normal), this[wp]());
        }
        positionAndNormalFromPoint(t, e1872) {
            const n1318 = this[_p], i946 = n1318.getNDC(t, e1872), r702 = n1318.positionAndNormalFromPoint(i946);
            if (null == r702) return null;
            jp.copy(n1318.target.matrixWorld).invert();
            const s481 = Ip(r702.position.applyMatrix4(jp));
            qp.getNormalMatrix(jp);
            const a373 = Ip(r702.normal.applyNormalMatrix(qp));
            let o287 = null;
            return null != r702.uv && (o287 = Op(r702.uv)), {
                position: s481,
                normal: a373,
                uv: o287
            };
        }
        [Gp](t) {
            if (!(t instanceof HTMLElement && 0 === t.slot.indexOf("hotspot"))) return;
            let e1873 = this[zp].get(t.slot);
            null != e1873 ? e1873.increment() : (e1873 = new Eu({
                name: t.slot,
                position: t.dataset.position,
                normal: t.dataset.normal
            }), this[zp].set(t.slot, e1873), this[_p].addHotspot(e1873)), this[_p].queueRender();
        }
        [Wp](t) {
            if (!(t instanceof HTMLElement)) return;
            const e1874 = this[zp].get(t.slot);
            e1874 && (e1874.decrement() && (this[_p].removeHotspot(e1874), this[zp].delete(t.slot)), this[_p].queueRender());
        }
    }
    return r700;
})(((t535)=>{
    var n1319, i947, r703, s482;
    class a374 extends t535 {
        constructor(){
            super(...arguments), this[n1319] = void 0, this[i947] = null, this[r703] = new fo, this[s482] = null, this.variantName = null, this.orientation = "0 0 0", this.scale = "1 1 1";
        }
        get model() {
            return this[Yx];
        }
        get availableVariants() {
            return this.model ? this.model[Vx]() : [];
        }
        get originalGltfJson() {
            return this[Zx];
        }
        [(n1319 = Yx, i947 = $x, r703 = Kx, s482 = Zx, Jx)]() {
            return ()=>{
                this[wp]();
            };
        }
        async createTexture(t, e1875 = "image/png") {
            const n1320 = this[$x], i948 = await new Promise((e1876)=>this[Kx].load(t, e1876));
            return n1320 && i948 ? (i948.encoding = 3001, i948.wrapS = 1e3, i948.wrapT = 1e3, i948.flipY = !1, i948.userData.mimeType = e1875, new Fy(this[Jx](), i948)) : null;
        }
        async updated(t) {
            if (super.updated(t), t.has("variantName")) {
                const t = this[$x], { variantName: e1877  } = this;
                null != t && (await this[Yx][Ux](e1877), this[wp](), this.dispatchEvent(new CustomEvent("variant-applied")));
            }
            if (t.has("orientation") || t.has("scale")) {
                const { modelContainer: t  } = this[_p], e1878 = mu(this.orientation)[0].terms, n1321 = Tu(e1878[0]).number, i949 = Tu(e1878[1]).number, r704 = Tu(e1878[2]).number;
                t.quaternion.setFromEuler(new Ct(i949, r704, n1321, "YXZ"));
                const s483 = mu(this.scale)[0].terms;
                t.scale.set(s483[0].number, s483[1].number, s483[2].number), this[_p].updateBoundingBox(), this[_p].updateShadow(), this[Ep].arRenderer.onUpdateScene(), this[wp]();
            }
        }
        [Sp]() {
            super[Sp]();
            const { currentGLTF: t  } = this[_p];
            if (null != t) {
                const { correlatedSceneGraph: e1879  } = t;
                null != e1879 && t !== this[$x] && (this[Yx] = new qx(e1879, this[Jx]()), this[Zx] = JSON.parse(JSON.stringify(e1879.gltf))), "variants" in t.userData && this.requestUpdate("variantName");
            }
            this[$x] = t, this.dispatchEvent(new CustomEvent("scene-graph-ready"));
        }
        async exportScene(t536) {
            const e1880 = this[_p];
            return new Promise(async (n1322)=>{
                const i950 = {
                    binary: !0,
                    onlyVisible: !0,
                    maxTextureSize: 1 / 0,
                    forcePowerOfTwoTextures: !1,
                    includeCustomExtensions: !1,
                    embedImages: !0
                };
                Object.assign(i950, t536), i950.animations = e1880.animations, i950.truncateDrawRange = !0;
                const r705 = e1880.shadow;
                let s484 = !1;
                null != r705 && (s484 = r705.visible, r705.visible = !1), await this[Yx][Fx]();
                (new Dv).register((t)=>new my(t)).parse(e1880.modelContainer.children[0], (t)=>n1322(new Blob([
                        i950.binary ? t : JSON.stringify(t)
                    ], {
                        type: i950.binary ? "application/octet-stream" : "application/json"
                    })), i950), null != r705 && (r705.visible = s484);
            });
        }
        materialFromPoint(t, e1881) {
            const n1323 = this[_p], i951 = n1323.getNDC(t, e1881);
            return n1323.raycaster.setFromCamera(i951, n1323.getCamera()), this[Yx][zx](n1323.raycaster);
        }
    }
    return Xx([
        e({
            type: String,
            attribute: "variant-name"
        })
    ], a374.prototype, "variantName", void 0), Xx([
        e({
            type: String,
            attribute: "orientation"
        })
    ], a374.prototype, "orientation", void 0), Xx([
        e({
            type: String,
            attribute: "scale"
        })
    ], a374.prototype, "scale", void 0), a374;
})(((t537)=>{
    var n1324, i952, r706;
    class s485 extends t537 {
        constructor(){
            super(...arguments), this.autoRotate = !1, this.autoRotateDelay = 3e3, this.rotationPerSecond = "auto", this[n1324] = performance.now(), this[i952] = 0, this[r706] = (t)=>{
                this.autoRotate && "user-interaction" === t.detail.source && (this[nb] = performance.now());
            };
        }
        connectedCallback() {
            super.connectedCallback(), this.addEventListener("camera-change", this[sb]), this[nb] = performance.now();
        }
        disconnectedCallback() {
            super.disconnectedCallback(), this.removeEventListener("camera-change", this[sb]), this[nb] = performance.now();
        }
        updated(t) {
            super.updated(t), t.has("autoRotate") && (this[nb] = performance.now());
        }
        [(n1324 = nb, i952 = ib, rb)](t) {
            this[ib] = t[0];
        }
        [Mp](t, e1882) {
            if (super[Mp](t, e1882), !this.autoRotate || !this[Dp]() || this[Ep].isPresenting) return;
            const n1325 = Math.min(e1882, t - this[nb] - this.autoRotateDelay);
            n1325 > 0 && (this[_p].yaw = this.turntableRotation + this[ib] * n1325 * .001);
        }
        get turntableRotation() {
            return this[_p].yaw;
        }
        resetTurntableRotation(t = 0) {
            this[_p].yaw = t;
        }
    }
    return r706 = sb, Qx([
        e({
            type: Boolean,
            attribute: "auto-rotate"
        })
    ], s485.prototype, "autoRotate", void 0), Qx([
        e({
            type: Number,
            attribute: "auto-rotate-delay"
        })
    ], s485.prototype, "autoRotateDelay", void 0), Qx([
        tg({
            intrinsics: eb,
            updateHandler: rb
        }),
        e({
            type: String,
            attribute: "rotation-per-second"
        })
    ], s485.prototype, "rotationPerSecond", void 0), s485;
})(((t538)=>{
    var n1326, i953, r707;
    class s486 extends t538 {
        constructor(){
            super(...arguments), this.environmentImage = null, this.skyboxImage = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.exposure = 1, this[n1326] = null, this[i953] = null, this[r707] = (t)=>{
                t.element === this && this[Gu]();
            };
        }
        connectedCallback() {
            super.connectedCallback(), this[Ep].loader.addEventListener("preload", this[ju]);
        }
        disconnectedCallback() {
            super.disconnectedCallback(), this[Ep].loader.removeEventListener("preload", this[ju]);
        }
        updated(t) {
            super.updated(t), t.has("shadowIntensity") && (this[_p].setShadowIntensity(.5 * this.shadowIntensity), this[wp]()), t.has("shadowSoftness") && (this[_p].setShadowSoftness(this.shadowSoftness), this[wp]()), t.has("exposure") && (this[_p].exposure = this.exposure, this[wp]()), (t.has("environmentImage") || t.has("skyboxImage")) && this[Lp]() && this[Gu]();
        }
        hasBakedShadow() {
            return this[_p].bakedShadows.size > 0;
        }
        [(n1326 = Hu, i953 = Wu, r707 = ju, Sp)]() {
            super[Sp](), null != this[Hu] && this[Vu](this[Hu]);
        }
        async [Gu]() {
            const { skyboxImage: t , environmentImage: e1883  } = this;
            null != this[Wu] && (this[Wu](), this[Wu] = null);
            const { textureUtils: n1327  } = this[Ep];
            if (null != n1327) try {
                const { environmentMap: i954 , skybox: r708  } = await new Promise(async (i956, r710)=>{
                    const s487 = n1327.generateEnvironmentMapAndSkybox(ru(t), e1883, {
                        progressTracker: this[Ap]
                    });
                    this[Wu] = ()=>r710(s487), i956(await s487);
                });
                this[_p].background = null != r708 ? r708.name === i954.name ? i954 : r708 : null, this[Vu](i954), this[_p].dispatchEvent({
                    type: "envmap-update"
                });
            } catch (t539) {
                if (t539 instanceof Error) throw this[Vu](null), t539;
            }
        }
        [Vu](t) {
            this[_p].environment !== t && (this[Hu] = t, this[_p].environment = this[Hu], this.dispatchEvent(new CustomEvent("environment-change")), this[wp]());
        }
    }
    return zu([
        e({
            type: String,
            attribute: "environment-image"
        })
    ], s486.prototype, "environmentImage", void 0), zu([
        e({
            type: String,
            attribute: "skybox-image"
        })
    ], s486.prototype, "skyboxImage", void 0), zu([
        e({
            type: Number,
            attribute: "shadow-intensity"
        })
    ], s486.prototype, "shadowIntensity", void 0), zu([
        e({
            type: Number,
            attribute: "shadow-softness"
        })
    ], s486.prototype, "shadowSoftness", void 0), zu([
        e({
            type: Number
        })
    ], s486.prototype, "exposure", void 0), s486;
})(((t540)=>{
    var n1328, i957, r711, s488, a375, o288, l229, h182, c132, u113, d91, p78, m58, f50, g41, v38, y36, x31;
    class b28 extends t540 {
        constructor(){
            super(...arguments), this.cameraControls = !1, this.cameraOrbit = "0deg 75deg 105%", this.cameraTarget = "auto auto auto", this.fieldOfView = "auto", this.minCameraOrbit = "auto", this.maxCameraOrbit = "auto", this.minFieldOfView = "auto", this.maxFieldOfView = "auto", this.interactionPromptThreshold = 3e3, this.interactionPromptStyle = Sg, this.interactionPrompt = wg, this.interactionPolicy = Tg, this.orbitSensitivity = 1, this.touchAction = Eg, this.disableZoom = !1, this.enablePan = !1, this.interpolationDecay = 50, this.bounds = "legacy", this[n1328] = this.shadowRoot.querySelector(".interaction-prompt"), this[i957] = this.shadowRoot.querySelector("#prompt"), this[r711] = [
                this.shadowRoot.querySelector("#finger0"),
                this.shadowRoot.querySelector("#finger1")
            ], this[s488] = this.shadowRoot.querySelector(".pan-target"), this[a375] = 1 / 0, this[o288] = 0, this[l229] = 1 / 0, this[h182] = !1, this[c132] = !1, this[u113] = new pg(this[_p].camera, this[xp], this[_p]), this[d91] = new Ko, this[p78] = !1, this[m58] = !1, this[f50] = !1, this[g41] = ()=>{
                isFinite(this[Qg]) || (this[Qg] = performance.now()), this.interactionPrompt !== Mg || this[Jg] || (this[Yg] = !0);
            }, this[v38] = ()=>{
                this.interactionPrompt === Mg && (this[Yg] = !1, this[Bg].classList.remove("visible"), this[Kg] = 1 / 0, this[Qg] = 1 / 0);
            }, this[y36] = ({ source: t  })=>{
                this[Gg](), this[wp](), t === ug && (this[Jg] = !0, this[Vg]()), this.dispatchEvent(new CustomEvent("camera-change", {
                    detail: {
                        source: t
                    }
                }));
            }, this[x31] = (t)=>{
                "pointer-change-start" === t.type ? this[yp].classList.add("pointer-tumbling") : this[yp].classList.remove("pointer-tumbling");
            };
        }
        getCameraOrbit() {
            const { theta: t , phi: e1884 , radius: n1329  } = this[tv];
            return {
                theta: t,
                phi: e1884,
                radius: n1329,
                toString () {
                    return `${this.theta}rad ${this.phi}rad ${this.radius}m`;
                }
            };
        }
        getCameraTarget() {
            return Ip(this[Ep].isPresenting ? this[Ep].arRenderer.target : this[_p].getTarget());
        }
        getFieldOfView() {
            return this[Ug].getFieldOfView();
        }
        getMinimumFieldOfView() {
            return this[Ug].options.minimumFieldOfView;
        }
        getMaximumFieldOfView() {
            return this[Ug].options.maximumFieldOfView;
        }
        getIdealAspect() {
            return this[_p].idealAspect;
        }
        jumpCameraToGoal() {
            this[ev] = !0, this.requestUpdate(ev, !1);
        }
        resetInteractionPrompt() {
            this[Zg] = 0, this[Kg] = 1 / 0, this[Jg] = !1, this[Yg] = this.interactionPrompt === wg && this.cameraControls;
        }
        zoom(t) {
            const e1885 = new WheelEvent("wheel", {
                deltaY: -30 * t
            });
            this[xp].dispatchEvent(e1885);
        }
        connectedCallback() {
            super.connectedCallback(), this[Ug].addEventListener("change", this[Xg]), this[Ug].addEventListener("pointer-change-start", this[$g]), this[Ug].addEventListener("pointer-change-end", this[$g]);
        }
        disconnectedCallback() {
            super.disconnectedCallback(), this[Ug].removeEventListener("change", this[Xg]), this[Ug].removeEventListener("pointer-change-start", this[$g]), this[Ug].removeEventListener("pointer-change-end", this[$g]);
        }
        updated(t) {
            super.updated(t);
            const e1886 = this[Ug], n1330 = this[_p], i958 = this[xp];
            if (t.has("cameraControls") && (this.cameraControls ? (e1886.enableInteraction(), this.interactionPrompt === wg && (this[Yg] = !0), i958.addEventListener("focus", this[qg]), i958.addEventListener("blur", this[jg])) : (i958.removeEventListener("focus", this[qg]), i958.removeEventListener("blur", this[jg]), e1886.disableInteraction(), this[Vg]()), this[xp].setAttribute("aria-label", this[up])), t.has("disableZoom") && (e1886.disableZoom = this.disableZoom), t.has("enablePan") && (e1886.enablePan = this.enablePan), t.has("bounds") && (n1330.tightBounds = "tight" === this.bounds), (t.has("interactionPrompt") || t.has("cameraControls") || t.has("src")) && (this.interactionPrompt === wg && this.cameraControls && !this[Jg] ? this[Yg] = !0 : this[Vg]()), t.has("interactionPolicy")) {
                const t = this.interactionPolicy;
                e1886.applyOptions({
                    interactionPolicy: t
                });
            }
            if (t.has("touchAction")) {
                const t = this.touchAction;
                e1886.applyOptions({
                    touchAction: t
                }), e1886.updateTouchActionStyle();
            }
            t.has("orbitSensitivity") && (e1886.sensitivity = this.orbitSensitivity), t.has("interpolationDecay") && (e1886.setDamperDecayTime(this.interpolationDecay), n1330.setTargetDamperDecayTime(this.interpolationDecay)), !0 === this[ev] && Promise.resolve().then(()=>{
                e1886.jumpToGoal(), n1330.jumpToGoal(), this[ev] = !1;
            });
        }
        async updateFraming() {
            const t = this[_p], e1887 = t.adjustedFoV(t.framedFoVDeg);
            await t.updateFraming();
            const n1331 = t.adjustedFoV(t.framedFoVDeg), i959 = this[Ug].getFieldOfView() / e1887;
            this[Ug].setFieldOfView(n1331 * i959), this[iv] = !0, this.requestUpdate("maxFieldOfView"), this.requestUpdate("fieldOfView"), this.requestUpdate("minCameraOrbit"), this.requestUpdate("maxCameraOrbit"), this.requestUpdate("cameraOrbit"), await this.updateComplete;
        }
        interact(t541, e1888, n1332) {
            const i960 = this[xp], r712 = this[Hg];
            if ("1" === r712[0].style.opacity) return void console.warn("interact() failed because an existing interaction is running.");
            const s489 = new Array;
            s489.push({
                x: gg(e1888.x),
                y: gg(e1888.y)
            });
            const a376 = [
                {
                    x: s489[0].x(0),
                    y: s489[0].y(0)
                }
            ];
            null != n1332 && (s489.push({
                x: gg(n1332.x),
                y: gg(n1332.y)
            }), a376.push({
                x: s489[1].x(0),
                y: s489[1].y(0)
            }));
            let o289 = performance.now();
            const { width: l230 , height: h183  } = this[_p], c133 = (t)=>{
                for (const [e1889, n1333] of a376.entries()){
                    const { style: s490  } = r712[e1889];
                    s490.transform = `translateX(${l230 * n1333.x}px) translateY(${h183 * n1333.y}px)`, "pointerdown" === t ? s490.opacity = "1" : "pointerup" === t && (s490.opacity = "0");
                    const a377 = {
                        pointerId: e1889 - 5678,
                        pointerType: "touch",
                        target: i960,
                        clientX: l230 * n1333.x,
                        clientY: h183 * n1333.y,
                        altKey: !0
                    };
                    i960.dispatchEvent(new PointerEvent(t, a377));
                }
            }, u114 = ()=>{
                if (this[Ug].isUserChange) {
                    for (const t of this[Hg])t.style.opacity = "0";
                    return void c133("pointercancel");
                }
                const e1890 = Math.min(1, (performance.now() - o289) / t541);
                for (const [t, n1334] of a376.entries())n1334.x = s489[t].x(e1890), n1334.y = s489[t].y(e1890);
                c133("pointermove"), e1890 < 1 ? requestAnimationFrame(u114) : (c133("pointerup"), document.removeEventListener("visibilitychange", d92));
            }, d92 = ()=>{
                let t = 0;
                "hidden" === document.visibilityState ? t = performance.now() - o289 : o289 = performance.now() - t;
            };
            document.addEventListener("visibilitychange", d92), c133("pointerdown"), requestAnimationFrame(u114);
        }
        [(n1328 = Bg, i957 = zg, r711 = Hg, s488 = kg, a375 = Qg, o288 = Zg, l229 = Kg, h182 = Jg, c132 = Yg, u113 = Ug, d91 = tv, p78 = ev, m58 = nv, f50 = iv, sv)](t) {
            const e1891 = this[_p];
            e1891.framedFoVDeg = 180 * t[0] / Math.PI, this[Ug].setFieldOfView(e1891.adjustedFoV(e1891.framedFoVDeg));
        }
        [rv](t) {
            const e1893 = this[Ug];
            if (this[iv]) {
                const { theta: e1892 , phi: n1335  } = this.getCameraOrbit();
                t[0] = e1892, t[1] = n1335, this[iv] = !1;
            }
            e1893.isUserChange = !1, e1893.setOrbit(t[0], t[1], t[2]);
        }
        [ov](t) {
            this[Ug].applyOptions({
                minimumAzimuthalAngle: t[0],
                minimumPolarAngle: t[1],
                minimumRadius: t[2]
            }), this.jumpCameraToGoal();
        }
        [lv](t) {
            this[Ug].applyOptions({
                maximumAzimuthalAngle: t[0],
                maximumPolarAngle: t[1],
                maximumRadius: t[2]
            }), this[Wg](t[2]), this.jumpCameraToGoal();
        }
        [hv](t) {
            this[Ug].applyOptions({
                minimumFieldOfView: 180 * t[0] / Math.PI
            }), this.jumpCameraToGoal();
        }
        [cv](t) {
            const e1894 = this[_p].adjustedFoV(180 * t[0] / Math.PI);
            this[Ug].applyOptions({
                maximumFieldOfView: e1894
            }), this.jumpCameraToGoal();
        }
        [av](t) {
            const [e1895, n1336, i961] = t;
            this[Ep].arRenderer.isPresenting || this[_p].setTarget(e1895, n1336, i961), this[Ug].isUserChange = !1, this[Ep].arRenderer.updateTarget();
        }
        [Mp](t, e1896) {
            if (super[Mp](t, e1896), this[Ep].isPresenting || !this[Dp]()) return;
            const n1337 = this[Ug], i962 = this[_p], r713 = performance.now();
            if (this[Yg]) {
                const t = this.interactionPrompt === wg ? this[fp] : this[Qg];
                this.loaded && r713 > t + this.interactionPromptThreshold && (this[Yg] = !1, this[Kg] = r713, this[Bg].classList.add("visible"));
            }
            if (isFinite(this[Kg]) && this.interactionPromptStyle === Sg) {
                const t = (r713 - this[Kg]) / 5e3 % 1, e1897 = yg(t), s491 = xg(t);
                if (this[zg].style.opacity = `${s491}`, e1897 !== this[Zg]) {
                    const t = e1897 * i962.width * .05, r714 = (e1897 - this[Zg]) * Math.PI / 16;
                    this[zg].style.transform = `translateX(${t}px)`, n1337.isUserChange = !1, n1337.adjustOrbit(r714, 0, 0), this[Zg] = e1897;
                }
            }
            if (n1337.update(t, e1896), i962.updateTarget(e1896)) {
                const t = n1337.isUserChange ? ug : dg;
                this[Xg]({
                    type: "change",
                    source: t
                });
            }
        }
        [Vg]() {
            this[Yg] = !1, this[Bg].classList.remove("visible"), this[Kg] = 1 / 0;
        }
        [Wg](t) {
            const e1898 = 2 * Math.max(this[_p].boundingSphere.radius, t);
            this[Ug].updateNearFar(0, e1898);
        }
        [Gg]() {
            const { theta: t , phi: e1899  } = this[Ug].getCameraSpherical(this[tv]), n1338 = (4 + Math.floor((t % Fg + Ng) / Ig)) % 4, i963 = Math.floor(e1899 / Og), r715 = bg[n1338], s492 = _g[i963];
            this[mp](`View from stage ${s492}${r715}`);
        }
        get [up]() {
            return super[up] + (this.cameraControls ? ". Use mouse, touch or arrow keys to move." : "");
        }
        async [Tp](t) {
            const e1900 = this[Ug], n1339 = this[_p], i964 = n1339.adjustedFoV(n1339.framedFoVDeg);
            super[Tp](t);
            const r716 = n1339.adjustedFoV(n1339.framedFoVDeg) / i964, s493 = e1900.getFieldOfView() * (isFinite(r716) ? r716 : 1);
            e1900.updateAspect(this[_p].aspect), this.requestUpdate("maxFieldOfView", this.maxFieldOfView), await this.updateComplete, this[Ug].setFieldOfView(s493), this.jumpCameraToGoal();
        }
        [Sp]() {
            super[Sp](), this[nv] ? this[iv] = !0 : this[nv] = !0, this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal();
        }
    }
    return g41 = qg, v38 = jg, y36 = Xg, x31 = $g, vg([
        e({
            type: Boolean,
            attribute: "camera-controls"
        })
    ], b28.prototype, "cameraControls", void 0), vg([
        tg({
            intrinsics: Cg,
            observeEffects: !0,
            updateHandler: rv
        }),
        e({
            type: String,
            attribute: "camera-orbit",
            hasChanged: ()=>!0
        })
    ], b28.prototype, "cameraOrbit", void 0), vg([
        tg({
            intrinsics: Dg,
            observeEffects: !0,
            updateHandler: av
        }),
        e({
            type: String,
            attribute: "camera-target",
            hasChanged: ()=>!0
        })
    ], b28.prototype, "cameraTarget", void 0), vg([
        tg({
            intrinsics: Ag,
            observeEffects: !0,
            updateHandler: sv
        }),
        e({
            type: String,
            attribute: "field-of-view",
            hasChanged: ()=>!0
        })
    ], b28.prototype, "fieldOfView", void 0), vg([
        tg({
            intrinsics: Lg,
            updateHandler: ov
        }),
        e({
            type: String,
            attribute: "min-camera-orbit",
            hasChanged: ()=>!0
        })
    ], b28.prototype, "minCameraOrbit", void 0), vg([
        tg({
            intrinsics: Pg,
            updateHandler: lv
        }),
        e({
            type: String,
            attribute: "max-camera-orbit",
            hasChanged: ()=>!0
        })
    ], b28.prototype, "maxCameraOrbit", void 0), vg([
        tg({
            intrinsics: Rg,
            updateHandler: hv
        }),
        e({
            type: String,
            attribute: "min-field-of-view",
            hasChanged: ()=>!0
        })
    ], b28.prototype, "minFieldOfView", void 0), vg([
        tg({
            intrinsics: Ag,
            updateHandler: cv
        }),
        e({
            type: String,
            attribute: "max-field-of-view",
            hasChanged: ()=>!0
        })
    ], b28.prototype, "maxFieldOfView", void 0), vg([
        e({
            type: Number,
            attribute: "interaction-prompt-threshold"
        })
    ], b28.prototype, "interactionPromptThreshold", void 0), vg([
        e({
            type: String,
            attribute: "interaction-prompt-style"
        })
    ], b28.prototype, "interactionPromptStyle", void 0), vg([
        e({
            type: String,
            attribute: "interaction-prompt"
        })
    ], b28.prototype, "interactionPrompt", void 0), vg([
        e({
            type: String,
            attribute: "interaction-policy"
        })
    ], b28.prototype, "interactionPolicy", void 0), vg([
        e({
            type: Number,
            attribute: "orbit-sensitivity"
        })
    ], b28.prototype, "orbitSensitivity", void 0), vg([
        e({
            type: String,
            attribute: "touch-action"
        })
    ], b28.prototype, "touchAction", void 0), vg([
        e({
            type: Boolean,
            attribute: "disable-zoom"
        })
    ], b28.prototype, "disableZoom", void 0), vg([
        e({
            type: Boolean,
            attribute: "enable-pan"
        })
    ], b28.prototype, "enablePan", void 0), vg([
        e({
            type: Number,
            attribute: "interpolation-decay"
        })
    ], b28.prototype, "interpolationDecay", void 0), vg([
        e({
            type: String,
            attribute: "bounds"
        })
    ], b28.prototype, "bounds", void 0), b28;
})(((t542)=>{
    var n1340, i965, r717, s494, a378, o290, l231, h184, c134, u115;
    class d93 extends t542 {
        constructor(){
            super(...arguments), this.ar = !1, this.arScale = "auto", this.arPlacement = "floor", this.arModes = "webxr scene-viewer", this.iosSrc = null, this.xrEnvironment = !1, this[n1340] = !1, this[i965] = this.shadowRoot.querySelector(".ar-button"), this[r717] = document.createElement("a"), this[s494] = new Set, this[a378] = tf, this[o290] = !1, this[l231] = (t)=>{
                t.preventDefault(), this.activateAR();
            }, this[h184] = ({ status: t  })=>{
                t !== Zu && this[Ep].arRenderer.presentedScene !== this[_p] || (this.setAttribute("ar-status", t), this.dispatchEvent(new CustomEvent("ar-status", {
                    detail: {
                        status: t
                    }
                })), t === Zu ? this.removeAttribute("ar-tracking") : t === Qu && this.setAttribute("ar-tracking", nd));
            }, this[c134] = ({ status: t  })=>{
                this.setAttribute("ar-tracking", t), this.dispatchEvent(new CustomEvent("ar-tracking", {
                    detail: {
                        status: t
                    }
                }));
            }, this[u115] = (t)=>{
                "_apple_ar_quicklook_button_tapped" == t.data && this.dispatchEvent(new CustomEvent("quick-look-button-tapped"));
            };
        }
        get canActivateAR() {
            return this[of] !== tf;
        }
        connectedCallback() {
            super.connectedCallback(), this[Ep].arRenderer.addEventListener("status", this[df]), this.setAttribute("ar-status", Zu), this[Ep].arRenderer.addEventListener("tracking", this[pf]), this[hf].addEventListener("message", this[mf]);
        }
        disconnectedCallback() {
            super.disconnectedCallback(), this[Ep].arRenderer.removeEventListener("status", this[df]), this[Ep].arRenderer.removeEventListener("tracking", this[pf]), this[hf].removeEventListener("message", this[mf]);
        }
        async update(t) {
            super.update(t), t.has("arScale") && (this[_p].canScale = "fixed" !== this.arScale), t.has("arPlacement") && (this[_p].updateShadow(), this[wp]()), (t.has("ar") || t.has("arModes") || t.has("src") || t.has("iosSrc")) && (t.has("arModes") && (this[lf] = Ym(this.arModes)), this[ff]());
        }
        async activateAR() {
            switch(this[of]){
                case Km:
                    this[sf]();
                    break;
                case Qm:
                    await this[nf]();
                    break;
                case Zm:
                    this[rf]();
                    break;
                default:
                    console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities");
            }
        }
        async [(n1340 = af, i965 = ef, r717 = hf, s494 = lf, a378 = of, o290 = cf, l231 = uf, h184 = df, c134 = pf, u115 = mf, ff)]() {
            if (this[of] = tf, this.ar) {
                if (null != this.src) for (const t of this[lf]){
                    if ("webxr" === t && ph && !Xm && await this[Ep].arRenderer.supportsPresentation()) {
                        this[of] = Qm;
                        break;
                    }
                    if ("scene-viewer" === t && xh && !$m) {
                        this[of] = Zm;
                        break;
                    }
                    if ("quick-look" === t && gh) {
                        this[of] = Km;
                        break;
                    }
                }
                !this.canActivateAR && null != this.iosSrc && gh && (this[of] = Km);
            }
            if (this.canActivateAR) this[ef].classList.add("enabled"), this[ef].addEventListener("click", this[uf]);
            else if (this[ef].classList.contains("enabled")) {
                this[ef].removeEventListener("click", this[uf]), this[ef].classList.remove("enabled");
                const t = ed;
                this.setAttribute("ar-status", t), this.dispatchEvent(new CustomEvent("ar-status", {
                    detail: {
                        status: t
                    }
                }));
            }
        }
        async [nf]() {
            console.log("Attempting to present in AR with WebXR..."), await this[gf]();
            try {
                this[ef].removeEventListener("click", this[uf]);
                const { arRenderer: t  } = this[Ep];
                t.placeOnWall = "wall" === this.arPlacement, await t.present(this[_p], this.xrEnvironment);
            } catch (t) {
                console.warn("Error while trying to present in AR with WebXR"), console.error(t), await this[Ep].arRenderer.stopPresenting(), Xm = !0, console.warn("Falling back to next ar-mode"), await this[ff](), this.activateAR();
            } finally{
                this[ff]();
            }
        }
        async [gf]() {
            this.loaded || (this[cf] = !0, this[gp](), await ((t, e1901, n1341 = null)=>new Promise((i966)=>{
                    t.addEventListener(e1901, function r718(s495) {
                        n1341 && !n1341(s495) || (i966(s495), t.removeEventListener(e1901, r718));
                    });
                }))(this, "load"), this[cf] = !1);
        }
        [Lp]() {
            return super[Lp]() || this[cf];
        }
        [rf]() {
            const t = self.location.toString(), e1902 = new URL(t), n1342 = new URL(this.src, t), i967 = new URLSearchParams(n1342.search);
            if (e1902.hash = "#model-viewer-no-ar-fallback", i967.set("mode", "ar_preferred"), i967.has("disable_occlusion") || i967.set("disable_occlusion", "true"), "fixed" === this.arScale && i967.set("resizable", "false"), "wall" === this.arPlacement && i967.set("enable_vertical_placement", "true"), i967.has("sound")) {
                const e1903 = new URL(i967.get("sound"), t);
                i967.set("sound", e1903.toString());
            }
            if (i967.has("link")) {
                const e1904 = new URL(i967.get("link"), t);
                i967.set("link", e1904.toString());
            }
            const r719 = `intent://arvr.google.com/scene-viewer/1.0?${i967.toString() + "&file=" + encodeURIComponent(n1342.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(e1902.toString())};end;`;
            self.addEventListener("hashchange", ()=>{
                "#model-viewer-no-ar-fallback" === self.location.hash && ($m = !0, self.history.back(), console.warn("Error while trying to present in AR with Scene Viewer"), console.warn("Falling back to next ar-mode"), this[ff]());
            }, {
                once: !0
            }), this[hf].setAttribute("href", r719), console.log("Attempting to present in AR with Scene Viewer..."), this[hf].click();
        }
        async [sf]() {
            const t = !this.iosSrc;
            this[ef].classList.remove("enabled");
            const e1905 = t ? await this.prepareUSDZ() : this.iosSrc, n1343 = new URL(e1905, self.location.toString());
            "fixed" === this.arScale && (n1343.hash && (n1343.hash += "&"), n1343.hash += "allowsContentScaling=0");
            const i968 = this[hf];
            i968.setAttribute("rel", "ar");
            const r720 = document.createElement("img");
            i968.appendChild(r720), i968.setAttribute("href", n1343.toString()), t && i968.setAttribute("download", "model.usdz"), console.log("Attempting to present in AR with Quick Look..."), i968.click(), i968.removeChild(r720), t && URL.revokeObjectURL(e1905), this[ef].classList.add("enabled");
        }
        async prepareUSDZ() {
            const t = this[Ap].beginActivity();
            await this[gf]();
            const e1906 = this[_p], n1344 = e1906.shadow;
            let i969 = !1;
            null != n1344 && (i969 = n1344.visible, n1344.visible = !1), t(.2);
            const r721 = new km, s496 = await r721.parse(e1906.modelContainer), a379 = new Blob([
                s496
            ], {
                type: "model/vnd.usdz+zip"
            }), o291 = URL.createObjectURL(a379);
            return t(1), null != n1344 && (n1344.visible = i969), o291;
        }
    }
    return qm([
        e({
            type: Boolean,
            attribute: "ar"
        })
    ], d93.prototype, "ar", void 0), qm([
        e({
            type: String,
            attribute: "ar-scale"
        })
    ], d93.prototype, "arScale", void 0), qm([
        e({
            type: String,
            attribute: "ar-placement"
        })
    ], d93.prototype, "arPlacement", void 0), qm([
        e({
            type: String,
            attribute: "ar-modes"
        })
    ], d93.prototype, "arModes", void 0), qm([
        e({
            type: String,
            attribute: "ios-src"
        })
    ], d93.prototype, "iosSrc", void 0), qm([
        e({
            type: Boolean,
            attribute: "xr-environment"
        })
    ], d93.prototype, "xrEnvironment", void 0), d93;
})(((t543)=>{
    var n1345, i970, r722, s497, a380, o292, l232, h185, c135, u116, d94, p79, m59, f51;
    class g42 extends t543 {
        constructor(...t544){
            super(...t544), this.poster = null, this.reveal = dv, this.loading = mv, this.generateSchema = !1, this.seamlessPoster = !1, this[n1345] = !1, this[i970] = !1, this[r722] = 0, this[s497] = null, this[a380] = this.shadowRoot.querySelector(".slot.poster"), this[o292] = this.shadowRoot.querySelector("#default-poster"), this[l232] = this.shadowRoot.querySelector("#default-progress-bar > .bar"), this[h185] = this.shadowRoot.querySelector("#default-progress-bar > .mask"), this[c135] = this[bv].getAttribute("aria-label"), this[u116] = ((t, e1908)=>{
                let n1346 = null;
                const i971 = (...i972)=>{
                    null == n1346 && (t(...i972), n1346 = self.setTimeout(()=>n1346 = null, e1908));
                };
                return i971.flush = ()=>{
                    null != n1346 && (self.clearTimeout(n1346), n1346 = null);
                }, i971;
            })((t)=>{
                const e1909 = this[vv].parentNode;
                requestAnimationFrame(()=>{
                    this[yv].style.opacity = "" + .2 * (1 - t), this[vv].style.transform = `scaleX(${t})`, 0 === t && (e1909.removeChild(this[vv]), e1909.appendChild(this[vv])), 1 === t ? this[vv].classList.add("hide") : this[vv].classList.remove("hide");
                });
            }, 100), this[d94] = ()=>{
                this.reveal !== pv && this.reveal !== dv && this.dismissPoster();
            }, this[p79] = (t)=>{
                if (this.reveal !== pv) switch(t.keyCode){
                    case 32:
                    case 13:
                        this.dismissPoster();
                }
            }, this[m59] = (t)=>{
                const e1910 = t.detail.totalProgress;
                this[Tv] = Math.max(e1910, this[Tv]), 1 === e1910 && (this[Sv].flush(), !this[Pp]() || null == this[_v] && this.reveal !== dv || this[wv]()), this[Sv](e1910), this.dispatchEvent(new CustomEvent("progress", {
                    detail: {
                        totalProgress: e1910
                    }
                }));
            }, this[f51] = ()=>{
                this[Ev] = !0;
                const t = this.getRootNode();
                t && t.activeElement === this && this[xp].focus();
                const e1911 = this[bv];
                e1911.setAttribute("aria-hidden", "true"), e1911.tabIndex = -1, this.dispatchEvent(new CustomEvent("poster-dismissed"));
            };
            const e1907 = self.ModelViewerElement || {}, g43 = e1907.dracoDecoderLocation || "https://www.gstatic.com/draco/versioned/decoders/1.4.1/";
            Jc.setDRACODecoderLocation(g43);
            const v39 = e1907.ktx2TranscoderLocation || "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
            Jc.setKTX2TranscoderLocation(v39), e1907.meshoptDecoderLocation && Jc.setMeshoptDecoderLocation(e1907.meshoptDecoderLocation);
        }
        static set dracoDecoderLocation(t) {
            Jc.setDRACODecoderLocation(t);
        }
        static get dracoDecoderLocation() {
            return Jc.getDRACODecoderLocation();
        }
        static set ktx2TranscoderLocation(t) {
            Jc.setKTX2TranscoderLocation(t);
        }
        static get ktx2TranscoderLocation() {
            return Jc.getKTX2TranscoderLocation();
        }
        static set meshoptDecoderLocation(t) {
            Jc.setMeshoptDecoderLocation(t);
        }
        static get meshoptDecoderLocation() {
            return Jc.getMeshoptDecoderLocation();
        }
        static mapURLs(t) {
            Fd.singleton.loader[Xc].manager.setURLModifier(t);
        }
        dismissPoster() {
            this[Pp]() ? this[wv]() : (this[_v] = gv, this[gp]());
        }
        showPoster() {
            const t = this[xv], e1912 = this[bv];
            e1912.removeAttribute("tabindex"), e1912.removeAttribute("aria-hidden"), t.classList.add("show");
            const n1347 = this.modelIsVisible;
            this[Mv] = !1, this[cp](n1347), this[Ev] = !1;
        }
        getDimensions() {
            return Ip(this[_p].size);
        }
        connectedCallback() {
            super.connectedCallback(), this[xv].addEventListener("click", this[Cv]), this[xv].addEventListener("keydown", this[Lv]), this[Ap].addEventListener("progress", this[Pv]);
        }
        disconnectedCallback() {
            super.disconnectedCallback(), this[xv].removeEventListener("click", this[Cv]), this[xv].removeEventListener("keydown", this[Lv]), this[Ap].removeEventListener("progress", this[Pv]);
        }
        async updated(t) {
            super.updated(t), t.has("poster") && null != this.poster && (this[bv].style.backgroundImage = `url(${this.poster})`), t.has("alt") && this[bv].setAttribute("aria-label", this[dp]), (t.has("reveal") || t.has("loading")) && this[gp](), t.has("generateSchema") && (!0 === this.generateSchema ? this[_p].updateSchema(this.src) : this[_p].updateSchema(null)), t.has("seamlessPoster") && (!0 === this.seamlessPoster ? this[xv].classList.add("quick") : this[xv].classList.remove("quick"));
        }
        [(n1345 = Mv, i970 = Ev, r722 = Tv, s497 = _v, a380 = xv, o292 = bv, l232 = vv, h185 = yv, c135 = Rv, u116 = Sv, d94 = Cv, p79 = Lv, m59 = Pv, Lp)]() {
            return !!this.src && (null != this[_v] || this.loading === fv || this.reveal === dv && this[hp]);
        }
        [Pp]() {
            const { src: t  } = this;
            return !!t && super[Pp]() && 1 === this[Tv];
        }
        [(f51 = Av, wv)]() {
            this[_v] = null;
            const t = this[xv];
            if (t.classList.contains("show")) {
                const e1913 = this.modelIsVisible;
                this[Mv] = !0, this[cp](e1913), requestAnimationFrame(()=>{
                    t.classList.remove("show"), !0 === this.seamlessPoster ? this[Av]() : t.addEventListener("transitionend", this[Av], {
                        once: !0
                    });
                });
            } else this[Ev] = !0;
        }
        [Cp]() {
            return super[Cp]() && this[Mv];
        }
        [Dp]() {
            return super[Dp]() && this[Ev];
        }
        async [gp]() {
            this[Tv] = 0, !0 === this.generateSchema && this[_p].updateSchema(this.src), null != this[_p].currentGLTF && null != this.src && this[Lp]() || this.showPoster(), this[mp]("Loading"), await super[gp]();
        }
    }
    return uv([
        e({
            type: String
        })
    ], g42.prototype, "poster", void 0), uv([
        e({
            type: String
        })
    ], g42.prototype, "reveal", void 0), uv([
        e({
            type: String
        })
    ], g42.prototype, "loading", void 0), uv([
        e({
            type: Boolean,
            attribute: "generate-schema"
        })
    ], g42.prototype, "generateSchema", void 0), uv([
        e({
            type: Boolean,
            attribute: "seamless-poster"
        })
    ], g42.prototype, "seamlessPoster", void 0), g42;
})(((t545)=>{
    var n1348;
    class i973 extends t545 {
        constructor(...t546){
            super(t546), this.autoplay = !1, this.animationName = void 0, this.animationCrossfadeDuration = 300, this[n1348] = !0, this[_p].subscribeMixerEvent("loop", (t)=>{
                const e1914 = t.action._loopCount;
                this.dispatchEvent(new CustomEvent("loop", {
                    detail: {
                        count: e1914
                    }
                }));
            }), this[_p].subscribeMixerEvent("finished", ()=>{
                this[kp] = !0, this.dispatchEvent(new CustomEvent("finished"));
            });
        }
        get availableAnimations() {
            return this.loaded ? this[_p].animationNames : [];
        }
        get duration() {
            return this[_p].duration;
        }
        get paused() {
            return this[kp];
        }
        get currentTime() {
            return this[_p].animationTime;
        }
        set currentTime(t) {
            this[_p].animationTime = t, this[wp]();
        }
        get timeScale() {
            return this[_p].animationTimeScale;
        }
        set timeScale(t) {
            this[_p].animationTimeScale = t;
        }
        pause() {
            this[kp] || (this[kp] = !0, this.dispatchEvent(new CustomEvent("pause")));
        }
        play(t) {
            this.availableAnimations.length > 0 && (this[kp] = !1, this[Up](t), this.dispatchEvent(new CustomEvent("play")));
        }
        [(n1348 = kp, Sp)]() {
            super[Sp](), this[kp] = !0, this.autoplay && this.play();
        }
        [Mp](t, e1915) {
            super[Mp](t, e1915), this[kp] || !this[Dp]() && !this[Ep].isPresenting || (this[_p].updateAnimation(e1915 / 1e3), this[wp]());
        }
        updated(t) {
            super.updated(t), t.has("autoplay") && this.autoplay && this.play(), t.has("animationName") && this[Up]();
        }
        async [gp]() {
            return this[_p].stopAnimation(), super[gp]();
        }
        [Up](t = Bp) {
            var e1916;
            const n1349 = null !== (e1916 = t.repetitions) && void 0 !== e1916 ? e1916 : 1 / 0, i974 = t.pingpong ? 2202 : 1 === n1349 ? 2200 : 2201;
            this[_p].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3, i974, n1349), this[kp] && (this[_p].updateAnimation(0), this[wp]());
        }
    }
    return Fp([
        e({
            type: Boolean
        })
    ], i973.prototype, "autoplay", void 0), Fp([
        e({
            type: String,
            attribute: "animation-name"
        })
    ], i973.prototype, "animationName", void 0), Fp([
        e({
            type: Number,
            attribute: "animation-crossfade-duration"
        })
    ], i973.prototype, "animationCrossfadeDuration", void 0), i973;
})(((t547)=>{
    var e1917;
    const n1350 = Symbol("endPolyfillCoordination");
    return e1917 = n1350, class extends t547 {
        constructor(){
            super(...arguments), this[e1917] = null;
        }
        connectedCallback() {
            super.connectedCallback && super.connectedCallback(), null == this[n1350] && (this[n1350] = ((t)=>{
                if (null == t.shadowRoot || t.hasAttribute("data-js-focus-visible")) return ()=>{};
                if (!self.applyFocusVisiblePolyfill) {
                    const e1918 = ()=>{
                        self.applyFocusVisiblePolyfill(t.shadowRoot);
                    };
                    return self.addEventListener("focus-visible-polyfill-ready", e1918, {
                        once: !0
                    }), ()=>{
                        self.removeEventListener("focus-visible-polyfill-ready", e1918);
                    };
                }
                return self.applyFocusVisiblePolyfill(t.shadowRoot), ()=>{};
            })(this));
        }
        disconnectedCallback() {
            super.disconnectedCallback && super.disconnectedCallback(), null != this[n1350] && (this[n1350](), this[n1350] = null);
        }
    };
})(Np)))))))));
customElements.define("model-viewer", ab);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["3BwQ7","eSWDu"], "eSWDu", "parcelRequire94c2")

//# sourceMappingURL=index.eda90e5b.js.map
